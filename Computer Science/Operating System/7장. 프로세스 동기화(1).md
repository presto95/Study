# 프로세스 동기화

## 배경

생산자 소비자 문제에서 각 프로세스는 공유 메모리에 접근하므로 공통 변수와 버퍼를 공유한다. 이 때 공유 변수의 값이 결과에 영향을 주므로 각 프로세스에서의 수행이 병행적으로 이루어지면 실행되는 순서에 따라 올바르게 동작하지 않을 수 있다.

이처럼 병행으로 수행되는 여러 프로세스가 공통된 데이터를 조작할 때 결과가 접근 순서에 의해 결정되면, **경합 상태*race condition***가 존재한다고 말한다.

어떠한 코드 문장이 원자적으로 수행되어도 원하지 않는 결과가 발생할 수 있다.

```c
// P1 : a = a + 1; b = b + 1;
// P2 : b = b * 2; a = a * 2;
a = a + 1;  // P1
b = b * 2;  // P2
b = b + 1;  // P1
a = a * 2;  // P2
```

위의 코드에서 변수 a와 b의 값이 같을 것을 예상하였으나 기대한 결과가 나오지 않는다.

**프로세스 동기화**를 통해 이러한 문제를 해결한다.

## 임계 구역 문제

**Critical Section**

프로세스 코드의 일부분. 다른 프로세스와 공동으로 사용하는 변수, 테이블, 파일 등을 변경하는 부분을 말한다.

임계 구역의 실행은 상호 배타적으로 일어나야 한다. 즉 한 프로세스가 임계 구역을 실행하고 있다면 다른 프로세스는 임계 구역에 진입할 수 없어야 한다.

이를 위해 각 프로세스는 임계 구역에 진입하기 전 허가를 받아야 하며, 이를 **진입 구역*entry section***이라고 한다.

허가를 받아 임계 구역을 실행한 후 다른 프로세스들이 진입할 수 있도록 해야 하며, 이러한 처리를 하기 위한 구역을 **출구 구역*exit section***이라고 한다.

진입 구역, 임계 구역, 출구 구역이 아닌 코드 부분을 **잔류 구역*remainder section***이라고 한다.

> remainder -> **entry -> critical -> exit** -> remainder

임계 구역 문제를 해결하는 메커니즘은 다음의 요건을 충족해야 한다.

- 상호 배제*mutual exclusive*
  - 한 프로세스가 임계 구역에서 실행하고 있으면 다른 어떠한 프로세스도 임계 구역에 진입해서는 안된다.
- 진행*progress*
  - 여러 개의 프로세스가 임계 구역에 진입하고자 하면 이들의 진입 순서는 이들에 의해 결정되어야 하며, 이 선택은 무한정 연기되어서는 안 된다.
- 한계 대기*bounded waiting*
  - 한 프로세스가 임계 구역에 진입하고자 요청한 이후 해당 요청에 허용될 때까지, 다른 프로세스가 임계 구역에 진입할 수 있는 횟수가 제한되어야 한다.

## 소프트웨어 접근 방법

### 두 개의 프로세스를 위한 해결책

#### 첫 번째

- 공유 변수 `int turn`
- 초기 값 `turn = 1 or 0`
- `turn`이 `i`이면 `P`<sub>`i`</sub>가 임계 지역에 진입할 수 있다.

```c
do {
  // entry section
  while(turn != i);

  // critical section

  // exit section
  turn = j;

  // remainder section
} while(1);
```

이 경우 상호 배제는 만족하지만 진행 요구 조건은 충족하지 않는다. 다른 프로세스가 진입하고자 하더라도 해당 프로세스의 차례가 아니면 무조건 기다려야 하기 때문이다.

특히 한 프로세스가 예기치 임계 구역을 실행하던 도중 예기치 않게 종료되면 다른 프로세스는 임계 구역에 영원히 진입할 수 없게 된다.

#### 두 번째

- 공유 변수 `boolean flag[2]`
- 초기 값 `flag[0] = flag[1] = false`
- `flag[i]`가 `true`이면 `P`<sub>`i`</sub>가 임계 구역에 진입할 준비가 되었음을 나타낸다.

```c
do {
  // entry section
  flag[i] = true; // (1)
  while(flag[j]); // (2)

  // critical section

  // exit section
  flag[i] = false;

  // remainder section
} while(1);
```

이 경우 상호 배제는 만족하지만 진행 요구 조건은 충족하지 않는다. 다른 프로세스가 진입하고자 하더라도 해당 프로세스의 차례가 아니면 무조건 기다려야 하기 때문이다.

특히 `flag` 모두 `true`가 된 경우 두 프로세스는 영원히 기다리게 된다.

또한 프로세스가 자신의 `flag` 값을 `true`로 설정한 후 예기치 않게 종료되면 다른 프로세스는 영원히 진입할 수 없게 된다.

코드에서 (1)과 (2)의 순서를 바꾸면 상호 배제를 만족시키지 않게 된다.

#### 세 번째

- 공유 변수 `boolean flag[2]`, `int turn`
- 초기 값 `flag[0] = flag[1] = false`, `turn = 0 or 1`

```c
do {
  // entry section
  flag[i] = true;
  while(flag[j]) {
    if(turn == j) {
      flag[i] = false;
      while(turn == j);
      flag[i] = true;
    }
  }

  // critical section

  // exit section
  turn = j;
  flag[i] = false;

  // remainder section
} whlie(1);
```

두 프로세스 모두 진입하고자 하는 경우(`flag[0] = flag[1] = true`) `turn` 값이 진입하는 프로세스를 결정하게 해주므로 세 가지 요구 조건을 모두 충족하게 된다.

### 네 번째

- 공유 변수 `boolean flag[2]`, `int turn`
- 초기 값 `flag[0] = flag[1] = false`, `turn = 0 or 1`

```c
do {
  // entry section
  flag[i] = true; // (1)
  turn = j;       // (2)
  while(flag[j] && turn == j);

  // critical section

  // exit section
  flag[i] = false;

  // remainder section
} while(1);
```

(1)에 따라 두 프로세스가 모두 진입하고자 하더라도 `turn` 변수값에 의해 하나의 프로세스만 `while`문을 통과할 수 있게 된다. 따라서 상호 배제를 만족하게 된다.

`while`문의 조건에 따라 한 프로세스에 오류가 있더라도 다른 프로세스는 임계 구역에 진입할 수 있다. 따라서 진행 및 한계 대기를 만족하게 된다.

### 여러 개의 프로세스를 위한 해결책

