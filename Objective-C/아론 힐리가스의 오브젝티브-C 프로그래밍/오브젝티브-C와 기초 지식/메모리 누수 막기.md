# 메모리 누수 막기

- 양방향으로 강하게 참조하는 경우 메모리에서 올바르게 해제되지 않음

## 유지 사이클*retain cycle*

- 소유권의 순환에 의해 발생
- 메모리 누수의 원인

## 약한참조*weak reference*

**소유권을 주장하지 않는 포인터**

변수 선언시 `__weak`를 타입 앞에 명시함, 프로퍼티 선언시 `(weak)`를 명시함

- `__weak Employee *holder;`
- `@property (weak) Employee *holder;`

## 참조 수동 카운팅과 ARC

참조 수동 카운팅에 대해서는 나중에 알아보아야 할 필요가 있으면 알아보도록 하자..

ARC는 자동 정리 풀*autorelease pool*을 자동으로 사용하나, 풀을 직접 만들고 비워야 함.

```objective-c
// 자동 정리 풀을 만듦
@autorelease { ... }
// 자동 정리 풀이 비워짐
```

---

### 메모리 관리를 쉽게 이해하기

- '내가 노는 바닥'만 생각하기
  - 다른 객체가 특정 객체를 참조한다고 하지만, 특정 객체가 다른 객체를 알 필요가 없다면 참조하는 프로퍼티를 약한참조하게 만들면 됨

> Asset 클래스는 다른 객체들이 자신의 label에 신경을 쓴다고 해서 이들 객체에 관해 무엇을 알아야 할 이유가 없다. Asset 인스턴스가 필요한 객체를 유지만 한다면 문제될 것은 전혀 없기 때문이다.

---

결국 Swift에서도 같은 이야기. 양방향 참조시 약한참조를 적절하게 사용하여 메모리 누수를 방지해야 할 필요가 있다.