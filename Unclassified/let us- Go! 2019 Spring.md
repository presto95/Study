# let us: Go! 2019 Spring

## 스토리보드 없이 UI 만들기

> 발표자 개인의 의견입니다.

모든 개발 문제에서 하나의 정답은 없다.

인터페이스 빌더와 코드는 상호보완적 관계

### 인터페이스 빌더를 선택하지 않아야 하는 이유

- merge conflict
- 재사용이 힘듬
  - xib는 어느정도 가능하지만, storyboard는 사실상 어려움
- 코드와 인터페이스 빌더 양쪽에서 프로퍼티 값을 설정하는 것은 소모적임

### 코드를 선택해야 하는 이유

- 인터페이스 빌더를 사용했을 때의 단점을 해결할 수 있음
  - merge conflict 해결이 쉬워짐
- 인터페이스 빌더로 만들 수 없는 것들 (동적 오토 레이아웃, 그라데이션 등) 을 만들 수 있음
- 모든 설정을 코드에서 한눈에 확인할 수 있음
- 뷰를 만드는 방식을 정확히 이해한다고 할 수 있음
- 성능 문제

### 코드를 선택하지 않아야 하는 이유

- 없다.

### 오토레이아웃 팁 및 도구

- SnapKit
- UIStackView
- UILayoutGuide
  - 개발자가 직접 추가하여 커스텀 Safe Area를 만들 수 있음
- 오토레이아웃 이슈가 발생했을 때, 콘솔에 뷰의 이름이 표시되어 디버깅을 쉽게 할 수 있음
  - 인터페이스 빌더 - Accessibility - Identifier 줘서 같은 효과를 낼 수 있음
- Xcode Visual Debugger
- Reveal (써드 파티 앱, 유료)
- wtfautolayout.com

## try! Swift 후기

appventure.me

method swizzling

키패스 활용 : Kuery

machobfuscator : Mach-O 애플리케이션 바이너리 파일 리버싱 / 난독화

## Texture

복잡한 UI를 반응성 좋고 부드럽게 해주는 iOS 프레임워크

코드로 UI를 그리는 것을 도와주는 프레임워크

### 장점

- 코드로 UI 작성 : 재사용 용의
- 반응 및 렌더링 빠름. 쓰레드 안전
- 협업하기 좋음, 가독성 좋음

### 단점

- 러닝 커브
- 자료가 적음
- Objective-C 예제가 많음

## RxFlow 시작하기

> Coordinator Pattern?

**reactive flow coordinator pattern** 기반 navigation framework

### 사용한 이유

- 화면 이동 처리. 내비게이션에 대한 의문.
- MVVM-C 아키텍쳐?

### Coordinator Pattern

- 뷰컨트롤러에 모든 것을 구현함
- 이것에서 coordinator를 활용하기
  - **Navigation Flow / Model Mutation**을 coordinator가 담당하게 함
  - 뷰컨트롤러를 고립되게 하여, 재사용 가능하게 함. 
  - 뷰컨트롤러를 통제할 수 있음

### RxFlow

- 라우팅을 위한 프레임워크
- **키워드**
  - Flow
  - Step
  - Stepper
  - Presentable
  - Flowable
  - Coordinator

## iOS 환경에서 SOLID 연습하기

낮은 결합도, 높은 응집도

### 개요

- 객체 지향 프로그래밍
- 설계의 5원칙
- 유지 보수를 쉽게, 읽기 쉽게, 확장을 쉽게

### SRP

- 한 클래스, 함수는 하나의 책임만 가져야 한다.
- 클래스 코드를 수정할 이유는 하나여야 한다.
- 체크 포인트
  - 클래스의 인스턴스 변수가 너무 많음
  - 속성과 상관 없는 메소드가 많음
  - 클래스나 메소드를 설명하기 위해 `and`, `if`, `or` 등을 많이 사용함

### OCP

- 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
  - 기능 및 요구사항이 추가될 때 기존 요소의 변경을 최소화
- 유연성, 재사용성, 유지보수성을 취하기 위함
- 체크 포인트
  - 새로운 기능이나 케이스가 추가될 때마다 기존 코드를 변경해야 함
  - 자신의 속성보다는 외부의 속성에 의존하고 있음
  - 인터페이스보다는 구현한 타입에 의존하고 있음

### LSP

- 하위 타입은 기반 타입을 대체할 수 있어야 한다.
- 상속을 사용했을 때 서브클래스는 자신의 슈퍼클래스 대신 사용되도록 같은 동작을 해야 한다.
- 체크포인트
  - 자식 클래스에 너무 많은 재정의가 구현됨

### ISP

- 클래스 내에서 사용하지 않는 인터페이스는 구현하지 말아야 한다.
- 인터페이스의 SRP.
- 체크 포인트
  - 프로토콜을 채택하고 어쩔 수 없이 의미 없는 구현을 하고 있지 않은가
  - 해당 프로토콜이 하나의 역할을 하는가

### DIP

- 상위 레벨 모듈은 하위 레벨 모듈에 의존하면 안된다. 두 모듈은 추상화된 인터페이스에 의존해야 한다.
- 추상화된 것은 구체적인 것에 의존하면 안되며, 구체적인 것이 추상화된 것에 의존해야 한다.
- DI - 해결 방법
- 체크 포인트
  - 내부적으로 생성하는 모듈이 하위 모듈에 의존하고 있음

## 상속에서 프로토콜로

- protocol extension 
  - 특정 조건을 만족할 때의 프로토콜 초기 구현
  - extension syntax / default value

- associated objects
  - Objective-C 런타임, 사용자 속성이나 메소드를 서브클래스를 만들지 않고 추가 / 제거
  - 객체 인스턴스 변수를 기존 클래스에 추가할 때 사용
  - 클래스 수정 및 재정의 없이 임의의 변수를 추가하기 위해 사용
  - Key 기반으로 동작
  - 소스 객체가 해제되면 소스 객체에 추가된 연관 객체도 해제됨

## Framework Driven Development

### 기존 개발 방법의 문제점

- 메인 프로젝트 + 오픈 소스 라이브러리
- 파일 단위로 레이어 분리
- 소스 코드의 집중화 : 애플리케이션 내에 모든 코드가 위치해야 함
  - 응집도 감소, 결합도 증가, 사이드 이펙트 증가
- 라이브러리 직접 관리
- 오픈소스, 외부 SDK를 직접 사용
  - Swift / iOS 버전, 테스트 등에서 외부 소스 관리 비용 증가
- 왜 이렇게 했을까?
  - 기존 Objective-C에서는 빌드 속도가 비교적 빨랐음
  - Xcode는 의존성 관리 도구를 지원하지 않음
    - 프레임워크 작성 및 관리가 귀찮음
  - 소규모 프로젝트
  - 그렇게 하고 있었음
  - 현재 Swift는 코드, 파일 개수가 많아질수록 느려짐

### 프레임워크 주도 개발

- 모듈 단위로 분리
- **프레임워크로 레이러를 나누어 개발**
- 결합도 낮아짐, 응집도 높아짐

### 장점

- 외부에 코드의 노출 여부를 결정할 수 있음
  - 노출 코드의 접근 수준을 public, open으로
  - 나머지는 internal로
  - 다른 프레임워크와 독립적
  - 응집도 증가, 결합도 감소, 사이드 이펙트 감소
- 각 프레임워크에서 빠르고 많은 테스트를 수행
  - 메인 프로젝트에 더 안정적인 상태로 적용 가능
- 메인 프로젝트의 빌드 속도 증가
  - 프레임워크 빌드 후 메인 프로젝트 빌드
- 충돌 가능성 감소 (프로젝트 파일)

### 단점

- 프레임워크를 만들어야 함
- 기존 코드와의 커플링을 제거하며 리팩토링 해야 함
- 수많은 프레임워크가 생길 수 있음
- 귀찮음

### Practice

- Module
  - 라이브러리를 가진 프로젝튿
  - 특정 역할 수행 (네트워킹 등)
  - 외부는 정의된 인터페이스를 통해서만 접근
  - 다른 라이브러리로 대체 가능
- Module Package
  - 여러 모듈 관리, 모듈 간 결합으로 기능 확장
- Domain Service
  - 애플리케이션의 특정 도메인 역할
- Main Service
  - 각 서비스 호출 및 연결
- Application
  - UIApplication (AppDelegate) 에서 제공하는 기능을 받아서 처리

- 메인 프로젝트는 라이브러리를 알 필요가 없으며, 언제든 그 라이브러리를 다른 것으로 교체할 수 있음
- 도메인별로 프레임워크를 만들어, 다른 API를 알 필요가 없음
- watchOS 등 앱 확장시 필요한 프레임워크만 사용하므로 중복 코드가 줄어듬

cocoa layered architecture

a framework for iOS application

## Immutable Data

### 장점

- 예측 가능성 : `let`으로 선언된 변수는 불변
- Coverage : 코드를 커버하기 위한 코드가 적어짐. 테스트 용이
- Race Condition (경쟁 상태) : 불변하므로 경쟁 상태가 없음. 쓰레드 안전
- 유지 보수 용이

### 단점

- 익숙치 않음
- 메모리 낭비
- 퍼포먼스 좋지 않음

### Performance vs. Maintenance

- 우리가 만들 일반적인 서비스에서는 퍼포먼스보다는 유지보수성
- 스트리밍 등의 경우에는 퍼포먼스 우선

> A monad is just a monoid in the category of endofunctors.

변경된 값이 필요하다면 새로 만들어라.

functor / monad