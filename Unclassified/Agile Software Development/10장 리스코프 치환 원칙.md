# Liskov Substitution Principle

객체 지향 프로그래밍의 일차적인 메커니즘은 추상화와 다형성이며, 정적으로 타입이 결정되는 언어에서는 **상속**을 통해 이를 실현한다.

이러한 상속이 특별한 사용을 규율하는 설계 법칙이 바로 LSP이다.

> 가장 바람직한 상속 구조는 무엇일까?
>
> 개방폐쇄 원칙을 따르지 않는 계층 구조를 만들게 해버리는 함정에는 어떤 것들이 있을까?

## LSP

**하위 타입은 그것의 기반 타입으로 치환 가능해야 한다.**

타입 S의 각 객체 o1과 타입 T의 각 객체 o2가 있을 때, T로 프로그램 P를 정의했음에도 불구하고, o1이 o2로 치환될 때 P의 행위가 변화하지 않는다면, S는 P의 서브타입이다.

---

함수가 어떠한 기반 클래스를 요구할 때, 그 기반 클래스의 파생 클래스가 기반 클래스를 가장하여 함수에 넘겨졌을 때 함수가 잘못된 동작을 하게 만든다면, 파생 클래스는 LSP를 위반하는 것이며, 파생 클래스는 함수에 대하여 취약하다.

위의 경우에서 LSP를 해결하기 위해 파생 클래스에 대한 테스트를 추가하여 해당 파생 클래스를 넘겨받아도 함수가 제대로 동작하게 할 수 있으나, 이 경우 테스트는 함수가 기반 클래스의 모든 파생 클래스에 닫혀 있지 않으므로 OCP를 위반한다.

## LSP 위반의 간단한 예

LSP 위반은 대개 심각하게 OCP를 위반하는 런타임 타입 정보의 사용으로 이어진다.

메소드 구현에서 타입을 검사하여 특정 타입에 대한 행위를 호출하게 하며, 이는 OCP 위반이다.

```swift
struct Point {
  let x: Double
  let y: Double
}

enum ShapeType {
  case square
  case circle
}

protocol Shape {
  var type: ShapeType { get }
  init(type: ShapeType)
}

struct Circle: Shape {
  let center: Point = .init(x: 0, y: 0)
  let radius: Double = 0
  var type: ShapeType
  init(type: ShapeType) { self.type = .circle }
  func draw() { }
}

struct Square: Shape {
  let topLeft: Point = .init(x: 0, y: 0)
  let side: Double = 0
  var type: ShapeType
  init(type: ShapeType) { self.type = .square }
  func draw() { }
}

func drawShape(_ shape: Shape) {
  if let square = shape as? Square {
    square.draw()
  } else if let circle = shape as? Circle {
    circle.draw()
  }
}
```

위의 코드는 OCP를 위반한다. `drawShape(_:)` 함수는 `Shape`의 모든 파생 클래스를 알아야 하고 새로운 파생 클래스가 생겨날 때마다 변경되어야 하기 때문이다.

이러한 구조가 잘못된 것을 알지만 프로그래머는 때때로 이러한 코드를 작성한다. **무엇이** 이러한 코드를 작성하도록 하는 것일까?

```swift
class Shape { }

class Square: Shape {
  func draw() { }
}

class Circle: Shape {
  func draw() { }
}

func drawShape(_ shape: Shape) {
  // ...
}
```

`drawShape(_:)`의 구현은 shape를 검사하여 타입을 결정하고 적절한 `draw()` 함수를 호출하는 것이 될 것이다.

이 때 Square와 Circle은 Shape를 대체할 수 없으므로 LSP 위반이며, 이는 `drawShape(_:)`의 OCP 위반을 유발한다.

**LSP 위반은 잠재적인 OCP 위반이다.**

## 정사각형과 직사각형 예제

```swift
struct Point {
  let x: Double
  let y: Double
}

class Rectangle {
  private var _topLeft: Double = 0
  private var _width: Double = 0
  private var _height: Double = 0
  var width: Double {
    get {
      return _width
    }
    set {
      _width = newValue
    }
  }
  var height: Double {
    get {
      return _height
    }
    set {
      _height = newValue
    }
  }
}
```

직사각형이 시스템 내에서 잘 돌아가고 있는데, 고객에 정사각형도 조작할 수 있게 해달라고 요구해왔다.

---

상속은 IS-A 관계라고 말할 수 있다.

새로운 종류의 객체가 원래 종류의 객체와 IS-A 관계를 이룬다고 말할 수 있다면, 새 객체의 클래스는 원래 객체의 클래스에서 파생될 수 있어야 한다.

모든 정사각형은 직사각형이다 (A square is a rectangle). 그러므로 Square 클래스는 Rectangle 클래스에서 파생될 수 있어야 한다.

하지만, 이런 식의 생각은 미묘하지만 심각한 문제를 낳을 수 있다.

1. Square는 width와 height 프로퍼티를 필요로 하지 않는다. 어차피 정사각형의 너비와 높이는 같기 때문이다. Rectangle을 상속받은 Square는 두 개의 프로퍼티를 모두 갖게 되므로 소모적이다.

   - 메모리 문제를 신경쓰지 않는다면, Square의 width와 height 설정에서 너비와 높이 모두를 바꾸게끔 구현하여 해결할 수 있을 것이다.

2. 어떠한 함수가 인자로 Rectangle 타입을 요구하고 그것에 Square의 참조를 넘겼을 때 문제가 될 수 있다.

   - Square가 Rectangle로 치환될 수 없으므로 LSP 위반이다.
   - 파생 클래스를 만드는 것이 기반 클래스의 변경으로 이어지며, 설계에 결점이 있음을 의미하며 OCP 위반이다.
   - Rectangle이 수학적인 직사각형의, Square가 수학적인 정사각형의 역할을 할 수 있게 코드를 변경했다고 가정하자. 정사각형의 너비와 높이가 같다는 불변성이 유지된다.

3. 어떠한 함수가 인자로 Rectangle을 넘겨받고, 너비와 높이를 설정한 후 그 넓이를 assert한다.

   ```swift
   func function(_ rectangle: Rectangle) {
     rectangle.width(5)
     rectangle.height(4)
     assert(rectangle.size == 20)
   }
   ```

   - 인자로 Square가 넘어갔고 너비와 높이를 다르게 설정했다면 assert문은 false를 뱉을 것이다.
   - 다른 사람이 이 함수를 사용할 때, Rectangle의 너비를 바꾸는 것이 높이를 바꾸지는 않을 것이라고 생각했을 것이다. 이 생각은 분명히 합리적이나 Rectangle로서 넘겨질 수 있는 모든 객체가 이 가정을 만족하지 않았다.
   - 함수는 Square / Rectangle 계층 구조에 취약하다.
   - Square가 Rectangle과 치환 가능하지 않다. LSP를 위반한다.
   - 함수의 작성자는 Rectangle 클래스의 구현에서 너비와 높이가 독립적일 것이라고 생각했다고 주장할 수 있다.
   - Rectangle에서 Square를 파생시킴으로써, Rectangle의 불변식을 위반하게 되었다.

   > Rectangle의 불변식 [너비와 높이는 독립적이다]는 Rectangle의 구현에 의해 실현되었고,
   >
   > Square가 Rectangle을 상속받고 Square의 불변식 [너비와 높이는 같다]를 구현하였다.
   >
   > 파생 클래스가 기반 클래스의 불변식을 따르지 않고 특정 파생 클래스만의 불변식을 실현하게 함으로써 Rectangle의 불변식을 위반하게 된 것이다.

### 유효성은 본래 갖추어진 것이 아니다

**모델만 별개로 보고, 그 모델의 유효성을 충분히 검증할 수 없다.**

어떤 모델의 유효성은 오직 그 클라이언트의 관점에서만 표현될 수 있다.

특정 설계가 적절한지 아닌지 판단할 때는 단순히 별개로 봐서는 해답을 찾을 수 없다. 그렇게 설계한 사람의 *합리적인 가정*의 관점에서 바라보아야 한다.

기반 클래스에 대해서 작성한 단위 테스트는 파생 클래스에 대하여 실패할 수 있다. 테스트 주도 개발을 해야 하는 또 하나의 이유 중 하나가 된다.

물론 이러한 가정은 예상하기 어렵다. 다른 원칙과 마찬가지로, 관련된 취약성의 악취를 맡을 때까지, 가장 명백한 LSP 위반을 제외한 나머지의 처리는 연기하는 것이 최선이다.

### IS-A 관계는 행위에 대한 것이다

> 애초에 IS-A 관계로 모델 관계를 정의한 것이 잘못된 것이다.
>
> 정사각형이 직사각형이라는 생각으로 모델을 설계했기 때문에 정사각형은 독립된 너비와 높이에 대한 특성을 갖게 된 것이다.

A square is a rectangle. 이 관계가 모델 설계에서 들어맞지 않았다.

정사각형은 직사각형일 수 있다. 하지만 위 `function`의 관점에서 Square는 절대 Rectangle일 수 없다. **Sqaure의 행위가 함수가 기대하는 Rectangle의 행위와 일치하지 않기 때문이다.**

행위 측면에서 볼 때 Square는 Rectangle이 아니며, 행위야말로 소프트웨어의 모든 것이다. 그러므로 이 설계는 잘못되었다.

### 계약에 의한 설계

*합리적 추정*? 고객이 정말로 기대하는 것을 어떻게 알 수 있겠는가?

*합리적 추정*을 명시적으로 만들어 LSP를 강제하는 테크닉 : 계약에 의한 설계*design by contract*

계약에 의한 설계를 통하여, 어떤 클래스의 작성자는 그 클래스의 계약사항을 명시적으로 정한다.

- 모든 클라이언트 코드의 작성자가 신뢰할 수 있는 행위에 대해 알려준다.
- 각 메소드의 사전조건과 사후조건을 선언하는 것으로 구체화된다.
- 메소드를 실행하기 위해 사전조건이 참이 되어야 한다. 메소드 실행이 완료되면 사후조건이 참이 됨을 보장한다.

Rectangle 클래스의 `setWidth(_:)` 메소드의 사후 조건을 다음과 같이 볼 수 있다.

- 그 너비가 인자로 넘어온 값과 같다.
- 그 높이가 메소드가 실행되기 전의 높이와 같다.

> 파생 클래스는, 오직 원래 사전 조건과 같거나 더 약한 수준에서 기반 클래스를 대체할 수 있고, 원래 사후 조건과 같거나 더 강한 수준에서 기반 클래스를 대체할 수 있다.

기반 클래스의 인터페이스를 통해 어떠한 객체를 사용할 때, 사용자는 그 기반 클래스의 사전 조건과 사후 조건만 알 수 있다.

파생된 객체는 기반 클래스가 받아들일 수 있는 모든 것을 받아들일 수 있어야 한다.

파생된 객체의 행위와 출력은 기반 클래스의 제약을 위반해서는 안된다. 기반 클래스의 사용자가 파생 클래스의 출력에 의해 혼란스러워해서는 안 된다.

---

Sqaure의 `setWidth(_:)` 메소드의 사후 조건은 Rectangle의 `setWidth(_:)` 메소드의 사후 조건보다 약하다. 높이가 메소드가 실행되기 전의 높이와 같아야 한다는 조건을 강제하지 않기 때문이다. (정사각형의 경우 너비가 변경될 때 높이도 변경될 수 있다.) 그러므로 Sqaure의 `setWidth(_:)` 메소드는 기반 클래스의 계약을 위반한다.

일반적으로 각 메소드의 사전 조건과 사후 조건을 수동으로 처리하고 위의 규칙이 위반되는지 확인해야 한다. 각 메소드의 주석에 이러한 것들을 문서화해두면 유용하다.

### 단위 테스트에서의 계약사항 구체화하기

단위 테스트를 작성하여 계약을 구체화할 수 있다. 어떠한 클래스의 행위를 철저하게 테스트하여 그 클래스의 행위를 좀 더 분명하게 만들어준다.

클라이언트 코드의 작성하는 단위 테스트 코드를 관찰하여 그들이 사용하는 클래스에 대한 합리적 추정이 무엇인지 알고 싶어 할 것이다.

이러한 구조가 올바르지 않다는 것을 알