## 객체 지향 프로그래밍의 특성 및 구현

상속 / 추상화 / 캡슐화 / 다형성

### 클래스

- 실제 세계의 객체를 추상화하여 그 속성과 행위를 각각 프로퍼티와 메소드로 정의함

### 인스턴스

- 클래스로 정의한 것을 토대로 메모리에 할당.

### 추상화

- 공통의 속성이나 기능을 묶어 네이밍
- 사자, 토끼, 뱀을 동물이라는 추상적인 객체로 추상화.

### 캡슐화(은닉성)

- 기능과 특성의 모음을 클래스에 캡슐화하는 것
- 코드를 수정 없이 재활용하기 위함.
- 관련 기능 및 특성을 한 곳에 모으고 분류하여 재사용을 가능하게 함. 
- 데이터를 외부에서 직접 접근을 못하게 하고 다른 방법 (메소드나 프로퍼티 등) 을 제공함
  - 어떠한 객체의 명세에 알맞은 기능만을 외부에 노출하도록 함

### 상속

- 수퍼 클래스의 속성 및 기능을 하위 클래스가 이어받아 사용할 수 있고, 하위 클래스에서 기능을 변경해야 할 경우 재정의가 가능한 것

### 다형성

- 같은 모양의 코드가 다른 행위를 함
- 동일한 타입을 가진 여러 객체가 같은 속성을 가짐
- 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있음
  - 오버로딩, 오버라이딩
- 상위 클래스 타입에 하위 클래스의 인스턴스를 할당할 수 있음
  - 상속 또는 인터페이스 구현

## SOLID 법칙

### Single Responsibility Principle

단일 책임 원칙

클래스는 단 하나의 책임을 갖는다. 클래스가 변경되어야 하는 이유는 단 하나여야 한다.

하나의 클래스는 하나의 기능만을 가지며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행해야 한다.

관심사의 분리와 밀접한 관계가 있다.

SRP를 지키지 않았을 경우 해당 클래스의 수정이 다른 모듈에 미치는 영향을 가늠하기 힘들다.

### Open-Closed Principle

개방폐쇄 원칙

모든 소프트웨어 개체는 확장에 대해 열려 있고, 수정에 대해 닫혀 있어야 한다.

수정이 일어나더라도 기존 구성요소에서는 수정이 이루어지지 않아야 하며, 쉬운 확장을 가능하게 하여 재사용을 할 수 있도록 해야 한다.

추상화와 다형성의 개념이 적용된다.

### Liskov Substitution Principle

리스코프 치환 원칙

상속의 개념이 적용된다.

상위 클래스의 객체는 필요한 프로그램의 속성 변경 없이 하위 클래스의 객체로 치환될 수 있어야 한다.

하위 타입은 언제나 자신의 기반 타입으로 교체될 수 있어야 한다. 서브클래스는 부모가 정의한 인터페이스 및 메소드를 지켜야 한다. 서브 클래스와 기반 클래스는 IS-A 관계여야 한다.

직사각형이 상위 개념, 정사각형이 하위 개념일 때, 정사각형은 상위 개념의 가로세로 속성을 제한하므로 LSP를 지키지 않은 것이다.

LSP를 지키지 않은 경우 클래스 계층 설계가 좋지 않게 될 수 있고, 수퍼클래스에 대하여 작성한 단위 테스트가 서브 클래스에서는 작동하지 않을 수 있다.

### Interface Segregation Principole

인터페이스 분리 원칙

클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.

인터페이스의 SRP. 하나의 인터페이스는 하나의 책임을 가져야 한다.

시스템의 내부 의존성 관계를 느슨하게 하여 리팩토링 등을 쉽게 할 수 있다.

UITableViewDelegate와 UITableViewDataSource는 모두 위임을 위한 프로토콜이지만, 데이터 소스와 델리게이트의 책임을 분리하여 프로토콜이 작성되었다.

### Dependency Inversion Principle

의존성 역전 원칙

상위 모듈은 하위 모듈에 종속되어서는 안되며, 둘 모두 추상화에 의존해야 한다.

추상화는 세부 사항에 의존하지 않으며, 세부 사항은 추상화에 의해 달라져야 한다.

상위 모듈이 하위 모듈에 의존하는 전통적 의존 관계를 역전시켜, 상위 모듈이 하위 모듈의 구현으로부터 독립되어야 한다.

모듈 간 의존성이 강한 경우, 어떠한 모듈의 수정에 대하여 이에 의존하는 다른 모듈에 대해서도 변경이 일어나야 한다. 그렇기 때문에 추상에 의해 의존해야 한다.

의존성 주입. 

## 공개키 및 대칭키 암호화 알고리즘의 비교

### 대칭키 암호화 알고리즘

- 하나의 키를 양쪽이 함께 사용, 암복호화에 사용되는 키가 같음
- 계산 속도가 빠름
- 키 하나만 알아내면 암호화된 메세지를 해독할 수 있음
- DES, AES 등

### 공개키 암호화 알고리즘

- 공개키와 비밀키가 존재함
- 암호화할 때는 모두에게 공개된 공개 키, 복호화할 때는 비밀의 개인 키를 사용
- 대칭키 알고리즘에 비해 속도가 느림
  - 메세지를 이 알고리즘을 사용해 암호화하기보다는, 대칭키 암호화 알고리즘에 사용되는 키에 공개키 암호화 알고리즘을 적용
- RSA 등

## RSA 알고리즘에 대하여

공개키 암호화 알고리즘 중 하나

큰 수의 소인수분해는 어렵다

일방향 함수를 사용하며, 암호화하기는 쉬우나 복호화하기는 어렵다.

## Rx의 장점, Rx를 사용하는 이유

> Rx는 관찰 가능한 시퀀스를 사용하여 비동기적이고 이벤트 기반 프로그램을 구성하기 위한 라이브러리.
>
> ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.

여러 개의 아이템에 대하여, 비동기 처리를 하기 위해 Rx를 사용함

아이템을 스트림으로 미는 것push

## 함수형 프로그래밍

불변 데이터 / 고차 함수 / 커링 / 함수 합성 / 순수 함수 / 일급 객체 등

> 순수 함수를 조합하고, 공유 상태, 변경 가능한 데이터, 부작용을 피하여 소프트웨어를 만드는 프로세스
>
> 명령형이 아닌 선언형이며, 애플리케이션의 상태는 순수 함수를 통해 전달됨

### 객체 지향 프로그래밍 패러다임과의 차이

- 명령형 프로그래밍 : 프로그램의 상태와, 상태를 변경시키는 구문의 관점에서 연산을 설명. '어떻게' 할 것인가
  - 절차지향 : 수행되어야 할 연속적인 계산 과정을 포함
  - 객체지향 : 객체들의 집합으로 프로그램의 상호작용을 표현
- 선언형 프로그래밍 : 무엇과 같은지를 설명함. 알고리즘을 명시하지 않고 목표만 명시함. '무엇을' 할 것인가
  - 함수형 : 순수 함수를 조합하여 소프트웨어를 만듦

### 일급 객체

- 변수나 자료구조 안에 담을 수 있음
- 매개변수로 전달할 수 있음
- 반환값으로 사용될 수 있음
- 할당에 사용된 이름에 관계 없이 고유한 식별이 가능함
- 동적으로 프로퍼티 할당이 가능함

### 고차 함수

- 매개변수로 전달할 수 있는 함수
- 반환형으로 사용될 수 있는 함수
- 일급 객체의 부분집합

### 불변성

- 함수형 프로그래밍에서 데이터는 변할 수 없음
- 데이터 변경이 필요한 경우 원본을 변경하지 않고 해당 데이터의 복사본을 만들어 그것을 활용하여 작업함

### 순수 함수

- 동일한 입력에 항상 동일한 값을 반환함
- 외부 상태에 영향을 받지 않으며, 외부 상태에 영향을 주지 않음
- 프로그램의 변화가 없고, 입력 값에 대한 출력을 예상할 수 있기 때문에 테스트에 용이함

### 함수의 합성

- 둘 이상의 함수를 조합함
- 여러 개의 작은 순수 함수들을 조합함
- 어떠한 함수의 출력이 다른 함수의 입력이 됨

### 커링

- 매개변수가 여러 개인 함수를 매개변수가 하나인 여러 개의 함수로 쪼개기

### 재귀 함수

- 절차 지향적으로 작성하는 코드를 함수형으로 작성할 수 있다.

## HTTP 메소드

`GET www.naver.com HTTP/1.1`

서버가 요청을 검증한 후, 유효하면 요청에 대한 응답을 함.

### GET

CRUD의 Read

요청 URI의 정보를 가져온다.

GET의 body는 어떻게 처리해야 한다에 대한 정의가 없음

### POST

CRUD의 Create

요청 URI의 리소스의 새로운 정보를 보낸다.

서버에 입력 데이터를 보내기 위함

데이터를 요청 메세지의 body에 담아 전송함

요청을 통해 전달되는 표현이 웹 서버 쪽에 있는 타겟 리소스 자체로 처리됨

멱등성이 없음 : 여러 번 수행을 했을 때 결과가 같지 않음

### PUT

CRUD의 Update

요청 URI에 저장될 정보를 보낸다.

타겟 리소스의 상태를 갱신하려는 의도를 가짐 : 이미 리소스의 위치를 알고 있음

멱등성이 있음 : 여러 번 수행을 해도 결과가 같음

### DELETE

CRUD의 Delete

요청 URI의 리소스를 삭제한다.

## HTTP 상태 코드

### 100번대 : 조건부 응답

요청을 받았으며 작업을 계속한다.

HTTP/1.0 이후 정의되지 않음. 서버도 클라이언트에게 이 코드를 보내지는 않음

101(Switching Protocols) 코드의 경우 웹소켓 등에서 사용됨

### 200번대 : 성공

클라이언트가 요청한 동작을 서버가 수신하여 이해했고 승낙했으며, 성공척으로 처리함

- 200 OK : 성공
- 201 Created : 요청이 성공적으로 처리되어 리소스가 생성됨
- 204 No Content : 성공적으로 처리했으나 컨텐츠를 제공하지는 않음
- 206 Partial Content : 성공적으로 처리했으며 컨텐츠의 일부 부분만 제공함

### 300번대 : 리다이렉션 완료

리다이렉션이 이루어져여야 이 요청을 완료할 수 있음.

단축 URL 서비스의 경우 접속시 301 또는 302 코드를 보내며, 해더의 `location`에 실제 URL을 적어 보냄

- 301 Moved Permanently : 영구적으로 컨텐츠가 이동함
- 302 Found : 다른 페이지로 이동하며, 나중에 변경될 수 있음

### 400번대 : 클라이언트 오류

올바르지 않은 요청

- 400 Bad Request : 요청 자체가 잘못됨
- 401 Unauthorized : 인증이 필요한 리소스에 인증 없이 접근함. 브라우저에게 어느 인증 방식을 사용할 것인지 보내주어야 함
- 403 Forbidden : 서버가 요청에 대한 응답을 거부함
- 404 Not Found : 요청에 대한 리소스가 없음
- 408 Request Timeout : 요청 중 시간 초과

### 500번대 : 서버 오류

올바른 요청에 대해 서버가 응답할 수 없음

- 500 Internal Server Error : 서버에 오류가 발생하여 응답을 보낼 수 없음
- 502 Bad Gateway : 게이트웨이가 잘못되엇음
- 520 Unknown Error : 알 수 없는 오류

## 커넥션 타임 아웃 / 리드 타임 아웃

### Connection Timeout

- 클라이언트가 어떠한 이유로 서버에 접근을 실패한 경우
- 접근 시간제한 등

### Read Timeout 

- 클라이언트가 서버에 접속을 성공했으나 서버가 응답을 제대로 주지 못한 상태에서 클라이언트가 연결을 해제하는 경우
  - 응답을 위해 서버가 수행하는 로직이 오래 걸리는 경우 등
- 클라이언트는 이 상황을 오류로 인지하고, 서버는 계속 요청에 대한 응답을 주기 위해 로직을 수행중이기 때문에 양 단간 동기화가 되지 않아 문제가 발생할 확률이 높음
- Read Timeout을 낮게 설정하는 것은 위험하다.
- 응답이 오래 걸리는 요청의 경우 비동기 방식의 접속을 시도하는 것도 하나의 방법이다.

클라이언트와 서버 간의 통신에 위와 같은 문제가 발생할 수 있으며, 여러 상황을 설정하여 시뮬레이션 해보아야 한다.

## ARC와 GC에 대하여, 그 차이 비교

### 가비지 컬렉터

- 런타임에서 메모리 관리

### 매뉴얼 레퍼런스 카운팅 MRC

- Objective-C에서의 개발시 참조 관리를 하는 방법
- alloc, new, copy, mutableCopy, retain 등으로 레퍼런스 증가, release로 레퍼런스 감소

### 오토 레퍼런스 카운팅 ARC

- 컴파일 타임에서 컴파일러에 의해 적절한 위치에 리테인 및 릴리즈 코드가 추가됨
- MRC에서 개발자가 수동으로 넣어준 리테인 및 릴리즈 코드를 컴파일러가 추가해주는 것
- 어떠한 객체를 참조하는 경우 그 객체에 대한 참조 카운트가 1 증가하고, 0이 되었을 때 메모리에서 해제됨
- strong, weak, unowned
  - weak는 반드시 옵셔널
  - unowned는 절대 옵셔널이 아님. 가리키는 객체가 nil일 경우 런타임 에러를 발생시킬 수 있음
  - 힙에서 어떠한 메모리를 가리키고 있으나, 관심이 없어지면 그대로 가리키던 객체를 해제할 수 있음
- 클로저 캡처링, 객체 간 상호 참조의 경우 강한 순환 참조가 발생할 수 있음
  - 클래스 인스턴스의 프로퍼티에 클로저를 할당하고, 클로저 내에서 인스턴스의 프로퍼티에 접근할 때 강력 참조 순환이 만들어짐. 클로저도 참조 타입이기 때문이다.
  - 클로저의 캡쳐 리스트를 통해 해결한다. `[weak self]`, `[unowned self]` 

## Swift 5 변경사항

- `@dynamicCallable` 선언을 한 타입에 대하여, synthetic sugar를 사용하여 메소드를 호출할 수 있음
- 열거형의 연관 값에 가변 인자를 사용할 수 없음, 대신 array를 사용할 수 있음
- `try?`의 expression을 옵셔널을 사용하여 중첩된 결과를 반환하는 대신, 표현식의 결과로 나오는 옵셔널을 flat하게 만들어줌
  - `try?`의 결과가 옵셔널이 아니라는 것이 아님. `try?`의 표현식의 결과가 옵셔널일 때 그것을 flat하게 만들어준다는 것
- Swift 3을 지원하지 않음
- ABI Stability
  - ABI (Application Binary Interface) : 응용 프로그램과 운영체제 또는 응용 프로그램과 라이브러리, 응용 프로그램의 구성 요소 간에 사용되는 저수준 인터페이스.
    - 애플리케이션 용량이 줄어듦. 스위프트 런타임이 OS단에 통합될 수 있기 때문이다.
    - 새로운 기능 추가 등이 어려움
    - 언어가 안정화 단계에 들어섰다고 말할 수 있음
  - API (Application Programming Interface) : 응용 프로그램을 작성할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스.

## xUnique의 동작, 실무 적용 가능성

xUnique는 Xcode 프로젝트 파일인 `project.pbxproj` 파일을 재생성하여 유일하고 같게 만들어주어 협업시 이 파일에 대한 충돌을 방지해줌

Xcode가 파일에 대해 생성하는 UUID는 같은 파일에 대하여 유일하지 않다.

xUnique는 먼저 `project.pbxproj` 파일을 JSON 포맷으로 변환한다.

JSON의 모든 `object` 를 반복하면서 모든 UUID에 절대 경로를 부여하고, MD5 헥스 다이제스트를 이용하여 새로운 UUID를 생성한다.

깃 후크에 등록하여 사용할 수도 있다.

- `-u` : 프로젝트 파일을 유일하게 함 - UUID를 MD5 다이제스트로 교체함
- `-s` : MD5 기준으로 프로젝트 파일을 정렬함
- `-p` : 파일 이름 기준으로 프로젝트 파일을 정렬함
- `-c` : 프로젝트 파일이 수정된 경우 xUnique는 0이 아닌 상태 코드를 반환하며 종료됨.
- u 및 s 옵션이 붙지 않으면 두 개 모두를 붙인 것이 기본 옵션임.

## 스토리보드 사용시 뷰가 불러와지는 시점

스토리보드 내에 정의된 어떠한 액션에 응답하여 자동으로 인스턴스화되고 생성된다.

`instantiateInitialViewController()`, `instantiateViewController(withIdentifier:)` 와 같은 메소드를 사용하여 코드로 뷰컨트롤러를 생성할 수도 있다.

## 오버라이딩과 오버로딩의 차이

객체 지향 프로그래밍의 '다형성'과 관련된 개념

오버라이딩 : 수퍼클래스가 가지고 있는 메소드나 프로퍼티를 하위 클래스가 재정의하여 사용

오버로딩 : 같은 기반 이름의 메소드를 여러 개 가질 수 있으며, 이 경우 매개변수의 타입과 개수, 반환형 등에 차이가 있어야 한다.

## Array와 Dictionary의 탐색 시간 복잡도

O(n). n은 Collection의 길이.

## 클로저 내의 변수는 메모리의 어떤 공간에 저장되는가?

힙에 저장된다.

> 블록(==클로저)에 의해 접근된 변수는 힙에 있는 블록 자료구조에 복사되어 블록이 나중에 접근할 수 있게 합니다. 

## MVVM 아키텍쳐에 대하여

MVC 아키텍쳐의 단점인 '컨트롤러가 비대해지는 것'을 막기 위한 아키텍쳐 중 하나.

뷰 업데이트 로직과 비즈니스 로직의 분리 : 관심사의 분리

### MVC

Model View Controller

Model : 프로그램에서 사용되는 실제 데이터 및 데이터 조작 로직을 처리하는 부분

View : 사용자에게 보여지는 UI

Controller : 사용자의 입력을 받고 처리하는 부분

View와 Model이 서로 의존적

### MVVM

Model ViewModel Model

ViewModel : View를 표현하기 위해 만들어진, View를 위한 Model

View를 통해 사용자의 입력이 들어옴. Command 패턴을 통해 ViewModel에 명령을 내림. Data Binding을 통하여 ViewModel의 값이 변화하면 바로 View가 갱신됨

View와 ViewModel은 독립적이게 됨

ViewModel에 비즈니스 로직이 위치함. View에는 뷰를 갱신하는 로직만 있음

iOS에서 ViewModel은 UIKit을 임포트하면 안됨, 뷰를 인자로 받아 뷰의 상태를 직접 변경하면 안됨.

iOS의 UIViewController도 View로 간주됨

- View에 입력이 들어오면 Command 패턴을 통해 ViewModel에 명령함
- ViewModel은 필요한 데이터를 Model에 요청함
- Model은 ViewModel에 필요한 데이터를 응답함
- ViewModel은 응답 받은 데이터를 가공하여 저장함
- View는 ViewModel과의 데이터 바인딩으로 인해 자동으로 갱신됨

## 3-way merge

### git의 merge에 대하여

merge : 분기된 커밋을 하나의 커밋으로 합하기 위해 사용함

### fast-forward

머지의 대상이 되는 브랜치의 포인터를 옮김

브랜치들이 같은 커밋 라인에 위치하는 경우

### 3-way merge

fast-forward 방식이 아닌 머지 방법 중 하나

서로 다른 브랜치의 커밋을 머지하는 경우 발생하는 충돌에 대해 3-way merge 방법을 사용하여 충돌 해결

두 개의 브랜치가 서로 부모자식 연관이 없을 때

두 커밋의 공통 조상을 찾아 3-way merge를 진행하고, 그 결과를 새로운 커밋으로 만듦

두 브랜치의 공통 조상 / 한 브랜치 / 다른 브랜치 노드, 총 3개의 커밋을 참조하여 3-way merge를 진행, 그 결과를 새로운 커밋으로 만들어 가리키게 함

```
c4 c3
| /
c2
|
c1
|
c0
```

위의 그래프에서 master 브랜치가 c2, hotfix 브랜치가 c4, iss53 브랜치가 c3을 가리키고 있다고 가정하자. master 브랜치를 hotfix 브랜치로 merge할 때 서로 같은 그래프 라인에 위치하고 있으므로 fast-forward 방식으로 merge가 이루어지게 된다. 그 결과로 master 및 hotfix 브랜치는 c4를 가리키게 된다.

c3을 가리키던 iss53 브랜치에서 작업을 더 하고, master 브랜치를 merge하려는 경우에는 fast-forward로 merge하지 않는다. 이 경우 각 브랜치가 가리키는 커밋 두 개와 공통 조상 하나를 사용하여 3-way merge를 하게 된다. 또한 그 결과로 별도의 커밋을 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다.

충돌이 날 가능성이 있으며, 충돌이 난 경우 git은 merge를 행하지 못하여 새로운 커밋을 만들어내지 않고, 개발자가 이를 수동으로 해결해주어야 한다.

## rebase

두 브랜치가 나뉘기 전인 공통 조상 커밋으로 이동하고 나서, 그 커밋부터 지금 checkout한 브랜치가 가리키는 커밋까지의 diff를 차례대로 만들어 어딘가에 임시로 저장해 놓는다. rebase할 브랜치가 합칠 브랜치가 가리키는 커밋을 가리키게 하고, 아까 저장해 놓았던 변경사항을 차례대로 적용한다.

3-way merge에 비해, rebase는 커밋 히스토리를 선형으로 만든다. 일을 병렬로 동시에 진행해도 rebase하고 나면 모든 작업이 차례대로 수행된 것처럼 보인다.

**이미 공개 저장소에 push한 커밋을 rebase하지 마라.**

## rebase vs. merge

### 히스토리를 바라보는 관점

- 작업한 내용의 기록
  - 이 경우 커밋 히스토리를 변경한다는 것은 그동안 작업한 내용을 부정하는 꼴이 된다.
  - 그래서 계속 merge를 했을 때, 수많은 merge 커밋이 히스토리에 남게 되는 것은 문제가 없을까?
- 프로젝트의 진행 기록
  - 프로젝트의 진행 기록을 rebase 등으로 깔끔하게 정리하고 싶을 수 있다.