# 급여 관리 사례 연구: 반복의 시작

> 저자의 설계에 대한 생각의 변화에 중점을 두어 정리한다.

## 소개

간단한 일괄 임금 지급 시스템 개발 과정의 첫 번째 반복을 보여 준다.

고객은 반복에 대하여 처리할 스토리를 선택하고, 개발자는 그것들을 어떻게 구현할지 생각해야 한다.

### 명세

첫 번째 반복에서 고객이 스토리를 선택하였고, 이것에서 명세를 정의할 수 있다.

항상 그래왔듯, 데이터베이스 스키마를 정의하는 것부터 시작할 수 있다. 제대로 동작하는 스키마를 설계하고 어떠한 질의 구성을 시작하는 것은 쉬운 일이다.

하지만 이러한 접근 방식을 택하면 데이터베이스가 중점적 관심사가 되는 애플리케이션이 만들어지리 것이다. 데이터베이스는 **구체적인 구현**이므로, 데이터베이스에 대한 고려는 최대한 뒤로 미루어야 한다. 처음부터 데이터베이스를 생각하게 되면 그것에 맞추어서 애플리케이션을 설계하게 될 것이고, 애플리케이션은 데이터베이스와 단단히 묶이게 된다.

추상화는 **본질을 확충하고 지엽적인 것을 제거**하는 것이다. 데이터베이스는 지엽적인 것이며, 그저 데이터를 저장하고 그것에 접근하는 기법일 뿐이다.

## 유스케이스 분석

시스템의 데이터보다는, 시스템의 행위를 생각하는 것에서 출발한다. 우리가 만들어내야 하는 것은 시스템의 동작이다.

**유스케이스**를 만들어 시스템의 행위를 이해하고 분석해볼 수 있다. 유스케이스는 좀 더 구체적인 내용이 추가되어 상세해진 사용자 스토리라고 말할 수 있다.

유스케이스 분석을 수행할 때는, 이 시스템의 사용자들이 시스템에 줄 수 있는 여러 종류의 자극을 알아내기 위해 사용자 스토리와 인수 테스트를 살펴보게 되며, 시스템이 이러한 자극에 어떻게 반응하는지 알아내려 한다.

다음의 스토리를 상세화된 유스케이스로 변환해보자.

1. 새 직원 추가
2. 직원 삭제
3. 타임카드 기록
4. 판매 영수증 기록
5. 조합 공제액 기록
6. 직원 정보 변경
7. 당일을 위한 급여 프로그램 실행

### 직원 추가

직원은 시급을 받는 직원, 월급을 받는 직원, 판매량에 기반한 수수료를 추가로 받는 월급을 받는 직원, 세 종류의 직원을 생각해볼 수 있다. 이는 '직원'이라는 추상화를 암시한다.

이 때 커맨드 패턴을 사용하여, 각각의 일을 독자적인 클래스에 나누어 맡겨, SRP를 실현할 수 있다.

이 유스케이스는 직원 레코드를 다루고 있는데, 여기서 다시 데이터베이스를 고려하고자 하는 생각이 들 수 있을 것이다. 하지만 이 유스케이스가 정말로 요구하는 것은 직원을 새로 만드는 것이며, 데이터베이스와는 관련이 없다.

```swift
protocol Employee {}
class HourlyEmployee: Employee {}
class CommissionedEmployee: Employee {}
class SalariedEmployee: Employee {}
```

이 단계에서는 직원을 추상화하고, 임금을 받는 타입에 따라 직원의 개념을 구체화한 세 개의 클래스를 만들 수 있을 것이다.

### 직원 삭제

현재 단계에서 이 유스케이스는 별다른 영감을 주지 못하므로 일단 넘어간다.

### 타임카드 기록

타임카드는 시급을 받는 직원에 대해서만 유효하다. 이는 서로 다른 것은 서로 다른 클래스에 의해 표현되어야 한다는 아이디어를 강조한다.

시급을 받는 직원은, 타임 카드를 0개 이상 가질 수 있는 관계를 가지고 있다.

```swift
class HourlyEmployee: Employee {
  var timeCards: [TimeCard]
}
class TimeCard {}
```

### 판매 영수증 기록

타임카드 기록 유스케이스처럼, 판매 영수증은 판매량에 기반한 수수료를 추가로 받는 월급을 받는 직원에 대해서만 유효하다.

수수료를 추가로 받는 직원은, 판매 영수증을 0개 이상 가질 수 있는 관계를 가지고 있다.

```swift
class CommissionedEmployee: Employee {
  var salesReceipts: [SalesReceipts]
}
class SalesReceipt {}
```

### 조합 공제액 기록

조합은 조합원들을 위한 고유의 식별 번호 체계를 갖고 있다. 그러므로 시스템은 조합원과 직원을 연결할 수 있어야 한다. 이를 가능하게 하는 방법은 여러 가지가 있을 것이고, 나중에 결정하도록 한다.

하지만 조합원과 그들의 공제액 사이에는 직접적인 연관 관계가 있다는 것은 확실하다.

조합원은, 조합 공제액을 0개 이상 가질 수 있는 관계를 가지고 있다.

```swift
class UnionMember {
  var serviceCharges: [ServiceCharge]
}
class ServiceCharge {}
```

### 직원 정보 변경

이 유스케이스는 변경되어야 하는 직원의 모든 면을 말해주므로 의미가 아주 크다.

시급을 받는 직원을 월급을 받는 직원 등으로 변경할 수 있다는 것은, 위에서 작성한 직원 관련 클래스 계층 구조가 올바르지 않다는 것을 의미한다. 대신 임금을 계산하기 위해 스트래티지 패턴을 사용할 수 있을 것이다. 직원의 타입에 따라 다른 스트래티지를 사용하여 임금을 계산할 수 있게 된다.

지급 방법 또한 변경될 수 있어야 하므로, 이 개념에도 스트래티지 패턴을 적용할 수 있을 것이다.

직원은 조합에 가입하지 않을 수도 있으므로, 조합원 개념에는 널 오브젝트 패턴을 적용할 수 있을 것이다.

```swift
class Employee {
  var paymentMethod: PaymentMethod 
  var paymentClassification: PaymentClassification 
  var affilication: Affilication 
}

protocol PaymentMethod {}
class HoldMethod: PaymentMethod {}
class DirectMethod: PaymentMethod {}
class MailMethod: PaymentMethod {}

protocol PaymentClassification {}
class SalariedClassification: PaymentClassification {}
class HourlyClassification: PaymentClassification {}
class CommissionedClassification: PaymentClassification {}

protocol Affiliation {}
class NoAffiliation: Affiliation {}
class UnionAffiliation: Affiliation {}
```

이와 같은 패턴 사용은 이 시스템이 OCP를 잘 따르게 한다. `Employee` 클래스는 급여 지급 방법*PaymentMethod*, 급여 종류*PaymentClassification*, 조합 종류*Affiliation*에 대해 닫혀 있다. 클래스에 영향을 주지 않고 새로운 급여 지급 방법과 종류, 조합의 종류를 추가할 수 있다.

위의 구조는 **핵심 모델**이나 아키텍처가 된다.

### 임금지급일

Q : `Employee` 객체가 자신의 임금을 계산할 수 있는 방법을 어떻게 아는가?

A : `PaymentClassification`의 파생 클래스에 임금을 계산하는 일이 일어나야 할 것이다. 임금을 계산하기 위해 필요한 레코드를 갖기 때문에, 임금을 결정하는 메소드를 갖고 있을 것이다.

`Employee` 객체는 임금을 계산하라는 요청을 받으면, 해당 책임을 `PaymentClassification`에 넘긴다.

## 무엇을 배웠는가?

간단한 유스케이스 분석이 시스템 설계에 풍부한 정보와 영감을 가져다 준다. 유스케이스, 즉 행위에 대한 고찰로 다른 시각으로 설계를 바라볼 수 있었다.

## 잠재적인 추상화를 찾아서

OCP를 효과적으로 사용하려면 애플리케이션이 내포하는 추상화를 샅샅이 뒤져 찾아야 한다. 하지만 추상화는 애플리케이션의 요구사항에 명확하게 드러나지 않고, 심지어 암시조차 없는 경우가 많다.

몇몇 직원은 시간제로 일한다. 몇몇 직원은 고정된 월급을 받는다. 몇몇 직원은 수수료를 받는다.

위의 문장에서 우리는 '모든 직원은 임금을 받고, 서로 다른 체계에 따라 받는다'라는 일반화를 할 수 있다. 여기서 '모든 직원은 임금을 받는다'라는 추상화를 도출해낼 수 있다.

`PaymentClassification` 이 위의 추상화를 잘 해내고 있다. 이 추상화는 아주 간단한 유스케이스 분석에 의해 이미 사용자 스토리 속에서 발견된 것이다.

### 지급 주기 추상화

매주 금요일마다 임금을 받는다. 마지막 평일에 임금을 받는다. 격주 금요일마다 임금을 받는다.

위의 문장에서 '모든 직원은 어떤 지급 주기에 따라 임금을 받는다'라는 일반화를 할 수 있다. 여기서 '지급 주기'라는 개념의 추상화를 도출해낼 수 있을 것이다. 어떤 `Employee` 객체에 특정 날짜가 그 직원이 임금을 받는 날인지 물어볼 수 있어야 한다.

유스케이스는 직원의 임금 지급 주기를 임금 분류와 연계시키고 있었다. 하지만 정책이 바뀌어서 직원이 특정한 지급 주기를 선택할 수 있게 되거나, 직원이 서로 다른 지급 주기를 갖는 부서에 소속될 수 있을 것이다.

지급 주기 문제를 `PaymentClassification`에 위임했을 때 위와 같은 변경 사항이 발생하면, 지급 주기 변경에 대해 닫혀 있을 수 없게 된다. 지급 정책을 변경하면 지급 주기도 테스트해야 하며, 지급 주기를 변경하면 지급 정책도 테스트해야 한다. OCP와 SRP를 위반하게 된다.

이러한 일은 개발자에게는 흔한 일이지만, 관리자나 클라이언트에게는 두려운 일이다. 그들은 이러한 문제가 발생하면, 이후 어떠한 위치의 어떠한 변경이라 해도 시스템에서 관계 없는 어떠한 부분에든 문제를 일으킬 수 있을 것이라 생각할 것이다. 프로그램에 대한 신뢰성은 사라지게 된다.

이러한 생각은 유스케이스 분석으로 이끌어낸 것이 아니다. 요구사항을 주의 깊게 고려하고, 통찰력을 필요로 하는 문제다.

`PaymentSchedule`을 추상화하고, 스트래티지 패턴을 사용하여 `Employee`가 이것을 사용할 수 있도록 한다.

### 지급 방법

'모든 직원은 어떠한 방법에 의해 임금을 받는다'라는 일반화에서, '임금을 받는 방법'이라는 개념의 추상화를 도출해낼 수 있을 것이다. 이는 `PaymentMethod`에 의해 실현되었다.

### 조합

직원은 조합에 가입하지 않은 상태일 수도 있고, 조합이 아닌 자선 단체와 같은 곳에 임금의 일부를 자동 납부하는 요구 사항이 있을 수 있다. 그러므로 '직원은 임금에서 자동으로 돈을 지급받는 많은 단체에 가입되어 있을 수 있다'라고 일반화할 수 있다.

위의 일반화에서 `Affiliation`으로 추상화할 수 있다. 여러 개의 가입 단체를 가질 수 있으므로 리스트로 표현되며, 리스트가 비어 있다면 가입한 단체가 없다는 것을 의미하므로 널 오브젝트 패턴을 사용할 이유도 없어진다.

## 결론

하나의 반복이 시작될 때, 팀은 한데 모여 그 반복에 선택된 사용자 스토리의 설계를 놓고 논의한다. 이러한 **빠른 설계 회의**는 보통 한 시간이 가기 전에 끝난다. 회의의 목적은 사고 과정을 시작하고, 개발자들에게 일을 시작해나갈 공통적인 사고 모델을 주는 것이다.

확실한 설계를 만들어내는 것이 목표가 **아니다**.