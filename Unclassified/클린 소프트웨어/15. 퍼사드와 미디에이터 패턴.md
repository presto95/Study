# 퍼사드와 미디에이터 패턴

퍼사드*facade* 패턴과 미디에이터*mediator* 패턴은 모두 어떤 종류의 정책을 다른 객체들의 그룹에 부과한다.

퍼사드 패턴은 위로부터, 미디에이터 패턴은 아래로부터 정책을 적용한다.

퍼사드 패턴의 사용은 가시적이고 강제적이며, 미디에이터 패턴의 사용은 비가시적이고 허용적이다.

## 퍼사드 패턴

퍼사드 패턴은 복잡하고 일반적인 인터페이스를 가진 객체 그룹에 간단하고 구체적인 인터페이스를 제공하고자 할 때 사용한다.

애플리케이션이 어떤 패키지의 구체 내용을 알 필요가 없게, 퍼사드 객체가 패키지를 래핑하고, 애플리케이션이 퍼사드 객체를 사용하여 패키지에 접근한다.

퍼사드는 자신의 정책을 애플리케이션에 적용하며, 규정에 의해 퍼사드 객체는 패키지에 있는 기능에 접근하기 위한 유일한 수단이 된다.

## 미디에이터 패턴

미디에이터 패턴도 퍼사드 패턴과 마찬가지로 정책을 적용한다. 

하지만 퍼사드가 자신의 정책을 가시적이고 강제적으로 적용하는 반면, 미디에이터는 자신의 정책을 은밀하고 강제적이지 않은 방식으로 적용한다.

## 결론

정책 적용이 크고 가시적이어야 하는 경우에는 퍼사드를 사용하여 위로부터 정책을 적용할 수 있다.

교묘함과 재량이 필요한 경우에는 미디에이터를 사용하여 아래로부터 정책을 적용할 수 있다.

퍼사드는 어떠한 규정의 중심이 되며, 모든 사람들은 퍼사드 아래에 있는 것 대신 퍼사드를 사용하여 정책을 적용하도록 합의한다.

미디에이터는 클라이언트에게 감춰져 있다.

---

#### 추가

퍼사드 패턴은 클래스 라이브러리와 같은 어떤 소프트웨어의 다른 커다란 코드 부분에 대한 간략화된 인터페이스를 제공하며, 퍼사드는 그러한 인터페이스를 제공하는 객체다.

다음의 구조를 갖는다.

- 퍼사드
  - 다양한 패키지를 래핑하여 쉽고 단순한 인터페이스를 제공하는 객체.
- 클라이언트
  - 퍼사드 클래스를 사용하여 패키지 내의 리소스에 접근하는 객체.
- 패키지
  - 소프트웨어 라이브러리 및 API 집합. 퍼사드 객체를 통해 접근된다.

다음의 특징을 갖는다.

- 퍼사드는 소프트웨어 라이브러리를 쉽게 사용할 수 있게 해주며, 쉽게 이해할 수 있게 해준다. 공통 작업에 대해 간편한 메소드를 제공한다.
- 퍼사드는 라이브러리를 사용하는 코드를 읽기 쉽게 해준다.
- 퍼사드는 라이브러리 바깥쪽의 코드가 라이브러리 안쪽의 코드에 의존하는 일을 줄여준다. 바깥쪽 코드의 대부분은 퍼사드를 이용하기 때문에, 시스템을 개발하는 데 있어 유연성이 향상된다.
- 퍼사드는 좋게 작성되지 않은 API의 집합을 하나의 좋게 작성된 API로 감싸준다.

래퍼는 특정 인터페이스를 준수해야 한다.

단지 쉽고 단순한 인터페이스를 이용하고 싶을 때 사용한다.

```swift
// Packages
class CPU {
  func freeze() { ... }
  func jump(to position: Int) { ... }
  func execute() { ... }
}

class Memory {
  func load(_ data: Data, at position: Int) { ... }
}

// Facade
class Computer {
  func startComputer() {
    let cpu = CPU()
    let memory = Memory()
    ...
  }
}

// Client
let facade = Computer()
facade.startComputer()
```

미디에이터 패턴은 객체들의 집합이 상호작용하는 방법을 함축해놓은 객체를 정의한다. 객체 간 통신은 미디에이터 객체 안에 함축된다. 객체들은 서로 직접 통신하지 않으며, 미디에이터를 통해 통신한다. 이를 통해 객체 간 의존성을 줄여 결합도를 감소시킬 수 있다.

미디에이터 객체는 상호작용할 객체를 받아 상호작용 작업을 처리한다. 상호작용이 일어나는 객체들은 서로 직접적으로 연관되지 않아 결합도가 낮아지게 된다.