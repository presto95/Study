# 9장. 개방 폐쇄 원칙

> 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

**경직성** : 프로그램 한 군데를 변경한 것이 이에 의존적인 모듈에서 단계적인 변경을 일으킴

OCP를 지키지 않았다면 프로그램의 설계는 경직성의 악취를 풍긴다.

OCP를 잘 적용한다면 이미 잘 동작하고 있는 코드를 변경하지 않고 새로운 코드를 덧붙이는 것으로 변경할 수 있다.

**확장에 대해 열려 있다**

모듈의 행위가 확장될 수 있다. 

**수정에 대해 닫혀 있다**

모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.

어떤 모듈의 소스 코드를 변경하지 않고도 그 모듈의 행위를 바꾸는 일이 어떻게 가능할까?

## 해결책은 추상화다

추상화를 통해 고정되기는 해도 제한되지 않은 가능한 행위의 묶음을 표현할 수 있다.

모든 파생 가능한 클래스를 대표하는 가능한 행위의 제한되지 않은 묶음.

모듈의 행위는 추상화의 새로운 파생 클래스를 만듦으로써 확장이 가능하며, 이를 통해 수정에 닫혀 있을 수 있다.

### 의존 관계가 있는 두 모듈의 경우

어떠한 두 개의 클래스가 서로 의존 관계를 갖고 있을 때, 의존하는 모듈의 기능을 변경하려면 새로운 의존 모듈을 지정하도록 코드를 변경해야 하고, 이는 수정에 대해 닫혀 있지 않다.

의존하는 모듈의 추상화에 의존하여 위의 문제를 해결할 수 있다. 다른 의존하는 모듈을 사용하려면 추상화된 의존 모듈의 새로운 파생 클래스를 생성하여 그것을 사용하면 된다. 기존 의존 모듈은 변경되지 않았다.

### 어떠한 기능을 하는 하나의 모듈의 경우

모듈의 행위를 추상화한 인터페이스를 만들고, 이를 구현하는 여러 파생 클래스를 만들어 인터페이스가 정의한 행위를 확장하거나 수정할 수 있다.

## 예제

```swift
struct Point {
  let x: Int
  let y: Int
}

enum ShapeType {
  case circle
  case square
}

struct Shape {
  let type: ShapeType
}

struct Circle {
  let type: ShapeType
  let radius: Double
  let center: Point
}
func drawCircle(_ circle: Circle) { }

struct Square {
  let type: ShapeType
  let side: Double
  let topLeft: Point
}
func drawSquare(_ square: Square) { }

func drawAllShapes(_ shapes: [Shape]) {
  for shape in shapes {
    switch shape.type {
    case .square:
      drawSquare(shape as! Square)
    case .circle:
      drawCircle(shape as! Circle)
    }
  }
}
```

위의 코드는 OCP를 준수하지 않는다. `drawAllShapes(_:)` 함수는 새로운 도형이 등장했을 때 수정이 이루어져야 하므로 변경에 대해 닫혀 있지 않다.

또한 `ShapeType` 열거형에도 새로운 도형 종류가 추가될 때마다 수정이 이루어져야 한다.

`ShapeType` 열거형이 변경되면서 이 타입을 사용하는 자료 구조의 바이너리 파일도 재컴파일을 통해 변경되어야 한다.

새로운 도형을 추가하는 작업이 이토록 큰 영향을 미치는 것이다.

```swift
protocol Shape {
  func draw()
}

struct Square: Shape {
  func draw() { }
}

struct Circle: Shape {
  func draw() { }
}

func drawAllShapes(_ shapes: [Shape]) {
  for shape in shapes { shape.draw() }
}
```

위의 코드는 OCP를 준수한다. 새로운 도형 종류를 추가하려면 이를 추상화한 `Shape` 인터페이스를 구현해 주기만 하면 되며, 기존 코드를 수정할 필요가 없다.

이러한 변화에 대하여 애플리케이션 전체를 뒤지면서 변경이 필요한 부분을 찾을 필요가 없으므로 **취약하지 않으며 경직성이 없다.** 필요한 도형 종류만 다른 프로그램에서 재사용할 수 있으므로 **부동성이 없다.**

이처럼 기존 코드를 변경하지 않고 새로운 코드를 추가하는 방법으로 프로그램을 변경한다.

## 모든 상황에 알맞은 모델링

도형을 그리는 순서를 정의해야 한다는 요구 사항이 추가되었을 때, 위의 설계는 그렇게 좋은 것은 아니다. 

도형이라는 개념을 추상화하고 이를 구현하는 도형을 만드는 것이 자연스러울지라도, 도형 종류보다도 그 순서가 중요한 시스템에서는 이러한 모델링이 자연스럽지 않을 수 있다.

### 폐쇄는 완벽할 수 없기에, 전략적이어야 한다.

설계자는 자신의 설게에서 닫혀 있는 변경의 종류를 선택해야 한다.

변경이 일어날 가능성이 높은 것을 예측하고 이에 대해서 OCP를 적용하는 것이 좋다.

추상화 작업은 개발 시간과 노력을 충분히 들여야 하고, 과도한 추상화는 소프트웨어 설계의 복잡성을 높이기 때문에 있을 법한 변화에 대해 OCP를 적용하는 것이 좋다.

경험과 상식을 바탕으로, 변경에 일어날 때까지 기다려서 어떠한 변경이 일어날지 알 수 있을 것이다.

설계는 완벽할 수 없으므로, 변경이 일어날 것임을 알아야 하고, 변경이 되도록 이른 시점에 일어나게 하여 빠르게 코드를 수정하는 전략을 가져가는 것이 좋다. 이를 위해 변경을 시뮬레이션 할 필요가 있다.

- 테스트를 작성한다. 테스트는 시스템을 사용하는 방법 중 하나이므로, 프로그램을 테스트하기 위한 추상화를 만들 수 있을 것이다. 이를 통해 나중에 일어날 다른 종류의 변경으로부터 보호하는 추상화 중 많은 것을 알아차릴 수 있을 것이다.
- 짧은 주기로 개발한다.
- 기능 요소를 먼저 개발하고, 이를 이해당사자에게 자주 보여준다.
- 가장 중요한 기능 요소를 먼저 개발한다.
- 소프트웨어를 자주, 빨리 릴리즈한다. 가능한 한 자주, 가능한 한 빠르게 고객과 사용자 앞에서 이를 시연한다.

빠르게, 자주, 고객에게 보여주어 변경이 일어나는 것을 알아차리는 시점을 최대한 앞으로 당기는 것이 중요하다.

## 결론

OCP는 객체 지향 설계의 심장이다. 이 원칙을 준수하여 객체 지향 기술에서 당연하게 요구하는 최상의 효용 (유연성, 재사용성, 유지보수성 등) 을 낳을 수 있다.

하지만 과도한 추상화는 좋지 않으므로, 프로그램에서 자주 변경되는 부분에만 추상화를 적용하는 것이 중요하다.

> 어설픈 추상화를 피하는 일은 추상화 자체만큼이나 중요하다.