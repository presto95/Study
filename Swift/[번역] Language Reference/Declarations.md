# 선언

*선언*은 프로그램에 새로운 이름이나 구조를 도입한다. 예를 들어, 선언을 사용하여 함수와 메소드를 도입하고, 변수와 상수를 도입하고, 열거형, 구조체, 클래스 및 프로토콜 타입을 정의한다. 또한 선언을 사용하여 존재하는 이름 있는 타입의 동작을 확장하고 다른 곳에 선언된 심볼을 프로그램에 임포트한다.

Swift에서, 대부분의 선언은 선언되는 때에 구현되거나 초기화된다는 관점에서 또한 정의다. 즉, 프로토콜은 그 멤버들을 구현하지 않기 때문에, 대부분의 프로토콜 멤버들은 오직 선언일 뿐이다. 편리성과, Swift에서 이 차이는 그다지 중요하지 않기 때문에, *정의declaration*이라는 용어는 선언과 정의 모두를 다룬다.

## 최상위 수준 코드

Swift 소스 파일에서 최상위 수준의 코드는 0개 이상의 구문, 선언, 그리고 표현식으로 구성된다. 기본적으로 소스 파일의 최상위 수준에 선언된 변수, 상수, 그리고 다른 이름 있는 선언들은 같은 모듈에 있는 모든 소스 파일에서 해당 코드에 접근할 수 있다. 접근 수준 제어자와 함께 선언하여 이 기본 동작을 재정의할 수 있다.

두 가지 종류의 최상위 수준 코드가 있다: 최상위 수준 선언과 실행 가능한 최상위 수준 코드다. 최상위 수준 선언은 오직 선언으로만 구성되며, 모든 Swift 소스 파일에서 허용된다. 실행 가능한 최상위 수준 코드는 선언 뿐만 아니라 구문과 표현식을 포함하며, 오직 프로그램을 위한 최상위 수준 엔트리 포인트로만 허용된다.

실행 파일을 만들기 위해 컴파일되는 Swift 코드는 최상위 수준의 엔트리 포인트를 표시하기 위해, 코드가 파일과 모듈에서 어떻게 조직되어 있는지에 상관 없이, 다음의 접근법 중 최대 하나를 포함할 수 있다

- `main` 애트리뷰트
- `NSApplicationMain` 애트리뷰트
- `UIApplicationMain` 애트리뷰트
- `main.swift` 파일
- 최상위 수준의 실행 가능한 코드를 포함하는 파일

## 코드 블록

*코드 블록*은 구문들을 함께 묶기 위해 다양한 선언과 제어 구조에 의해 사용된다. 다음의 형식을 갖는다.

```
{
    {statements}
}
import {module}
import {import kind} {module}.{symbol name}
import {module}.{submodule}
let {constant name}: {type} = {expression}
let (firstNumber, secondNumber) = (10, 42)
print("The first number is \(firstNumber).")
// Prints "The first number is 10."
print("The second number is \(secondNumber).")
// Prints "The second number is 42."
var {variable name}: {type} = {expression}
var {variable name}: {type} {
    get {
        {statements}
    }
    set({setter name}) {
        {statements}
    }
}
var {variable name}: {type} = {expression} {
    willSet({setter name}) {
        {statements}
    }
    didSet({setter name}) {
        {statements}
    }
}
class Superclass {
    private var xValue = 12
    var x: Int {
        get { print("Getter was called"); return xValue }
        set { print("Setter was called"); xValue = newValue }
    }
}

// This subclass doesn't refer to oldValue in its observer, so the
// superclass's getter is called only once to print the value.
class New: Superclass {
    override var x: Int {
        didSet { print("New value \(x)") }
    }
}
let new = New()
new.x = 100
// Prints "Setter was called"
// Prints "Getter was called"
// Prints "New value 100"

// This subclass refers to oldValue in its observer, so the superclass's
// getter is called once before the setter, and again to print the value.
class NewAndOld: Superclass {
    override var x: Int {
        didSet { print("Old value \(oldValue) - new value \(x)") }
    }
}
let newAndOld = NewAndOld()
newAndOld.x = 200
// Prints "Getter was called"
// Prints "Setter was called"
// Prints "Getter was called"
// Prints "Old value 12 - new value 200"
typealias {name} = {existing type}
typealias StringDictionary<Value> = Dictionary<String, Value>

// The following dictionaries have the same type.
var dictionary1: StringDictionary<Int> = [:]
var dictionary2: Dictionary<String, Int> = [:]
typealias DictionaryOfInts<Key: Hashable> = Dictionary<Key, Int>
typealias Diccionario = Dictionary
protocol Sequence {
    associatedtype Iterator: IteratorProtocol
    typealias Element = Iterator.Element
}

func sum<T: Sequence>(_ sequence: T) -> Int where T.Element == Int {
    // ...
}
func {function name}
({parameters}) -> {return type} {
    {statements}
}
```

- 정수 리터럴에 대하여 `ExpressibleByIntegerLiteral`

- 부동소수점 리터럴에 대하여 `ExpressibleByFloatLiteral`

- 여러 개의 문자를 포함하는 문자열 리터럴에 대하여 `ExpressibleByStringLiteral`

- 오직 하나의 문자를 포함하는 문자열 리터럴에 대하여 `ExpressibleByExtendedGraphemeClusterLiteral`

  각 케이스는 반드시 유일한 이름을 갖고 유일한 원시 값이 할당되어야 한다.

  원시 값 타입이 `Int`로 지정되고 케이스들에 명시적으로 값을 할당하지 않는다면, 암시적으로 `0`, `1`, `2` 등의 값이 할당된다. `Int` 타입의 각각의 할당되지 않은 케이스는 이전 케이스의 원시 값으로부터 자동으로 증가된 원시 값을 암시적으로 할당받는다.

  ```
  enum ExampleEnum: Int {
      case a, b, c = 5, d
  }
  ```

  위의 예제에서, `ExampleEnum.a`의 원시 값은 `0`이고, `ExampleEnum.b`의 원시 값은 `1`이다. 그리고 `ExampleEnum.c`의 값이 명시적으로 `5`로 설정되었기 때문에, `ExampleEnum.d`의 값은 자동으로 `5`에서 증가하여 `6`이 된다.

  원시 값 타입이 `String`으로 지정되고 케이스들에 값을 명시적으로 할당하지 않는다면, 각각의 할당되지 않은 케이스는 암시적으로 해당 케이스의 이름과 같은 텍스트의 문자열이 할당된다.

  ```
  enum GamePlayMode: String {
      case cooperative, individual, competitive
  }
  ```

  위의 예제에서, `GamePlayMode.cooperative`의 원시 값은 `"cooperative"`이고, `GamePlayMode.individual`의 원시 값은 `"individual"`이고, `GamePlayMode.competitive`의 원시 값은 `"competitive"`이다.

  원시 값 타입을 갖는 케이스를 가진 열거형은 암시적으로 `RawPresentable` 프로토콜을 준수하며, 이는 Swift 표준 라이브러리에 정의되어 있다. 결과적으로, 그것들은 `rawValue` 프로퍼티를 갖고 `init?(rawValue: RawValue)` 시그니쳐를 가진 실패 가능한 이니셜라이저를 갖는다. `ExampleEnum.b.rawValue`처럼 열거형 케이스의 원시 값에 접근하기 위해 `rawValue` 프로퍼티를 사용할 수 있다. 또한 원시 값에 대응하는 케이스가 있다면, `ExampleEnum(rawValue: 5)`처럼 이를 찾기 위해 원시 값을 사용하여 열거형의 실패 가능한 이니셜라이저를 호출할 수 있으며, 이는 옵셔널 케이스를 반환한다.

  ### 열거형 케이스에 접근하기

  열거형 타입의 케이스를 참조하기 위해 `EnumerationType.enumerationCase`처럼 점 (`.`) 신택스를 사용한다. 열거형 타입이 컨텍스트로부터 추론될 수 있다면, 이를 생략할 수 있다. (점은 여전히 필요하다.)

  열거형 케이스의 값을 확인하기 위해 `switch` 구문을 사용할 수 있다. 열거형 타입은 `switch` 구문의 케이스 블록에 있는 열거형 케이스 패턴에 대하여 패턴 매칭된다.

  ## 구조체 선언

  *구조체 선언*은 **프로그램에 이름 있는 구조체 타입을 도입한다. 구조체 선언은 `struct` 키워드를 사용하여 선언되고 다음의 형식을 갖는다.

  ```
  struct {structure name}: {adopted protocols} {
      {declarations}
  }
  ```

  구조체의 구현부는 0개 이상의 *declarations*를 포함한다. 이 *declarations*는 저장 프로퍼티와 연산 프로퍼티, 타입 프로퍼티, 인스턴스 메소드, 타입 메소드, 이니셜라이저, 서브스크립트, 타입 별칭, 그리고 심지어 다른 구조체, 클래스, 열거형의 선언을 모두 포함할 수 있다. 구조체 선언은 디이니셜라이저나 프로토콜 선언을 포함할 수 없다.

  구조체 타입은 여러 개의 프로토콜을 채택할 수 있으나, 클래스, 열거형, 또는 다른 구조체로부터 상속될 수 없다.

  이전에 선언된 구조체의 인스턴스를 만드는 세 가지 방법이 있다.

  - 구조체 안에 선언된 이니셜라이저 중 하나를 호출하기
  - 이니셜라이저가 선언되어 있지 않다면, 구조체의 멤버와이즈 이니셜라이저를 호출하기
  - 이니셜라이저가 선언되어 있지 않고, 구조체 선언의 모든 프로퍼티가 초기값을 갖고 있다면, 구조체의 기본 이니셜라이저 호출하기

  구조체 인스턴스의 프로퍼티들은 점 (`.`) 신택스를 사용하여 접근할 수 있다.

  구조체는 값 타입이다; 구조체의 인스턴스는 변수나 상수에 할당될 때, 또는 함수 호출의 인자로 넘겨질 때 복사된다.

  익스텐션 선언을 사용하여 구조체 타입의 동작을 확장할 수 있다.

  ## 클래스 선언

  *클래스 선언*은 프로그램에 이름 있는 클래스 타입을 도입한다. 클래스 선언은 `class` 키워드를 사용하여 선언되며 다음의 형식을 갖는다.

  ```
  class {class name}: {superclass}, {adopted protocols} {
      {declarations}
  }
  ```

  클래스의 구현부는 0개 이상의 *declarations*를 포함한다. 이 *declarations*는 저장 프로퍼티와 연산 프로퍼티 모두, 인스턴스 메소드, 타입 메소드, 이니셜라이저, 한 개의 디이니셜라이저, 서브스크립트, 타입 별칭, 그리고 심지어 다른 클래스, 구조체, 열거형의 선언을 포함할 수 있다. 클래스 선언은 프로토콜 선언을 포함할 수 없다.

  클래스 타입은 오직 하나의 부모 클래스, *superclass*로부터 상속될 수 있지만, 여러 개의 프로토콜을 채택할 수 있다. *superclass*는 *class name*과 콜론 다음에 첫 번째로 나타나며, 이후에 *adopted protocols*가 따라나온다. 하지만 제네릭이 아닌 클래스는 오직 제네릭이 아닌 클래스로부터만 상속받을 수 있다. 콜론 다음에 제네릭 슈퍼클래스의 이름을 작성한다면, 그것의 제네릭 매개변수 절을 포함하여 제네릭 클래스의 완전한 이름을 반드시 포함해야 한다.

  클래스는 지정 이니셜라이저와 편의 이니셜라이저를 가질 수 있다. 클래스의 지정 이니셜라이저는 반드시 클래스에 선언된 모든 프로퍼티를 초기화해야 하고, 이를 반드시 슈퍼클래스의 지정 이니셜라이저 중 어떤 것이 호출되기 전에 해야 한다.

  클래스는 그 슈퍼클래스의 프로퍼티, 메소드, 서브스크립트, 이니셜라이저를 재정의할 수 있다. 재정의된 프로퍼티, 메소드, 서브스크립트, 지정 이니셜라이저는 반드시 `override` 선언 지정자와 함께 표시되어야 한다.

  서브클래스가 슈퍼클래스의 이니셜라이저를 구현하는 것을 요구하기 위해, 슈퍼클래스의 이니셜라이저에 `required` 선언 지정자를 붙인다. 해당 이니셜라이저의 서브클래스 구현도 역시 반드시 `required` 선언 지정자와 함께 표시되어야 한다.

  *superclass*에 선언된 프로퍼티와 메소드들이 현재 클래스에 의해 상속되었을지라도, *superclass*에 선언된 지정 이니셜라이저는 오직 서브클래스가 자동 이니셜라이저 상속의 조건을 충족할 때에만 상속된다. Swift는 보편적인 기반 클래스로부터 상속되지 않는다.

  이전에 선언된 클래스의 인스턴스를 생성하는 두 가지 방법이 있다.

  - 클래스 안에 선언된 이니셜라이저 중 하나를 호출하기
  - 이니셜라이저가 선언되어 있지 않고, 클래스의 모든 프로퍼티가 초기값을 가지고 있다면, 클래스의 기본 이니셜라이저를 호출하기

  클래스 인스턴스의 프로퍼티에 접근하기 위해 점 (`.`) 신택스를 사용한다.

  클래스는 참조 타입이다; 클래스의 인스턴스는 변수나 상수에 할당되거나 함수 호출의 인자로 넘겨질 때 복사되지 않고 참조된다.

  익스텐션 선언을 사용하여 클래스 타입의 동작을 확장할 수 있다.

  ## 프로토콜 선언

  *프로토콜 선언*은 프로그램에 이름 있는 프로토콜 타입을 도입한다. 프로토콜 선언은 `protocol` 키워드를 사용하여 전역 스코프에 선언되며 다음의 형식을 갖는다.

  ```
  protocol {protocol name}: {inherited protocols} {
      {protocol member declarations}
  }
  ```

  프로토콜의 구현부는 0개 이상의 *protocol member declarations*를 포함하며, 해당 프로토콜을 채택하는 타입이 반드시 충족해야 하는 준수 요구 조건을 기술한다. 특히, 프로토콜은 이를 준수하는 타입이 특정 프로퍼티, 메소드, 이니셜라이저, 서브스크립트를 반드시 구현해야 하도록 선언할 수 있다. 프로토콜은 또한 *연관 타입*이라고 불리는 특별한 종류의 타입 별칭을 선언할 수 있다. 이는 프로토콜의 다양한 선언 가운데의 관계를 지정할 수 있다. 프로토콜 선언은 클래스, 구조체, 열거형, 또는 다른 프로토콜 선언을 포함할 수 없다. 

  프로토콜 타입은 여러 개의 다른 프로토콜로부터 상속될 수 있다. 프로토콜 타입이 다른 프로토콜로부터 상속될 때, 그러한 다른 프로토콜의 요구사항 집합들은 결합되며, 현재 프로토콜로부터 상속받은 어떠한 타입이든지 그러한 모든 요구사항을 반드시 준수해야 한다.

  - 알아두기

    프로토콜 합성 타입을 사용하여 여러 개의 프로토콜의 준수 요구 조건을 결합할 수도 있다.

  타입의 익스텐션 선언에서 해당 프로토콜을 채택하여 이전에 선언된 타입에 대해 프로토콜 준수를 추가할 수 있다. 익스텐션에서, 반드시 채택된 프로토콜의 모든 요구사항을 구현해야 한다. 이미 타입이 모든 요구사항을 구현하고 있다면, 익스텐션 선언의 구현부를 빈 상태로 둘 수 있다.

  기본적으로, 프로토콜을 채택하는 타입은 프로토콜에 선언된 모든 프로퍼티, 메소드, 서브스크립트를 반드시 구현해야 한다. 즉, 이러한 프로토콜 멤버 선언에 `optional` 선언 지정자를 붙여 준수하는 타입의 구현이 선택적일 수 있게 할 수 있다. `optional` 지정자는 오직 `objc` 애트리뷰트로 표시된 멤버에 대해서만 적용 가능하며, `objc` 애트리뷰트로 표시된 프로토콜의 멤버들에 대해서만 적용 가능하다. 결과적으로, 오직 클래스 타입만이 선택적 멤버 요구 사항을 포함하는 프로토콜을 채택하고 준수할 수 있다.

  열거형의 케이스들은 타입 멤버에 대해 프로토콜 요구사항을 충족할 수 있다. 특히, 연관 값이 없는 열거형 케이스는 `Self` 타입의 읽기 전용 타입 변수에 대해서 프로토콜 요구사항을 충족하고, 연관 값이 있는 열거형 케이스는 매개변수와 인자 레이블이 케이스의 연관 값과 매칭되는 `Self`를 반환하는 함수에 대해서 프로토콜 요구사항을 충족한다.

  ```
  protocol SomeProtocol {
      static var someValue: Self { get }
      static func someFunction(x: Int) -> Self
  }
  enum MyEnum: SomeProtocol {
      case someValue
      case someFunction(x: Int)
  }
  ```

  클래스 타입만 프로토콜을 채택할 수 있도록 제한하기 위해 *inherited protocols* 리스트에 `AnyObject` 프로토콜을 콜론 뒤에 포함한다. 예를 들어, 다음의 프로토콜은 오직 클래스 타입만 채택할 수 있다.

  ```
  protocol SomeProtocol: AnyObject {
      /* Protocol members go here */
  }
  ```

  `AnyObject`로 표시된 프로토콜을 상속받은 프로토콜은 또한 오직 클래스 타입만 채택할 수 있다.

  - 알아두기

    프로토콜이 `objc` 애트리뷰트로 표시되어 있다면, `AnyObject` 요구조건은 해당 프로토콜에 암시적으로 적용된다; 명시적으로 `AnyObject` 요구조건을 프로토콜에 표시할 필요가 없다.

  프로토콜은 이름 있는 타입이며, 그러므로 다른 이름 있는 타입들처럼 코드의 모든 동일한 장소에서 나타날 수 있다. 그러나 프로토콜의 인스턴스를 만들 수 없는데, 프로토콜은 그것이 지정한 요구조건에 대한 구현을 실제로 제공하지 않기 때문이다.

  어떤 메소드가 클래스나 구조체가 구현해야 하는 델리게이트가 되는지를 선언하기 위해 프로토콜을 사용할 수 있다.

  ### 프로토콜 프로퍼티 선언

  프로토콜은 그것을 준수하는 타입이 반드시 구현해야 하는 프로퍼티를 프로토콜 선언의 구현부에 *프로토콜 프로퍼티 선언*을 포함하여 선언한다. 프로토콜 프로퍼티 선언은 변수 선언의 특별한 형식을 갖는다.

  ```
  var {property name}: {type} { get set }
  ```

  다른 프로톹콜 멤버 선언처럼, 이러한 프로퍼티 선언들은 해당 프로토콜을 준수하는 타입에 대한 접근자 및 설정자 요구조건만을 선언한다. 결과적으로, 접근자나 설정자가 선언된 프로토콜에서 직접 구현하지 않는다.

  접근자 및 설정자 요구조건은 준수하는 타입에 의해 다양한 방법으로 충족될 수 있다. 프로퍼티 선언이 `get`과 `set` 키워드를 모두 포함하고 있다면, 준수하는 타입은 저장 변수 프로퍼티 또는 연산 프로퍼티로 그것을 구현하여, 읽고 쓰기가 모두 가능하게 할 수 있다. (즉, 접근자와 설정자를 모두 구현함.) 그러나, 해당 프로퍼티 선언은 상수 프로퍼티나 읽기 전용 연산 프로퍼티로 구현될 수 없다. 프로퍼티 선언이 오직 `get` 키워드만을 포함한다면, 어떠한 종류의 프로퍼티로든 구현될 수 있다.

  프로토콜 선언에 타입 프로퍼티 요구조건을 선언하기 위해, 프로퍼티 선언을 `static` 키워드와 함께 표시한다. 해당 프로토콜을 준수하는 구조체와 열거형은 그 프로퍼티를 `static` 키워드로 선언하고, 해당 프로토콜을 준수하는 클래스는 `static` 또는 `class` 키워드로 선언한다. 프로토콜 준수를 구조체, 열거형, 또는 클래스에 추가하는 익스텐션은 사용을 확장하는 타입과 같은 키워드를 사용한다. 타입 프로퍼티 요구조건에 기본 구현을 제공하는 익스텐션은 `static` 키워드를 사용한다.

  ### 프로토콜 메소드 선언

  프로토콜은 그것을 준수하는 타입이 반드시 구현해야 하는 메소드를 프로토콜 선언의 구현부에 프로토콜 메소드 선언을 포함하여 선언한다. 프로토콜 메소드 선언은 함수 선언과 같은 형식을 갖고 있으나, 두 가지 예외가 있다: 함수 구현부를 포함하지 않고, 함수 선언의 일부분으로 기본 매개변수 값을 제공할 수 없다.

  프로토콜 선언에 클래스 또는 정적 메소드 요구조건을 선언하기 위해, `static` 선언 지정자와 함께 메소드 선언을 표시한다. 해당 프로토콜을 준수하는 구조체와 열거형은 `static` 키워드로 메소드를 선언하며, 해당 프로토콜을 준수하는 클래스는 `static`이나 `class` 키워드로 메소드를 선언한다. 구조체, 열거형, 또는 클래스에 프로토콜 준수를 추가하는 익스텐션은 사용을 확장하는 타입과 같은 키워드를 사용한다. 타입 메소드 요구조건에 기본 구현을 제공하는 익스텐션은 `static` 키워드를 사용한다.

  ### 프로토콜 이니셜라이저 선언

  프로토콜은 그것을 준수하는 타입이 반드시 구현해야 하는 이니셜라이저를 프로토콜 선언의 구현부에 프로토콜 이니셜라이저 선언을 포함하여 선언한다. 프로토콜 이니셜라이저 선언은 이니셜라이저 선언과 같은 형식을 갖고 있으나, 이니셜라이저의 구현부는 포함하지 않는다.

  준수하는 타입은 실패하지 않는 이니셜라이저나 `init!` 실패 가능한 이니셜라이저를 구현하여 실패하지 않는 프로토콜 이니셜라이저 요구조건을 충족할 수 있다. 준수하는 타입은 어떤 종류의 이니셜라이저든 구현하여 실패 가능한 프로토콜 이니셜라이저 요구조건을 충족할 수 있다.

  클래스가 프로토콜의 이니셜라이저 요구조건을 충족하기 위해 이니셜라이저를 구현할 때, 해당 이니셜라이저는 클래스가 이미 `final` 선언 지정자로 표시되지 않았다면 반드시 `required` 선언 지정자와 함께 표시되어야 한다.

  ### 프로토콜 서브스크립트 선언

  프로토콜은 그것을 준수하는 타입이 반드시 구현해야 하는 서브스크립트를 프로토콜 선언의 구현부에 프로토콜 서브스크립트 선언을 포함하여 선언한다. 프로토콜 서브스크립트 선언은 서브스크립트 선언의 특별한 형식을 갖는다.

  ```
  subscript ({parameters}) -> {return type} { get set }
  ```

  서브스크립트 선언은 해당 프로토콜을 준수하는 타입에 대해 최소한의 접근자 및 설정자 구현 요구사항만을 선언한다. 서브스크립트가 `get`과 `set` 키워드 모두를 포함하고 있다면, 준수하는 타입은 반드시 접근자 절 및 설정자 절을 모두 구현해야 한다. 서브스크립트 선언이 `get` 키워드만을 포함한다면, 준수하는 타입은 반드시 *적어도* 접근자 절을 구현해야 하며, 선택적으로 설정자 절을 구현할 수 있다.

  프로토콜 선언에 정적 서브스크립트 요구조건을 선언하기 위해 `static` 선언 지정자와 함께 서브스크립트 선언을 표시한다. 해당 프로토콜을 준수하는 구조체와 열거형은 `static` 키워드와 함께 서브스크립트를 선언하며, 해당 프로토콜을 준수하는 클래스는 `static`이나 `class` 키워드를 사용하여 서브스크립트를 선언한다. 구조체, 열거형, 또는 클래스에 프로토콜 준수를 추가하는 익스텐션은 사용을 확장하는 타입과 같은 키워드를 사용한다. 정적 서브스크립트 구현에 기본 구현을 제공하는 익스텐션은 `static` 키워드를 사용한다.

  ### 프로토콜 연관 타입 선언

  프로토콜은 `associatedtype` 키워드를 사용하여 연관 타입을 선언한다. 연관 타입은 프로토콜 선언의 일부분으로 사용되는 타입에 대한 별칭을 제공한다. 연관 타입은 제네릭 매개변수 절의 타입 매개변수와 비슷하나, 그것들은 선언된 프로토콜에서 `Self`와  연관되어 있다. 해당 컨텍스트에서, `Self`는 프로토콜을 준수하는 최후의 타입을 참조한다.

  또다른 프로토콜로부터 상속되는 연관 타입에 제약을 추가하기 위해, 연관 타입을 다시 선언하지 않고, 프로토콜 선언에 제네릭 `where` 절을 사용한다. 예를 들어, 아래의 `SubProtocol`의 선언은 동일하다.

  ```
  protocol SomeProtocol {
      associatedtype SomeType
  }
  
  protocol SubProtocolA: SomeProtocol {
      // This syntax produces a warning.
      associatedtype SomeType: Equatable
  }
  
  // This syntax is preferred.
  protocol SubProtocolB: SomeProtocol where SomeType: Equatable { }
  ```

  ## 이니셜라이저 선언

  *이니셜라이저 선언*은 프로그램에 클래스, 구조체, 또는 열거형에 대한 이니셜라이저를 도입한다. 이니셜라이저 선언은 `init` 키워드를 사용하여 선언되며 두 가지 기본 형식을 갖는다.

  구조체, 열거형, 그리고 클래스 타입은 여러 개의 이니셜라이저를 가질 수 있으나, 클래스 이니셜라이저에 대한 규칙과 연관 동작은 다르다. 구조체와 열거형과 는 다르게, 클래스는 두 가지 종류의 이니셜라이저, 지정 이니셜라이저와 편의 이니셜라이저를 갖는다.

  다음의 형식은 구조체, 열거형에 대한 이니셜라이저, 그리고 클래스에 대한 지정 이니셜라이저를 선언한다.

  ```
  init({parameters}) {
      {statements}
  }
  ```

  클래스의 지정 이니셜라이저는 클래스의 모든 프로퍼티를 직접 초기화한다. 같은 클래스에 있는 다른 이니셜라이저를 호출할 수 없고, 이 클래스가 슈퍼클래스를 갖는다면, 반드시 슈퍼클래스의 지정 이니셜라이저 중 하나를 호출해야 한다. 클래스가 슈퍼클래스로부터 어떤 프로퍼티를 상속받았다면, 슈퍼클래스의 지정 이니셜라이저 중 하나는 반드시 현재 클래스에서 이러한 프로퍼티가 설정되거나 수정되기 전에 호출되어야 한다.

  지정 이니셜라이저는 오직 클래스 선언 컨텍스트에서만 선언될 수 있으므로, 익스텐션 선언을 사용하여 클래스에 추가될 수 없다.

  구조체와 열거형에 있는 이니셜라이저는 선언된 다른 이니셜라이저를 호출하여 초기화 프로세스의 일부 또는 모두를 위임할 수 있다.

  클래스에 대해 편의 이니셜라이저를 선언하기 위해, `convenience` 선언 지정자와 함께 이니셜라이저 선언을 표시한다.

  ```
  convenience init({parameters}) {
      {statements}
  }
  ```

  편의 이니셜라이저는 또다른 편의 이니셜라이저나 클래스의 지정 이니셜라이저 중 하나에 초기화 프로세스를 위임할 수 있다. 즉, 초기화 프로세스는 반드시 클래스의 프로퍼티들을 완전하게 초기화하는 지정 이니셜라이저를 호출하는 것으로 종료해야 한다. 편의 이니셜라이저는 슈퍼클래스의 이니셜라이저를 호출할 수 없다.

  모든 서브클래스가 이니셜라이저를 구현하도록 요구하기 위해 `required` 선언 지정자를 사용하여 지정 및 편의 이니셜라이저를 표시할 수 있다. 해당 이니셜라이저의 서브클래스의 구현은 또한 반드시 `required` 선언 지정자를 사용하여 표시되어야 한다.

  기본적으로, 슈퍼클래스에 선언된 이니셜라이저는 서브클래스로 상속되지 않는다. 즉, 서브클래스가 그것의 모든 저장 프로퍼티에 기본값을 주어 초기화하고 그 자체에 이니셜라이저를 정의하지 않는다면, 슈퍼클래스의 모든 이니셜라이저를 상속받는다. 서브클래스가 슈퍼클래스의 모든 지정 이니셜라이저를 재정의한다면, 슈퍼클래스의 편의 이니셜라이저를 상속받는다.

  메소드, 프로퍼티, 서브스크립트처럼, 재정의된 지정 이니셜라이저에 대해 `override` 선언 지정자를 표시해야 한다.

  - 알아두기

    `required` 선언 지정자로 이니셜라이저를 표시한다면, 서브클래스에서 필수 이니셜라이저를 재정의할 때 `override` 지정자도 이니셜라이저에 표시하지 않는다.

  함수나 메소드처럼, 이니셜라이저는 에러를 던지거나 다시 던질 수 있다. 그리고 함수나 메소드처럼, 적절한 동작을 가리키기 위해 이니셜라이저의 매개변수 다음에 `throws`나 `rethrows` 키워드를 사용한다.

  ### 실패 가능한 이니셜라이저

  *실패 가능한 이니셜라이저*는 이니셜라이저가 선언된 타입의 옵셔널 인스턴스나 암시적으로 언래핑된 옵셔널 인스턴스를 만드는 이니셜라이저의 형식이다. 결과적으로, 실패 가능한 이니셜라이저는 초기화가 실패했다는 것을 가리키기 위해 `nil`을 반환할 수 있다.

  옵셔널 인스턴스를 만드는 실패 가능한 이니셜라이저를 선언하기 위해, 이니셜라이저 선언에 물음표를 덧붙인다 (`init?`). 암시적으로 언래핑되는 옵셔널 인스턴스를 만드는 실패 가능한 이니셜라이저를 선언하기 위해 느낌표를 대신 덧붙인다 (`init!`). 아래의 예시는 구조체의 옵셔널 인스턴스를 만드는 `init?` 실패 가능한 이니셜라이저를 보여준다.

  ```
  struct SomeStruct {
      let property: String
      // produces an optional instance of 'SomeStruct'
      init?(input: String) {
          if input.isEmpty {
              // discard 'self' and return 'nil'
              return nil
          }
          property = input
      }
  }
  ```

  실패하지 않는 이니셜라이저를 호출하는 것과 같은 방식으로 `init?` 실패 가능한 이니셜라이저를 호출한다. 단지 결과의 옵셔널 여부를 반드시 신경써야 한다.

  ```
  if let actualInstance = SomeStruct(input: "Hello") {
      // do something with the instance of 'SomeStruct'
  } else {
      // initialization of 'SomeStruct' failed and the initializer returned 'nil'
  }
  ```

  실패 가능한 이니셜라이저는 이니셜라이저 구현부의 어느 곳에서든 `nil`을 반환할 수 있다.

  실패 가능한 이니셜라이저는 어떠한 종류의 이니셜라이저에든 위임할 수 있다. 실패하지 않는 이니셜라이저는 또다른 실패하지 않는 이니셜라이저나 `init!` 실패 가능한 이니셜라이저에 위임할 수 있다. 실패하지 않는 이니셜라이저는 슈퍼클래스의 이니셜라이저의 결과를 강제 언래핑하는 것으로 `init?` 실패 가능한 이니셜라이저에 위임할 수 있다. 예를 들어, `super.init()!`처럼 작성할 수 있다.

  초기화 실패는 이니셜라이저 위임을 통해 전파된다. 특히, 실패 가능한 이니셜라이저가 실패하여 `nil`을 반환한 이니셜라이저에 위임한다면, 위임된 해당 이니셜라이저 또한 실패하고 암시적으로 `nil`을 반환한다. 실패하지 않는 이니셜라이저가 `init!` 실패 가능한 이니셜라이저에 위임하고 실패하여 `nil`을 반환한다면, 런타임 에러가 발생한다. (`nil` 값을 가진 옵셔널을 언래핑하기 위해 `!` 연산자를 사용하는 것처럼.)

  실패 가능한 지정 이니셜라이저는 어떠한 종류의 지정 이니셜라이저로든 서브클래스에서 재정의될 수 있다. 실패하지 않는 지정 이니셜라이저는 오직 실패하지 않는 지정 이니셜라이저로만 서브클래스에서 재정의될 수 있다.

  ## 디이니셜라이저 선언

  *디이니셜라이저 선언*은 클래스 타입에 대해 디이니셜라이저를 선언한다. 디이니셜라이저는 매개변수를 취하지 않고 다음의 형식을 갖는다.

  ```
  deinit {
      {statements}
  }
  ```

  디이니셜라이저는 클래스 객체에 대해 더 이상의 참조가 없을 때, 해당 클래스 객체가 할당 해제되기 직전에 자동으로 호출된다. 디이니셜라이저는 오직 클래스 선언의 구현부에서만 선언될 수 있으며, 클래스의 익스텐션 안에서는 선언될 수 없다. 그리고 각각의 클래스는 최대 하나의 디이니셜라이저를 가질 수 있다.

  서브클래스는 그 슈퍼클래스의 디이니셜라이저를 상속받으며, 해당 서브클래스가 할당 해제되기 직전에 암시적으로 호출된다. 해당 서브클래스 객체는 그 상속 체인에 있는 모든 디이니셜라이저들이 실행을 끝낼 때까지 할당 해제되지 않는다.

  디이니셜라이저는 직접 호출되지 않는다.

  ## 익스텐션 선언

  *익스텐션 선언*은 존재하는 타입의 동작을 확장할 수 있게 해준다. 익스텐션 선언은 `extension` 키워드를 사용하여 선언되며 다음의 형식을 갖는다.

  ```
  extension {type name} where {requirements} {
      {declarations}
  }
  ```

  익스텐션 선언의 구현부는 0개 이상의 *declarations*를 포함한다. 이러한 *declarations*는 연산 프로퍼티, 연산 타입 프로퍼티, 인스턴스 메소드, 타입 메소드, 이니셜라이저, 서브스크립트 선언, 그리고 심지어 클래스, 구조체, 열거형 선언도 포함할 수 있다. 익스텐션 선언은 디이니셜라이저나 프로토콜 선언, 저장 프로퍼티, 프로퍼티 옵저버, 또는 다른 익스텐션 선언을 포함할 수 없다. 프로토콜 익스텐션에 있는 선언들은 `final`로 표시될 수 없다.

  *type name*이 클래스, 구조체, 또는 열거형 타입일 때, 해당 익스텐션은 해당 타입을 확장한다. *type name*이 프로토콜 타입일 때, 해당 익스텐션은 해당 프로토콜을 준수하는 모든 타입을 확장한다.

  제네릭 타입이나 연관 타입을 가진 프로토콜을 확장하는 익스텐션 선언은 *requirements*를 포함할 수 있다. 확장된 타입이나 확장된 프로토콜을 준수하는 타입의 인스턴스가 *requirements*를 만족하면, 해당 인스턴스는 선언에 지정된 동작을 획득한다.

  익스텐션 선언은 이니셜라이저 선언을 포함할 수 있다. 즉, 확장한 타입이 또다른 모듈에 정의되어 있다면, 이니셜라이저 선언은 해당 타입의 멤버들이 적절하게 초기화되는 것을 보장하기 위해 이미 해당 모듈에 정의된 이니셜라이저에 위임해야 한다.

  존재하는 타입의 프로퍼티, 메소드, 이니셜라이저는 해당 타입의 익스텐션 안에서 재정의될 수 없다.

  익스텐션 선언은 *adopted protocols*를 지정하여 존재하는 클래스, 구조체, 또는 열거형 타입에 프로토콜 준수를 추가할 수 있다.

  ```
  extension {type name}: {adopted protocols} where {requirements} {
      {declarations}
  }
  ```

  익스텐션 선언은 존재하는 클래스에 대해 클래스 상속을 추가할 수 없다. 그러므로 *type name*과 콜론 다음에는 오직 프로토콜의 리스트만 지정할 수 있다.

  ### 조건적 준수

  조건적으로 프로토콜을 준수할 수 있도록 제네릭 타입을 확장하여, 해당 타입의 인스턴스가 특정 요구조건이 충족되었을 때만 해당 프로토콜을 준수할 수 있도록 할 수 있다. 익스텐션 선언의 *requirements*를 포함하여 프로토콜에 대한 조건적 준수를 추가한다.

  **재정의된 요구조건은 몇몇 제네릭 컨텍스트에서 사용되지 않는다**

  몇몇 제네릭 컨텍스트에서, 프로토콜에 대한 조건적 준수로부터 동작을 획득한 타입들은 항상 프로토콜 요구조건에 특정한 구현을 사용하지 않는다. 이 동작을 묘사하기 위해, 다음의 예시는 두 개의 프로토콜을 정의하고 이 프로토콜들을 모두 조건적으로 준수하는 제네릭 타입을 정의한다.

  ```
  protocol Loggable {
      func log()
  }
  extension Loggable {
      func log() {
          print(self)
      }
  }
  
  protocol TitledLoggable: Loggable {
      static var logTitle: String { get }
  }
  extension TitledLoggable {
      func log() {
          print("\(Self.logTitle): \(self)")
      }
  }
  
  struct Pair<T>: CustomStringConvertible {
      let first: T
      let second: T
      var description: String {
          return "(\(first), \(second))"
      }
  }
  
  extension Pair: Loggable where T: Loggable { }
  extension Pair: TitledLoggable where T: TitledLoggable {
      static var logTitle: String {
          return "Pair of '\(T.logTitle)'"
      }
  }
  
  extension String: TitledLoggable {
      static var logTitle: String {
          return "String"
      }
  }
  ```

  `Pair` 구조체는 그 제네릭 타입이 `Loggable` 또는 `TitledLoggable`을 준수할 때마다 각각 `Loggable`과 `TitledLoggable` 준수한다. 아래의 예시에서, `oneAndTwo`는 `Pair<String>`의 인스턴스이고, `String`이 `TitledLoggable`을 준수하기 때문에 `TitledLoggable`을 준수한다. `log()` 메소드가 `oneAndTwo`에서 직접 호출될 때, 타이틀 문자열을 포함하는 특화된 버전이 사용된다.

  ```
  let oneAndTwo = Pair(first: "one", second: "two")
  oneAndTwo.log()
  // Prints "Pair of 'String': (one, two)"
  ```

  그러나, `oneAndTwo`가 제네릭 컨텍스트에서 사용되거나 `Loggable` 프로토콜의 인스턴스로서 사용될 때, 특화된 버전은 사용되지 않는다. Swift는 `Pair`가 `Loggable`을 준수하기 위해 필요로 하는 최소한의 요구조건만을 찾아 호출해야 하는 `log()`의 구현을 고른다. 이러한 이유로, `Loggable` 프로토콜이 제공하는 기본 구현이 대신 사용된다.

  ```
  func doSomething<T: Loggable>(with x: T) {
      x.log()
  }
  doSomething(with: oneAndTwo)
  // Prints "(one, two)"
  ```

  `log()`가 `doSomething(_:)`에 전달된 인스턴스에서 호출되면, 로깅된 문자열에서 커스텀된 타이틀은 생략된다.

  ### 프로토콜 준수는 중복되지 않아야 한다

  구체 타입은 특정 프로토콜을 오직 한 번만 준수할 수 있다. Swift는 중복된 프로토콜 준수를 에러로 표시한다. 두 가지 종류의 상황에서 이러한 에러를 마주치게 될 것이다. 첫 번째 상황은 동일한 프로토콜을 여러 번 명시적으로 준수하지만, 다른 요구조건을 가질 때다. 두 번째 상황은 동일한 프로토콜을 여러 번 명시적으로 상속받을 때다.

  **명시적인 중복 해결**

  구체 타입에 대한 여러 개의 익스텐션은 같은 프로토콜에 대한 준수를 추가할 수 없으며, 심지어 해당 익스텐션의 요구조건들이 상호 배타적이라도 그렇다. 이 제한은 아래의 예시에서 입증된다. 두 개의 익스텐션 선언은 `Serializable` 프로토콜에 대한 조건적 준수를 추가하려 하고 있으며, 하나는 `Int` 요소를 가진 배열에 대한 것이고, 다른 하나는 `String` 요소를 가진 배열에 대한 것이다.

  ```
  protocol Serializable {
      func serialize() -> Any
  }
  
  extension Array: Serializable where Element == Int {
      func serialize() -> Any {
          // implementation
      }
  }
  extension Array: Serializable where Element == String {
      func serialize() -> Any {
          // implementation
      }
  }
  // Error: redundant conformance of 'Array<Element>' to protocol 'Serializable'
  ```

  여러 개의 구체 타입에 따라 조건적 준수를 추가해야 할 필요가 있다면, 각 타입이 준수할 수 있는 새로운 프로토콜을 만들고, 조건적 준수를 선언할 때 해당 프로토콜을 요구조건으로 사용한다.

  ```
  protocol SerializableInArray { }
  extension Int: SerializableInArray { }
  extension String: SerializableInArray { }
  
  extension Array: Serializable where Element: SerializableInArray {
      func serialize() -> Any {
          // implementation
      }
  }
  ```

  **암시적인 중복 해결**

  구체 타입이 조건적으로 프로토콜을 준수할 때, 해당 타입은 암시적으로 동일한 요구조건을 가진 부모 프로토콜들도 준수한다.

  하나의 부모로부터 상속받은 두 개의 프로토콜을 조건적으로 준수하는 타입을 필요로 한다면, 부모 프로토콜에 준수를 명시적으로 선언한다. 이는 다른 요구조건을 가진 부모 프로토콜을 두 번 암시적으로 준수하는 것을 피하게 한다.

  다음의 예시는 `TitledLoggable`과 새로운 `MarkedLoggable` 프로토콜 모두에 대한 조건적 준수를 선언할 때, 충돌을 피하기 위해 `Loggable`에 대한 `Array`의 조건적 준수를 명시적으로 선언한다.

  ```
  protocol MarkedLoggable: Loggable {
      func markAndLog()
  }
  
  extension MarkedLoggable {
      func markAndLog() {
          print("----------")
          log()
      }
  }
  
  extension Array: Loggable where Element: Loggable { }
  extension Array: TitledLoggable where Element: TitledLoggable {
      static var logTitle: String {
          return "Array of '\(Element.logTitle)'"
      }
  }
  extension Array: MarkedLoggable where Element: MarkedLoggable { }
  ```

  명시적으로 `Loggable`에 대한 조건적 준수를 선언하는 익스텐션 없이는, 다른 `Array` 익스텐션은 암시적으로 이러한 선언을 만들 것이고, 에러를 낼 것이다.

  ```
  extension Array: Loggable where Element: TitledLoggable { }
  extension Array: Loggable where Element: MarkedLoggable { }
  // Error: redundant conformance of 'Array<Element>' to protocol 'Loggable'
  ```

  ## 서브스크립트 선언

  *서버스크립트* 선언은 특정 타입의 객체에 대한 서브스크립트 지원을 추가할 수 있게 해주며, 컬렉션, 리스트, 또는 시퀀스에 있는 요소에 접근하기 위한 편리한 신택스를 제공하기 위해 전형적으로 사용된다. 서브스크립트 선언은 `subscript` 키워드를 사용하여 선언되고 다음의 형식을 갖는다.

  ```
  subscript ({parameters}) -> {return type} {
      get {
          {statements}
      }
      set({setter name}) {
          {statements}
      }
  }
  ```

  서브스크립트 선언은 클래스, 구조체, 열거형, 익스텐션, 또는 프로토콜 선언의 컨텍스트에서만 나타날 수 있다.

  *parameters*는 서브스크립트 표현식에서 대응하는 타입의 요소에 접근하기 위해 사용되는 하나 이상의 인덱스들을 지정한다 (예를 들어, `object[i]` 표현식에서의 `i`). 요소에 접근하기 위해 사용되는 이러한 인덱스들은 어떠한 타입이든 될 수 있으며, 각각의 매개변수는 각 인덱스의 타입을 지정하기 위해 타입 어노테이션을 반드시 포함해야 한다. *return type*은 접근되려고 하는 요소의 타입을 지정한다.

  연산 프로퍼티처럼, 서브스크립트 선언은 접근되는 요소의 값을 읽고 쓰는 것을 지원한다. 접근자는 값을 읽기 위해 사용되고, 설정자는 값을 쓰기 위해 사용된다. 설정자 절은 선택적이며, 오직 접근자만을 필요로 할 때, 두 개의 절 모두를 생략하고 단순히 요청된 값을 직접 반환하면 된다. 즉, 설정자 절을 제공한다면, 반드시 접근자 절도 제공해야 한다.

  *setter name*과 이를 감싼 소괄호는 선택적이다. 설정자 이름을 제공한다면, 설정자에 대해서 매개변수의 이름으로 사용된다. 설정자 이름을 제공하지 않는다면, 설정자에 대한 기본 매개변수 이름은 `value`다. 설정자에 대한 매개변수의 타입은 *return type*과 같다.

  *parameters*나 *return type*이 오버로딩하려는 것과 서로 다르다면, 서브스크립트 선언이 선언된 타입에서 오버로딩 할 수 있다. 또한 슈퍼클래스로부터 상속받은 서브스크립트 선언을 재정의할 수 있다. 이렇게 할 때, 반드시 `override` 선언 지정자와 함께 재정의된 서브스크립트 선언을 표시해야 한다.

  서브스크립트 매개변수는 함수 매개변수와 같은 규칙을 따르나, 두 가지 예외가 있다. 기본적으로, 서브스크립트에서 사용되는 매개변수들은 함수, 메소드, 이니셜라이저와 다르게 인자 레이블을 갖지 않는다. 그러나, 함수, 메소드, 이니셜라이저가 사용하는 것과 같은 신택스를 사용하여 명시적인 인자 레이블을 제공할 수 있다. 게다가, 서브스크립트는 인-아웃 매개변수를 가질 수 없다. 서브스크립트 매개변수는 기본값을 가질 수 있다.

  프로토콜 선언의 컨텍스트에서 서브스크립트를 선언할 수도 있다.

  ### 타입 서브스크립트 선언

  타입의 인스턴스가 아닌, 타입에 의해 노출되는 서브스크립트를 선언하기 위해, `static` 선언 지정자로 서브스크립트 선언을 표시한다. 클래스는 서브클래스가 슈퍼클래스의 구현을 재정의하는 것을 허용하기 위해 `class` 선언 지정자를 타입 연산 프로퍼티에 대산 표시할 수 있다. 클래스 선언에서, `static` 키워드는 `class`와 `final` 선언 지정자를 모두 사용하여 선언을 표시한 것과 같은 효과를 갖는다.

  ## 연산자 선언

  *연산자 선언*은 프로그램에 새로운 중위, 전위, 또는 후위 연산자를 도입하고, `operator` 키워드를 사용하여 선언된다.

  세 가지 다른 연산자, 중위, 전위, 후위 연산자를 선언할 수 있다. 연산자의 *fixity*는 연산자와 그것의 연산 대상과의 상대적인 위치를 지정한다.

  연산자 선언에는 세 가지 기본 형식이 있다. 하나는 각각의 fixity에 대해서다. 연산자의 fixity는 연산자 선언을 `infix`, `prefix`, 또는 `postfix` 선언 지정자를 `operator` 키워드 앞에 표시하여 지정된다. 각각의 형식에서, 연산자의 이름은 오직 Operators에 정의된 연산자 문자만을 포함할 수 있다.

  다음의 형식은 새로운 중위 연산자를 선언한다.

  ```
  infix operator {operator name}: {precedence group}
  ```

  *infix operator*는 두 개의 피연산자 사이에 작성되는 이항 연산자이며, `1 + 2` 표현식에 있는 잘 알려진 덧셈 연산자 (`+`) 같은 것이 있다.

  중위 연산자는 우선순위 그룹을 선택적으로 지정할 수 있다. 연산자에서 우선순위 그룹을 생략한다면, Swift는 기본 우선순위 그룹, `DefaultPrecedence`를 사용하며, 이는 `TernaryPrecedence`보다 바로 하나 높은 우선순위를 지정한다.

  다음의 형식은 새로운 전위 연산자를 선언한다.

  ```
  prefix operator {operator name}
  ```

  *prefix operator*는 그것의 피연산자 바로 앞에 작성되는 단항 연산자며, `!a` 표현식에 있는 논리 NOT 연산자 (`!`) 와 같은 것이 있다.

  전위 연산자 선언은 우선순위 수준을 지정하지 않는다. 전위 연산자는 비연관적이다.

  다음의 형식은 새로운 후위 연산자를 선언한다.

  ```
  postfix operator {operator name}
  ```

  *postfix operator*는 그것의 피연산자 바로 뒤에 작성되는 단항 연산자며, `a!` 표현식에 있는 강제 언래핑 연산자 (`!`) 와 같은 것이 있다.

  전위 연산자처럼, 후위 연산자 선언은 우선순위 수준을 명시하지 않는다. 후위 연산자는 비연관적이다.

  새로운 연산자를 선언한 후, 연산자 이름과 같은 이름을 갖는 정적 메소드를 선언하여 그것을 구현한다. 해당 정적 메소드는 타입의 멤버 중 하나이며, 연산자가 해당 메소드의 값들을 인자로 취한다-예를 들어, `Double`과 `Int`를 곱하는 연산자는 `Double` 구조체나 `Int` 구조체에서 정적 메소드로 구현된다. 전위 또는 후위 연산자를 구현한다면, 반드시 해당 메소드 선언을 대응하는 `prefix` 또는 `postfix` 선언 지정자를 사용하여 표시해야 한다.

  ## 우선순위 그룹 선언

  *우선순위 그룹 선언*은 프로그램에 새로운 중위 연산자 우선순위 그룹을 도입한다. 연산자의 우선순위는 그룹 지정하는 소괄호가 없을 때 연산자가 피연산자들에 얼마나 단단히 묶여지는지를 지정한다.

  우선순위 그룹 선언은 다음의 형식을 갖는다.

  ```
  precedencegroup {precedence group name} {
      higherThan: {lower group names}
      lowerThan: {higher group names}
      associativity: {associativity}
      assignment: {assignment}
  }
  ```

  *lower group names*와 *higher group names* 리스트는 존재하는 우선순위 그룹과 새로운 우선순위 그룹의 관계를 지정한다. `lowerThan` 우선순위 그룹 애트리뷰트는 현재 모듈의 바깥에 선언된 우선순위 그룹을 참조하기 위해서만 사용될 것이다. `2 + 3 * 5` 표현식처럼, 두 개의 연산자가 그것들의 피연산자들에 대해 서로 경쟁할 때, 더 높은 관계 우선순위를 갖는 연산자가 그 피연산자들에게 더 단단히 묶인다.

  - 알아두기

    *lower group names*와 *higher group names*를 사용하여 서로 관계된 우선순위 그룹은 하나의 관계 계층에 반드시 알맞아야 하지만, 선형 계층을 형성할 필요는 없다. 이는 우선순위 그룹이 정의되지 않은 관계 우선순위를 가질 수 있다는 것을 의미한다. 그러한 우선순위 그룹을 가진 연산자들은 그룹 지정하는 소괄호 없이는 서로의 다음에 사용될 수 없다.

  Swift는 표준 라이브러리가 제공하는 연산자들을 따라가기 위해 매우 많은 우선순위 그룹을 정의한다. 예를 들어, 덧셈 (`+`) 과 뺄셈 (`-`) 연산자는 `AdditionalPrecedence` 그룹에 속해 있고, 곱하기 (`*`) 와 나누기 (`/`) 연산자는 `MultiplicationPrecedence` 그룹에 속해 있다.

  연산자의 *associativity*는 같은 우선순위 수준을 가진 연산자의 시퀀스가 그룹 지정하는 소괄호 없이 어떻게 함께 그룹 지정되는지를 지정한다. 컨텍스트에 맞는 키워드 `left`, `right`, 또는 `none` 중 하나를 작성하여 연산자의 연관성을 지정한다-연관성을 생략하면, 기본은 `none`이다. 좌측-연관성 그룹을 가진 연산자는 왼쪽에서 오른쪽이다. 예를 들어, 뺄셈 연산자 (`-`) 는 좌측-연관성을 가지므로, `4 - 5 - 6` 표현식은 `(4 - 5) - 6`으로 그룹 지정되어 `-7`로 평가된다. 우측-연관성 그룹을 가진 연산자는 오른쪽에서 왼쪽이며, `none` 연관성으로 지정된 연산자는 전혀 연관되지 않는다. 같은 우선순위 수준에서 연관성이 없는 연산자는 서로와 인접하여 나타날 수 없다. 예를 들어, `<` 연산자는 `none` 연관성을 가지며, `1 < 2 < 3`은 유효한 표현식이 아니라는 것을 의미한다.

  우선순위 그룹의 *assignment*는 옵셔널 체이닝을 포함하는 오퍼레이션에서 사용될 때 연산자의 우선순위를 지정한다. `true`로 설정되면, 대응하는 우선순위 그룹에 있는 연산자는 옵셔널 체이닝을 하는 동안 표준 라이브러리의 할당 연산자와 같은 그룹 지정 규칙을 사용한다. 그렇지 않으면, `false`로 설정되거나 생략되면, 우선순위 그룹에 있는 연산자들은 할당을 수행하지 않는 연산자와 동일한 옵셔널 체이닝 규칙을 따른다.

  ## 선언 지정자

  *선언 지정자*는 키워드이거나, 선언의 동작이나 의미를 수정하는 컨텍스트에 맞는 키워드다. 선언의 어떠한 애트리뷰트들과 해당 선언을 도입하는 키워드 사이에 적절한 키워드나 컨텍스트에 맞는 키워드를 작성하여 선언 지정자를 지정한다.

  `class`

  클래스의 멤버에 이 지정자를 적용하여 해당 멤버가 클래스의 인스턴스의 멤버가 아니라, 클래스 그 자체의 맴버라는 것을 가리킨다. 이 지정자를 가지고 `final` 지정자를 가지지 않는 슈퍼클래스의 멤버는 서브클래스에 의해 재정의될 수 있다.

  `dynamic`

  Objective-C에서 표현될 수 있는 클래스의 멤버에 이 지정자를 적용한다. 멤버 선언을 `dynamic` 지정자로 표시하면, 해당 멤버에 대한 접근은 항상 Objective-C 런타임을 사용하여 다이나믹 디스패치 된다. 해당 멤버에 대한 접근은 컴파일러에 의해 절대 인라이닝되거나 탈가상화되지 않는다.

  `dynamic` 지정자로 표시된 선언은 Objective-C 런타임을 사용하여 디스패치되기 때문에, 반드시 `objc` 애트리뷰트와 함께 표시되어야 한다.

  `final`

  클래스 또는 클래스의 프로퍼티, 메소드, 또는 서브스크립트 멤버에 이 지정자를 적용한다. 어떤 클래스는 서브클래싱되지 않는다는 것을 가리키기 위해 이를 클래스에 적용한다. 클래스의 어떤 프로퍼티, 메소드, 서브스크립트는 어떠한 서브클래스에 의해서도 재정의되지 않는다는 것을 가리키기 위해 이를 각각에 적용한다.

  `lazy`

  클래스나 구조체의 저장 변수 프로퍼티에 이 지정자를 적용하여 해당 프로퍼티의 초기값이 최초로 접근될 때 최대 한 번 계산되고 저장되게 한다.

  `optional`

  프로토콜의 프로퍼티, 메소드, 또는 서브스크립트 멤버에 이 지정자를 적용하여 이를 준수하는 타입이 그러한 멤버를 필수적으로 구현할 필요가 없다는 것을 가리킨다.

  `objc` 애트리뷰트로 표시된 프로토콜에 대해서만 `optional` 지정자를 적용할 수 있다. 결과적으로, 오직 클래스 타입만이 선택적 멤버 요구조건을 포함하는 프로토콜을 채택하고 준수할 수 있다.

  `required`

  클래스의 지정 또는 편의 이니셜라이저에 이 지정자를 적용하여 모든 서브클래스가 해당 이니셜라이저를 반드시 구현해야 한다는 것을 가리킨다. 해당 이니셜라이저의 서브클래스에서의 구현도 반드시 `required` 지정자로 표시되어야 한다.

  `static`

  구조체, 클래스, 열거형, 또는 프로토콜의 멤버에 이 지정자를 적용하여 해당 멤버는 해당 타입의 인스턴스의 멤버가 아닌, 해당 타입의 멤버라는 것을 가리킨다. 클래스 선언 스코프에서, 멤버 선언에 `static` 지정자를 작성하는 것은 멤버 선언에 `class`와 `final` 지정자를 작성하는 것과 같은 효과를 갖는다. 그러나, 클래스의 상수 타입 프로퍼티는 예외를 가진다: 그러한 선언에 `class`와 `final`을 작성할 수 없기 때문에 `static`은 정상적이고, 클래스가 아닌 의미를 갖는다.

  `unowned`

  저장 변수, 상수, 또는 저장 프로퍼티에 이 지정자를 적용하여 해당 변수나 프로퍼티는 값으로 저장하고 있는 객체에 대해 미소유 참조를 갖고 있다는 것을 가리킨다. 해당 객체가 할당 해제된 후에 변수나 프로퍼티에 접근하려고 한다면, 런타임 에러가 발생한다. 약한 참조처럼, 해당 프로퍼티나 값의 타입은 반드시 클래스 타입이어야 한다; 약한 참조와는 다르게, 해당 타입은 옵셔널이 아니다.

  `unowned(safe)`

  `unowned`의 명시적인 스펠링.

  `unowned(unsafe)`

  저장 변수, 상수, 또는 저장 프로퍼티에 이 지정자를 적용하여 해당 변수나 프로퍼티는 값으로 저장하는 객체에 대해 미소유 참조를 갖고 있다는 것을 가리킨다. 해당 객체가 할당 해제된 후에 해당 변수나 프로퍼티에 접근하려 한다면, 해당 객체가 사용한 위치에 있는 메모리에 접근할 것이며, 이는 메모리에 안전하지 않은 동작이다. 약한 참조처럼, 해당 프로퍼티나 값의 타입은 반드시 클래스 타입이어야 한다; 약한 참조와는 다르게, 해당 타입은 옵셔널이 아니다.

  `weak`

  저장 변수나 저장 변수 프로퍼티에 이 지정자를 적용하여 해당 변수나 프로퍼티가 값으로 저장하고 있는 객체에 대해 약한 참조를 가지고 있다는 것을 가리킨다. 해당 변수나 프로퍼티의 타입은 반드시 옵셔널 클래스 타입이어야 한다. 객체가 할당 해제된 후에 해당 변수나 프로퍼티에 접근한다면, 그 값은 `nil`이다.

  ### 접근 제어 수준

  Swift는 다섯 가지 수준의 접근 제어: open, public, internal, file private, private을 제공한다. 선언의 접근 수준을 지정하기 위해 아래의 접근 수준 지정자들 중 하나를 선언에 표시할 수 있다.

  `open`

  선언에 이 지정자를 적용하여 해당 선언이 선언과 같은 모듈에서 코드 수준에서 접근되고 서브클래싱될 수 있다는 것을 가리킨다. `open` 접근 수준 지정자로 표시된 선언은 해당 선언을 포함하는 모듈을 임포트한 모듈에서도 코드 수준에서 접근되고 서브클래싱될 수 있다.

  `public`

  선언에 이 지정자를 적용하여 해당 선언이 선언과 같은 모듈에서 코드 수준에서 접근되고 서브클래싱될 수 있다는 것을 가리킨다. `public` 접근 수준 지정자로 표시된 선언은 해당 선언을 포함하는 모듈을 임포트한 모듈에서도 코드 수준에서 접근될 수 있으나, 서브클래싱될 수는 없다.

  `internal`

  선언에 이 지정자를 적용하여 해당 선언이 선언과 같은 모듈에서만 코드 수준으로 접근되고 서브클래싱될 수 있다는 것을 가리킨다. 기본적으로, 대부분의 선언은 암시적으로 `internal` 접근 수준 지정자를 사용하여 표시된다.

  `fileprivate`

  선언에 이 지정자를 적용하여 해당 선언이 선언과 같은 소스 파일에서만 코드 수준으로 접근될 수 있다는 것을 가리킨다.

  `private`

  선언에 이 지정자를 적용하여 해당 선언이 선언을 감싼 스코프 내에서만 코드 수준에서 접근될 수 있다는 것을 가리킨다.

  접근 수준의 목적을 위해, 동일한 파일에서의 동일한 타입에 대한 익스텐션은 접근 수준 스코프를 공유한다. 그것들이 확장하는 타입이 또한 같은 파일에 있다면, 해당 타입의 접근 수준 스코프를 공유한다. 타입의 선언에서 선언된 private 멤버들은 익스텐션에서 접근될 수 있고, 한 익스텐션에서 선언된 private 멤버는 다른 익스텐션과 타입의 선언에서 접근될 수 있다.

  위의 각각의 접근 수준 지정자는 선택적으로 하나의 인자를 받을 수 있으며, 소괄호로 둘러싸여진 `set` 키워드로 구성된다 (예를 들어, `private(set)`). 변수 또는 서브스크립트 자체의 접근 수준보다 작거나 같은 변수 또는 서브스크립트의 설정자에 대한 접근 수준을 지정하길 원할 때 이러한 형식의 접근 수준 지정자를 사용한다.

이 형식에서, 각 케이스 블록은 `case` 키워드와 그 뒤에 콤마로 구분된 하나 이상의 열거형 케이스가 붙는 것으로 구성된다. 첫 번째 형식의 케이스와는 다르게, 각 케이스는 *원시 값*이라고 불리는, 동일한 기본 타입의 기반 값을 갖는다. 이러한 값들의 타입은 *raw-value type*에 지정되며, 반드시 정수, 부동소수점, 문자열, 또는 단일 문자를 나타내야 한다. 특히, *raw-value type*은 반드시 `Equatable` 프로토콜과 다음의 프로토콜 중 하나를 준수해야 한다.

```
enum {enumeration name}: {raw-value type}, {adopted protocols} {
    case {enumeration case 1} = {raw value 1}
    case {enumeration case 2} = {raw value 2}
}
```

다음의 형식은 동일한 기본 타입의 열거형 케이스를 포함하는 열거형 타입을 선언한다.

### 원시 값 타입의 케이스를 갖는 열거형

`indirect` 지정자로 표시된 열거형은 연관 값을 갖는 케이스와 연관 값을 갖지 않는 케이스와의 혼합을 포함할 수 있다. 즉, 또한 `indirect` 지정자와 함께 표시된 케이스를 포함할 수 없다.

열거형의 연관 값을 갖는 모든 케이스에 대한 간접을 활성화하기 위해, 얼거형 전체를 `indirect` 지정자와 함께 표시할 수 있다-이는 열거형이 `indirect` 지정자와 함께 표시될 필요가 있는 많은 케이스를 포함할 때 편리하다.

```
enum Tree<T> {
    case empty
    indirect case node(value: T, left: Tree, right: Tree)
}
```

특정 열거형 케이스에 대한 간접을 활성화하기 위해, `indirect` 선언 지정자와 함께 표시한다. 간접 케이스는 반드시 연관 값을 가져야 한다.

열거형은 재귀적 구조를 가질 수 있다. 즉, 열거형 타입 그 자체의 인스턴스를 연관 값으로 갖는 케이스를 가질 수 있다. 그러나, 열거형 타입의 인스턴스는 값 시맨틱스를 가지며, 이는 그것들이 메모리에 고정된 레이아웃을 가지고 있다는 것을 의미한다. 재귀를 지원하기 위해 컴파일러는 반드시 간접 레이어를 삽입해야 한다.

**간접 열거형**

```
enum Number {
    case integer(Int)
    case real(Double)
}
let f = Number.integer
// f is a function of type (Int) -> Number

// Apply f to create an array of Number instances with integer values
let evenInts: [Number] = [0, 2, 4, 6].map(f)
```

연관 값을 저장하는 열거형 케이스는 열거형의 인스턴스를 생성할 때 지정된 연관 값들과 함께 함수로서 사용될 수 있다. 그리고 함수처럼, 열거형 케이스에 대한 참조를 얻고 코드에서 이를 나중에 적용할 수 있다.

이 형식에서, 각각의 케이스 블록은 `case` 키워드 다음에 콤마로 구분된 하나 이상의 열거형 케이스가 따라오는 것으로 구성된다. 각 케이스의 이름은 반드시 유일해야 한다. 각 케이스는 또한 주어진 타입의 값을 저장한다고 지정할 수 있다. 이러한 타입들은 *associated value types* 튜플에 지정되며, 케이스 이름 바로 다음에 나타난다.

이 형식에서 선언된 열거형은 때때로 다른 프로그래밍 언어에서는 *차별적 공용체discriminated unions*라고 불린다.

```
enum {enumeration name}: {adopted protocols} {
    case {enumeration case 1}
    case {enumeration case 2}({associated value types})
}
```

다음의 형식은 어떠한 타입의 열거형 케이스를 포함하는 열거형 타입을 선언한다.

### 어떠한 타입의 케이스를 가진 열거형

익스텐션 선언을 통해 열거형 타입의 동작을 확장할 수 있다.

구조체와 비슷하지만 클래스와는 다르게, 열거형은 값 타입이다; 열거형의 인스턴스는 변수나 상수에 할당될 때, 또는 함수 호출의 인자로 넘겨질 때 복사된다.

클래스나 구조체와는 다르게, 열거형 타입은 암시적으로 제공되는 기본 이니셜라이저를 갖지 않는다; 모든 이니셜라이저는 반드시 명시적으로 선언되어야 한다. 이니셜라이저는 열거형에 있는 다른 이니셜라이저에 위임할 수 있으나, 초기화 프로세스는 오직 이니셜라이저가 열거형 케이스 중 하나를 `self`에 할당한 후에 완료된다.

열거형 타입은 여러 개의 프로토콜을 채택할 수 있으나, 클래스, 구조체, 또는 다른 열거형으로부터 상속받을 수 없다.

열거형 선언은 두 개의 기본 형식을 갖고 `enum` 키워드를 사용하여 선언된다. 열거형의 구현부는 0개 이상의 값-*열거형 케이스*라고 불림-을 포함하는 형식이나, 연산 프로퍼티, 인스턴스 메소드, 타입 메소드, 이니셜라이저, 타입 별칭, 심지어 다른 열거형, 구조체, 클래스 선언을 포함하는 여러 선언을 포함하는 형식을 사용하여 선언된다. 열거형 선언은 디이니셜라이저나 프로토콜 선언을 포함할 수 없다.

*열거형 선언*은 프로그램에 이름 있는 열거형 타입을 도입한다.

## 열거형 선언

반환하지 않는 메소드를 재정의할 수 있으나, 새로운 메소드는 그 반환형과 반환하지 않는 동작을 반드시 보존해야 한다.

반환하지 않는 함수나 메소드는 `guard` 구문의 `else` 절을 마치기 위해 호출될 수 있다.

Swift는 `Never` 타입을 정의하며, 이는 함수나 메소드가 그것의 호출자에게 절대 반환하지 않는다는 것을 가리킨다. `Never` 반환형을 가진 함수와 메소드는 반환하지 않는 함수*nonreturning*이라고 불린다. 반환하지 않는 함수와 메소드는 회복할 수 없는 에러나 무기한 지속되는 작업 시퀀스를 시작하는 원인이 된다. 이는 해당 호출 직후에 실행되려 했던 코드는 실행되지 않는다는 것을 의미한다. 에러를 던지는 함수와 에러를 다시 던지는 함수는 심지어 이것이 반환하지 않는 함수일지라도, 프로그램 제어를 적절한 `catch` 블록에 전달할 수 있다.

### 절대 반환하지 않는 함수

에러를 던지는 메소드는 에러를 다시 던지는 메소드를 재정의할 수 없으며, 에러를 던지는 메소드는 에러를 다시 던지는 메소드에 대한 프로토콜 요구 조건을 충족할 수 없다. 즉, 에러를 다시 던지는 메소드는 에러를 던지는 메소드를 재정의할 수 있으며, 에러를 다시 던지는 메소드는 에러를 던지는 메소드에 대한 프로토콜 요구 조건을 충족시킬 수 있다.

```
func alwaysThrows() throws {
    throw SomeError.error
}
func someFunction(callback: () throws -> Void) rethrows {
    do {
        try callback()
        try alwaysThrows()  // Invalid, alwaysThrows() isn't a throwing parameter
    } catch {
        throw AnotherError.error
    }
}
```

에러를 다시 던지는 함수나 메소드는 오직 `catch` 절 안에서만 `throw` 구문을 포함할 수 있다. 이는 `do-catch` 구문 안에서 에러를 던지는 함수를 호출하게 하고, 다른 에러를 던져서 `catch` 절에 있는 에러를 처리하게 한다. 게다가, `catch` 절은 반드시 에러를 다시 던지는 함수의 에러를 던지는 매개변수 중 하나가 던지는 에러에 대해서만 처리해야 한다. 예를 들어, 다음의 코드는 `catch` 절이 `alwaysThrows()`가 던지는 에러를 처리하려 하기 때문에 유효하지 않다.

```
func someFunction(callback: () throws -> Void) rethrows {
    try callback()
}
```

함수나 메소드는 `rethrows` 키워드와 함께 선언되어, 이것이 오직 함수 매개변수 중 하나가 에러를 던질 때만 에러를 던질 수 있다는 것을 나타낼 수 있다. 이러한 함수나 메소드들은 *에러를 다시 던지는 함수* 또는 *에러를 다시 던지는 메소드*로 알려져 있다. 에러를 다시 던지는 함수와 메소드는 반드시 적어도 하나의 에러를 던지는 함수 매개변수를 가지고 있어야 한다.

### 에러를 다시 던지는 함수 및 메소드

에러를 던지는 메소드는 에러를 던지지 않는 메소드를 재정의할 수 없으며, 에러를 던지는 메소드는 에러를 던지지 않는 메소드에 대한 프로토콜 요구 조건을 충족시킬 수 없다. 즉, 에러를 던지지 않는 메소드는 에러를 던지는 메소드를 재정의할 수 있으며, 에러를 던지지 않는 메소드는 에러를 던지는 메소드에 대한 프로토콜 요구 조건을 충족시킬 수 있다.

함수가 에러를 던질 수 있는지 여부에 따라서만 함수를 오버로딩할 수 없다. 즉, 함수 *parameter*가 에러를 던질 수 있는지에 따라서 함수를 오버로딩할 수 잇다.

`throws` 키워드는 함수 타입의 일부분이며, 에러를 던지지 않는 함수는 에러를 던지는 함수의 서브타입이다. 결과적으로, 같은 자리에서 에러를 던지지 않는 함수를 에러를 던지는 함수로 사용할 수 있다.

에러를 던지는 함수나 메소드에 대한 호출은 반드시 `try` 또는 `try!` 표현식으로 감싸져야 (즉, `try` 또는 `try!` 연산자의 스코프에 있어야) 한다.

```
func {function name}({parameters}) throws -> {return type} {
    {statements}
}
```

에러를 던질 수 있는 함수와 메소드는 반드시 `throws` 키워드와 함께 표시되어야 한다. 이러한 함수와 메소드들은 *에러를 던지는 함수*와 *에러를 던지는 메소드*로 알려져 있다. 다음의 형식을 갖는다.

### 에러를 던지는 함수 및 메소드

`subscript(dynamicMemberLookup:)` 서브스크립트는 멤버 룩업에 대한 신택틱 슈거를 활성화한다.

```
let someFunction1: (Int, Int) -> Void = callable(_:scale:)  // Error
let someFunction2: (Int, Int) -> Void = callable.callAsFunction(_:scale:)
```

함수로서의-호출 메소드, 또는 `dynamicCallable` 애트리뷰트로부터의 메소드를 정의하는 것은 함수 호출 표현식 이상의 어떠한 컨텍스트에서든 타입의 인스턴스를 함수인 것처럼 사용할 수 있게 해주지 않는다.

함수로서의-호출 메소드와 `dynamicCallable` 애트리뷰트로부터의 메소드는 타입 시스템 안에서 얼마나 많은 정보를 인코딩하는지와, 런타임에서 얼마나 많은 동적 동작이 가능한지의 사이에 트레이드오프를 만든다. 함수로서의-호출 메소드를 선언할 때, 여러 개의 인자, 그리고 각 인자의 타입과 레이블을 지정한다. `dynamicCallable` 애트리뷰트의 메소드는 오직 인자의 배열을 붙들기 위해 사용되는 타입만을 지정한다.

```
struct CallableStruct {
    var value: Int
    func callAsFunction(_ number: Int, scale: Int) {
        print(scale * (number + value))
    }
}
let callable = CallableStruct(value: 100)
callable(4, scale: 2)
callable.callAsFunction(4, scale: 2)
// Both function calls print 208.
```

다음의 함수 호출들은 동일하다.

함수로서의-호출 메소드의 이름은 `callAsFunction()`, 또는 `callAsFunction`으로 시작 (그리고 레이블링된 인자나 레이블링되지 않은 인자를 추가) 하는 또다른 이름이다. 예를 들어, `callAsFunction(_:_:)`과 `callAsFunction(something:)`은 함수로서의-호출 메소드의 이름으로 또한 유효하다.

클래스, 구조체, 또는 열거형 타입은 `dynamicallyCall(withArguments:)` 메소드나 `dynamicallyCall(withKeywordArguments:)` 메소드, 또는 함수로서의-호출*call-as-function* 메소드를 정의하여 함수 호출 신택스를 지원할 수 있다. 어떠한 타입에 함수로서의-호출 메소드와 `dynamicCallable` 애트리뷰트를 사용하는 메소드들 중 하나 모두가 정의되었다면, 컴파일러는 두 가지 방법 중 하나를 사용할 수 있는 상황에서 함수로서의-호출 메소드를 선호한다.

특별한 이름을 갖는 몇 가지 메소드들은 함수 호출 신택스에 대한 신택틱 슈거를 활성화한다. 어떠한 타입이 이러한 메소드들 중 하나를 정의한다면, 타입의 인스턴스는 함수 호출 신택스에서 사용될 수 있다. 해당 함수 호출은 해당 인스턴스의 특별하게 이름 지어진 메소드들 중 하나를 호출하는 것으로 이해된다.

### 특별한 이름을 가진 메소드

타입의 인스턴스 대신 타입과 관련된 메소드는 열거형과 구조체에 대해서는 반드시 `static` 선언 지정자와 함께 표시되어야 하고, 클래스에 대해서는 `static`이나 `class` 선언 지정자와 함께 표시되어야 한다. `class` 선언 지정자로 표시된 클래스의 타입 메소드는 서브클래스 구현에서 재정의될 수 있다; `class final` 또는 `static`으로 표시된 클래스의 타입 메소드는 재정의될 수 없다.

슈퍼클래스의 메소드를 재정의하는 메소드는 반드시 `override` 선언 지정자와 함께 표시되어야 한다. `override` 지정자를 사용하지 않고 메소드를 재정의하거나 슈퍼클래스 메소드를 재정의하지 않는 메소드에 대해 `override` 지정자를 사용하는 것은 컴파일 에러를 발생시킨다.

`self`를 수정하는 열거형이나 구조체에 대한 메소드는 반드시 `mutating` 선언 지정자와 함께 표시되어야 한다.

### 특별한 종류의 메소드

```
func f(x: Int = 42) -> Int { return x }
f()       // Valid, uses default value
f(x: 7)   // Valid, uses the value provided
f(7)      // Invalid, missing argument label
```

타입 뒤에 동등 기호 (`=`) 와 표현식을 갖는 매개변수는 주어진 표현식에 대한 기본값을 갖는 것으로 이해된다. 주어진 표현식은 함수가 호출될 때 평가된다. 해당 매개변수가 함수 호출 시에 생략된다면, 대신 기본값이 사용된다.

기반 타입 이름 다음에 세 개의 점 (`...`) 이 바로 뒤따라오는 매개변수는 가변 매개변수로 이해된다. 함수는 최대 한 개의 가변 매개변수를 가질 수 있다. 가변 매개변수는 해당 기반 타입 이름의 요소를 포함한 배열로 취급된다. 예를 들어, 가변 매개변수 `Int...`는 `[Int]`로 취급된다.

언더스코어 (`_`) 매개변수는 명시적으로 무시되며 함수의 구현부 안에서 접근될 수 없다.

```
_ : {parameter type}
{parameter name}: {parameter type}...
{parameter name}: {parameter type} = {default argument value}
```

매개변수는 다음의 형식을 사용하여 무시될 수 있고, 여러 개의 변수 값을 취할 수 있고, 기본값을 제공할 수 있다.

### 특별한 종류의 매개변수

```
func multithreadedFunction(queue: DispatchQueue, x: inout Int) {
    // Make a local copy and manually copy it back.
    var localX = x
    defer { x = localX }

    // Operate on localX asynchronously, then wait before returning.
    queue.async { someMutatingOperation(&localX) }
    queue.sync {}
}
```

인-아웃 매개변수를 획득하고 변경할 필요가 있다면, 모든 변경이 함수 반환 이전에 끝마쳐지는 것을 보장하는 멀티쓰레드 코드처럼, 명시적인 지역 복사를 사용하라.

```
func someFunction(a: inout Int) -> () -> Int {
    return { [a] in return a + 1 }
}
```

인-아웃 매개변수를 획득한 클로저 또는 중첩 함수는 반드시 탈출 처리되지 않은 것이어야 한다. 인-아웃 매개변수를 변경하지 않거나 다른 코드가 만든 변화를 관찰하지 않고 획득할 필요가 있다면, 매개변수를 명시적으로 불변하게 획득하기 위해 획득 리스트를 사용하라.

함수 내에서, 심지어 기존 값을 현재 스코프에서 사용할 수 있을지라도, 인-아웃 매개변수로 넘겨진 값에 접근하지 마라. 기존 값에 접근하는 것은 값에 대한 동시 접근이며, 이는 Swift의 메모리 배타성 보장을 위반한다. 같은 이유로, 여러 개의 인-아웃 매개변수에 같은 값을 넘길 수 없다.

인자가 메모리의 물리 주소에 저장된 것일 때, 최적화를 위해 같은 메모리 위치가 함수 구현부의 안팎 모두에서 사용된다. 최적화된 동작은 *call by reference*라고 알려져 있다; 이는 복사에 대한 오버헤드를 제거하면서 copy-in copy-out 모델의 모든 요구사항을 충족한다. call-by-reference 최적화에 의존하지 않고 copy-in copy-out이 주어진 모델을 사용하여 코드를 작성하여, 최적화 여부에 상관 없이 올바르게 작동하도록 하라.

이 동작은 *copy-in copy-out* 또는 *call by value result*로 알려져 있다. 예를 들어, 연산 프로퍼티나 옵저버를 갖는 프로퍼티가 인-아웃 매개변수로서 넘겨질 때, 그것의 접근자는 함수 호출의 일부분으로서 호출되고 그것의 설정자는 함수 반환의 일부분으로서 호출된다.

1. 함수가 호출될 때, 인자의 값이 복사된다.
2. 함수의 구현부에서, 이 복사본은 수정된다.
3. 함수가 반환할 때, 해당 복사본의 값은 기존 인자에 할당된다.

인-아웃 매개변수는 다음과 같이 전달된다.

### 인-아웃 매개변수

```
func repeatGreeting(_ greeting: String, count n: Int) { /* Greet n times */ }
repeatGreeting("Hello, world!", count: 2) //  count is labeled, greeting is not
```

매개변수 이름 앞에 있는 언더스코어 (`_`) 인자 레이블을 은폐한다. 이에 대응하는 인자는 반드시 함수나 메소드 호출에서 레이블을 갖지 않아야 한다.

매개변수 이름 앞에 있는 이름은 매개변수에 명시적인 인자 레이블을 제공하며, 이는 매개변수 이름과 다를 수 있다. 이에 대응하는 인자는 함수나 메소드 호출에서 주어진 인자 레이블을 반드시 사용해야 한다.

```
{argument label} {parameter name}: {parameter type}
_ {parameter name}: {parameter type}
```

다음의 형식 중 하나로 인자 레이블의 기본 동작을 재정의할 수 있다.

```
func f(x: Int, y: Int) -> Int { return x + y }
f(x: 1, y: 2) // both x and y are labeled
```

매개변수는 이름을 가지며, 이는 인자 레이블처럼 함수 구현부 안에서 사용되고, 함수나 메소드를 호출할 때 사용된다. 기본적으로, 매개변수 이름은 또한 인자 레이블로서 사용된다.

```
{parameter name}: {parameter type}
```

함수 매개변수는 각 매개변수가 여러 형식 중 하나를 갖는 곳에 있는 콤마로 구분된 리스트다. 함수에 있는 인자들의 순서는 함수 선언에 있는 매개변수의 순서와 반드시 일치해야 한다. 매개변수 리스트의 가장 간단한 엔트리는 다음의 형식을 갖는다.

### 매개변수 이름

중첩 함수는 인-아웃 매개변수처럼 절대 탈출하지 않을 것임이 보장된 값을 획득하거나, 탈출 처리되지 않은 함수의 매개변수로 넘겨진다면 탈출 처리되지 않는다. 그렇지 않으면, 중첩 함수는 탈출 처리된 함수다.

함수 정의는 또다른 함수 선언의 내부에 나타날 수 있다. 이러한 종류의 함수는 *중첩 함수*라고 알려져 있다.

함수는 튜플 타입을 함수의 반환형으로 사용하여 여러 개의 값을 반환할 수 있다.

*statements*가 오직 하나의 표현식을 포함하는 함수 선언은 해당 표현식의 값을 반환하는 것으로 이해된다.

각 매개변수의 타입은 반드시 포함되어야 한다-그것은 추론될 수 없다. 매개변수 타입의 앞에 `inout`을 작성하면 해당 매개변수는 함수 스코프 안에서 수정될 수 있다.

```
func {function name}({parameters}) {
    {statements}
}
```

함수가 `Void` 반환형을 갖는다면, 반환형은 다음처럼 생략될 수 있다.

*함수 선언*은 프로그램에 함수나 메소드를 도입한다. 클래스, 구조체, 열거형, 또는 프로토콜의 컨텍스트에 선언된 함수는 *메소드*라고 불린다. 함수 선언은 `func` 키워드를 사용하여 선언되고 다음의 형식을 갖는다.

## 함수 선언

이 타입 별칭이 없었다면, `sum` 함수는 관련 타입*associated type*을 `T.Element` 대신 `T.Iterator.Element`로 참조해야 했을 것이다.

프로토콜 선언 안에서, 타입 별칭은 주기적으로 사용되는 타입에 더 짧고 더 편리한 이름을 줄 수 있다.

타입 별칭은 선언에서 모든 제네릭 매개변수를 생략하여 존재하는 타입의 제네릭 매개변수를 포워딩할 수 있다. 예를 들어, 여기서 선언된 `Diccionario` 타입 별칭은 `Dictionary`가 가진 제네릭 매개변수와 제약과 같은 것들을 갖는다.

타입 별칭과 존재하는 타입이 상호 교환 가능하게 사용될 수 있기 때문에, 타입 별칭은 추가적인 제네릭 제약을 도입할 수 없다.

타입 별칭이 제네릭 매개변수와 함께 선언된다면, 그러한 매개변수에 대한 제약은 반드시 존재하는 타입의 제네릭 매개변수에 대한 제약과 정확히 일치해야 한다.

타입 별칭 선언은 존재하는 제네릭 타입에 이름을 주기 위해 제네릭 매개변수를 사용할 수 있다. 타입 별칭은 존재하는 타입의 일부 또는 모든 제네릭 매개변수를 위해 구체 타입을 제공할 수 있다.

타입 별칭이 선언된 후, 별칭이 붙은 *name*은 프로그램의 모든 곳에서 *existing type*으로 대신 사용될 수 있다. *existing type*은 이름 있는 타입 또는 합성 타입이 될 수 있다. 타입 별칭은 새로운 타입을 만들지 않는다; 단순히 어떤 이름이 이미 존재하는 타입을 참조할 수 있게 하는 것이다.

*타입 별칭 선언*은 프로그램에 이미 존재하는 타입에 대한 이름 있는 별칭을 도입한다. 타입 별칭 선언은 `typealias` 키워드를 사용하여 선언되고 다음의 형식을 갖는다.

## 타입 별칭 선언

타입 변수 프로퍼티를 선언하기 위해, `static` 선언 지정자와 함께 선언한다. 클래스는 서브클래스가 슈퍼클래스의 구현을 재정의할 수 있게 하기 위해 대신 `class` 선언 지정자를 사용하여 타입 연산 프로퍼티를 선언할 수 있다.

### 타입 변수 프로퍼티

`didSet` 옵저버의 구현부가 오래된 값을 참조한다면, 접근자는 옵저버 이전에 호출되어 오래된 값을 사용 가능하게 한다. 그렇지 않으면, 새로운 값은 슈퍼클래스의 접근자를 호출하지 않고 저장된다. 아래의 예시는 슈퍼클래스에서 정의된 저장 프로퍼티와 옵저버를 추가하기 위해 서브클래스에서 재정의한 것을 보여준다.

`didSet` 절은 `willSet` 절을 제공한다면 선택적이다. 이처럼, `willSet` 절은 `didSet` 절을 제공한다면 선택적이다.

`willSet`과 `didSet` 절에서 *setter name*과 이를 둘러싼 소괄호는 선택적이다. 설정자 이름을 제공한다면, 이들은 `willSet`과 `didSet` 옵저버에 대해 매개변수 이름으로 사용된다. 설정자 이름을 제공하지 않는다면, `willSet` 옵저버에 대해서 기본 매개변수 이름은 `newValue`이고 `didSet` 옵저버에 대해서 기본 매개변수 이름은 `oldValue`가 된다.

`willSet` 옵저버는 변수나 프로퍼티의 값이 설정되기 직전에 호출된다. 새로운 값은 `willSet` 옵저버에 상수로 넘겨지며, 그러므로 `willSet` 절의 구현에서 변경될 수 없다. `didSet` 옵저버는 새로운 값이 설정된 직후에 호출된다. `willSet` 옵저버와는 대조적으로, 변수나 프로퍼티의 오래된 값은 여전히 그것에 접근할 필요가 있을 때를 대비하여 `didSet` 옵저버에 넘겨진다. 즉, 그 자신의 `didSet` 옵저버 절 안에서 해당 변수나 프로퍼티에 값을 할당한다면, 할당하는 새로운 값은 설정되는 것을 교체할 것이고 `willSet` 옵저버에 넘겨질 것이다.

`willSet` 및 `didSet` 옵저버는 변수나 프로퍼티의 값이 설정되고 있을 때 관찰하는 방법 (그리고 적절하게 응답하는 방법) 을 제공한다. 옵저버는 변수나 프로퍼티가 최초에 초기화될 때 호출되지 않는다. 대신, 값이 초기화 컨텍스트의 바깥에서 설정될 때만 호출된다.

초기화 *expression*은 클래스나 구조체 선언 컨텍스트에서 선택적이나, 다른 곳에서는 필수적이다. *type* 어노테이션은 해당 타입이 초기화 *expression*으로부터 추론될 수 있을 때 선택적이다. 이 표현식은 프로퍼티의 값을 최초에 읽을 때 평가된다. 이를 읽지 않도 프로퍼티의 초기 값을 덮어 쓴다면, 이 표현식은 프로퍼티 값을 최초에 쓸 때 평가된다.

어떠한 저장 프로퍼티에라도 프로퍼티 옵저버를 추가할 수 있다. 또한 어떠한 상속된 프로퍼티 (저장이든 연산이든) 에라도 서브클래스에서 프로퍼티를 재정의하여 프로퍼티 옵저버를 추가할 수 있다.

이 변수 선언의 형식을 전역 스코프, 함수의 지역 스코프, 또는 클래스나 구조체 선언의 컨텍스트에서 정의한다. 이 변수 선언의 형식이 전역 스코프나 함수의 지역 스코프에 선언된다면, 옵저버는 *저장 변수 옵저버*로 불린다. 이것이 클래스나 구조체 선언의 컨텍스트 안에 선언된다면, 옵저버는 *프로퍼티 옵저버*라고 불린다.

`willSet` 옵저버와 `didSet` 옵저버와 함께 저장 변수나 프로퍼티를 선언할 수도 있다. 옵저버와 함께 선언되는 저장 변수 또는 프로퍼티는 다음의 형식을 갖는다.

### 저장 변수 옵저버 및 프로퍼티 옵저버

이름 있는 저장 값과 저장 변수 프로퍼티와는 다르게, 이름 있는 연산 값과 연산 프로퍼티의 값은 메모리에 저장되지 않는다.

*setter name*과 이를 감싼 소괄호는 선택적이다. 설정자 이름을 제공한다면, 설정자에 대한 매개변수의 이름으로 사용된다. 설정자 이름을 제공하지 않는다면, 설정자에 대한 기본 매개변수 이름은 `newValue`다.

접근자는 값을 읽기 위해 사용되며, 설정자는 값을 쓰기 위해 사용된다. 설정자 절은 선택적이며, 오직 접근자만 필요할 때 두 절 모두를 생략하고 단순하게 요청된 값을 직접 반환할 수 있다. 하지만 설정자 절을 제공한다면, 반드시 접근자 절 또한 제공해야 한다.

이 변수 선언의 형식을 전역 스코프, 함수의 지역 스코프, 또는 클래스, 구조체, 열거형, 또는 익스텐션 선언의 컨텍스트에서 정의한다. 이 변수 선언의 형식이 전역 스코프나 함수의 지역 스코프에서 선언된다면, 이를 *연산 변수*라고 부른다. 이것이 클래스, 구조체, 또는 익스텐션 선언의 컨텍스트에서 선언된다면, 이를 *연산 프로퍼티*라고 부른다.

다음의 형식은 연산 변수 또는 연산 프로퍼티를 선언한다.

### 연산 변수 및 연산 프로퍼티

그 이름이 제안하듯, 저장 변수나 저장 변수 프로퍼티의 값은 메모리에 저장된다.

상수 선언처럼, *variable name*이 튜플 패턴이라면, 튜플의 각 아이템의 이름은 초기화 *expression*에서 대응하는 값에 바인딩된다.

초기화 *expression*은 프로토콜 선언에서 나타날 수 없으나, 다른 모든 컨텍스트에서, 초기화 *expression*은 선택적이다. 즉, 초기화 *expression*이 없다면, 변수 선언은 반드시 명시적인 타입 어노테이션 (`: type`) 을 포함해야 한다.

이 변수 선언의 형식을 전역 스코프에서, 함수의 지역 스코프에서, 또는 클래스나 구조체 선언의 컨텍스트에서 정의한다. 이 형식의 변수 선언이 전역 스코프나 함수의 지역 스코프에서 선언된다면, 이를 *저장 변수*라고 부른다. 이것이 클래스나 구조체 선언의 컨텍스트에서 선언된다면, 이를 *저장 변수 프로퍼티*라고 부른다.

다음의 형식은 저장 변수 또는 저장 변수 프로퍼티를 선언한다.

### 저장 변수 및 저장 변수 프로퍼티

서브클래스의 프로퍼티 선언을 `override` 선언 지정자와 함께 표시하여 서브클래스에서 프로퍼티를 재정의할 수 있다.

- 알아두기

  프로토콜 선언의 컨텍스트에서도 프로퍼티를 선언할 수 있다.

변수 선언은 다른 종류의 이름 있는 변경 가능한 값을 선언하는 여러 가지의 형식이 있으며, 저장 및 연산 변수와 프로퍼티, 저장 변수 및 프로퍼티 옵저버, 그리고 정적 변수 프로퍼티를 포함한다. 사용하기에 적절한 형식은 변수가 선언되는 스코프와 선언하려는 변수의 종류에 따른다.

*변수 선언*은 프로그램에 이름 있는 변수 값을 도입하고 `var` 키워드를 사용하여 선언된다.

## 변수 선언

상수 타입 프로퍼티를 선언할 때, `static` 선언 지정자를 사용하여 선언한다. 클래스의 상수 타입 프로퍼티는 항상 암시적으로 종단*final*이다; 서브클래스에 의한 재정의를 허용하거나 허용하지 않기 위해 `class` 또는 `final` 선언 지정자를 사용하여 선언할 수 없다.

타입 어노테이션 (`: type`) 은 *constant name*의 타입이 추론될 수 있을 때 상수 선언에서 선택적이다.

이 예시에서, `firstNumber`는 `10`의 값에 대한 이름 있는 상수고, `secondNumber`는 `42`의 값에 대한 이름 있는 상수다. 두 상수 모두 이제 독립적으로 사용될 수 있다.

상수 선언의 *constant name*이 튜플 패턴이라면, 튜플의 각 아이템의 이름은 초기화 *expression*에서 대응하는 값에 바인딩된다.

상수가 전역 스코프에 선언되었다면, 반드시 값과 함께 초기화되어야 한다. 상수 선언이 함수나 메소드의 컨텍스트에서 발생한다면, 그 값이 최초에 읽히기 전에 값이 설정된다는 것이 보장되는 한, 나중에 초기화될 수 있다. 컴파일러가 상수의 값이 절대 읽히지 않을 것이라는 것을 증명할 수 있다면, 그 상수는 값을 필수적으로 설정할 필요가 없다. 상수 선언이 클래스나 구조체 선언의 컨텍스트에서 발생한다면, 이는 *상수 프로퍼티*로 간주된다. 상수 선언은 연산 프로퍼티가 아니며, 그러므로 접근자나 설정자를 갖지 않는다.

상수 선언은 *constant name*과 초기화 *expression*의 값 사이에 불변 바인딩을 정의한다; 상수 값이 설정된 후, 이는 변경될 수 없다. 즉, 상수가 클래스 객체로 초기화되었다면, 객체 그 자체는 변할 수 있으나, 상수 이름과 그것이 참조하는 객체 간 바인딩은 변할 수 없다.

*상수 선언*은 프로그램에 이름 있는 상수 값을 도입한다. 상수 선언은 `let` 키워드를 사용하여 선언되고 다음의 형식을 갖는다.

## 상수 선언

임포트되는 심볼에 더 자세한 제한을 제공할 수 있다-특정 서브모듈이나 모듈 또는 서브모듈 내의 특정 선언을 지정할 수 있다. 이 세부 형식이 사용될 때, 오직 임포트된 심볼 (그리고 그것을 선언한 모듈이 아님) 만이 현재 스코프에서 사용 가능하게 된다.

*임포트 선언*은 현재 파일 바깥에 선언된 심볼에 접근할 수 있게 한다. 기본 형식은 전체 모듈을 임포트한다; `import` 키워드 다음에 모듈 이름이 붙는 것으로 구성된다.

## 임포트 선언

블록 안에 있는 *statements*는 선언, 표현식, 그리고 다른 종류의 구문들을 포함하며, 소스 코드에서 그것들이 나타나는 순서에 따라 실행된다.