# 패턴

*패턴*은 단일 값 또는 합성 값의 구조를 표현한다. 예를 들어, 튜플 `(1, 2)`의 구조는 콤마로 구분된 두 개의 요소릐 리스트다. 패턴은 어떤 하나의 특정 값이 아닌 값의 구조를 표현하기 때문에, 다양한 값들과 이것들을 매칭할 수 있다. 예를 들어, `(x, y)` 패턴은 튜플 `(1, 2)`과 다른 두 개의 요소를 가진 어떠한 튜플과도 매칭된다. 패턴을 값과 매칭하는 것 이외에도, 합성 값의 일부분이나 모두를 추출하고 각 부분을 상수나 변수 이름에 바인딩할 수 있다.

Swift에는 두 가지 종류의 기본 패턴이 있다. 하나는 어떠한 종류의 값에 성공적으로 매칭되는 것이고, 다른 하나는 런타임에서 특정 값에 매칭되는 것이 실패한 것이다.

첫 번째 종류의 패턴은 값을 단순한 변수, 상수, 그리고 옵셔널 바인딩으로 파괴하기 위해 사용된다. 이러한 것들은 와일드카드 패턴, 식별자 패턴, 그리고 이들을 포함하는 값 바인딩이나 튜플 패턴을 포함한다. 이러한 패턴들에 타입 어노테이션을 지정하여 오직 특정 타입의 값에만 매칭되도록 제한할 수 있다.

두 번째 종류의 패턴은 전체 패턴 매칭을 위해 사용되며, 매칭하려는 값들은 런타임에는 거기에 있지 않을 수 있다. 이러한 것들은 열거형 케이스 패턴, 옵셔널 패턴, 표현식 패턴, 그리고 타입 캐스팅 패턴을 포함한다. `switch` 구문의 케이스 레이블, `do` 구문의 `catch` 절, 또는 `if`, `while`, `guard`, `for-in` 구문의 조건 케이스에서 이러한 패턴들을 사용한다.

## 와일드카드 패턴

*와일드카드 패턴*은 어떠한 값과 매칭되고 무시하며, 언더스코어 (`_`) 로 구성된다. 와일드카드 패턴을 사용하여 값과 매칭되는 것을 신경쓰지 않는다. 예를 들여, 다음의 코드는 닫힌 범위 `1...3`을 통해 반복하며, 루프의 각 반복에 대해서 범위의 현재 값은 무시한다.

```swift
for _ in 1...3 {
    // Do something three times.
}
```

## 식별자 패턴

*식별자 패턴*은 어떠한 값과 매칭되고 매칭된 값을 변수나 상수 이름에 바인딩한다. 예를 들어, 다음의 상수 선언에서, `someValue`는 `Int` 타입인 `42` 값과 매칭되는 식별자 패턴이다.

```swift
let someValue = 42
```

매칭이 성공하면, 값 `42`는 상수 이름 `someValue`에 바인딩 (할당) 된다.

변수나 상수 선언의 좌측에 있는 패턴이 식별자 패턴이면, 해당 식별자 패턴은 암시적으로 값 바인딩 패턴의 서브 패턴이다.

## 값 바인딩 패턴

*값 바인딩 패턴*은 매칭된 값들을 변수나 상수 이름과 바인딩한다. 매칭된 값을 상수의 이름과 바인딩하는 값 바인딩 패턴은 `let` 키워드로 시작한다; 변수의 이름에 바인딩하는 것은 `var` 키워드로 시작한다.

값 바인딩 패턴 안에 있는 식별자 패턴은 새로운 이름 있는 변수나 상수에 매칭된 값들을 바인딩한다. 예를 들어, 튜플의 요소들을 분해하고 각 요소를 대응하는 식별자 패턴에 바인딩할 수 있다.

```swift
let point = (3, 2)
switch point {
    // Bind x and y to the elements of point.
case let (x, y):
    print("The point is at (\(x), \(y)).")
}
// Prints "The point is at (3, 2)."
```

위의 예시에서, `let`은 튜플 패턴 `(x, y)`에 있는 각각의 식별자 패턴에 분배된다. 이 동작 때문에, `switch` 구문의 케이스 `case let (x, y):`와 `case (let x, let y):`는 같은 값을 매칭한다.

## 튜플 패턴

*튜플 패턴*은 소괄호로 둘러싸여 콤마로 구분된 0개 이상의 패턴의 리스트다. 튜플 패턴은 대응하는 튜플 타입의 값을 매칭한다.

타입 어노테이션을 사용하여 튜플 패턴이 특정 종류의 튜플 타입과 매칭되도록 제한할 수 있다. 예를 들어, 상수 선언 `let (x, y): (Int, Int) = (1, 2)`에서의 튜플 패턴 `(x, y): (Int, Int)`은 오직 두 개의 요소가 모두 `Int` 타입인 튜플 타입에 대해서만 매칭된다.

튜플 패턴이 `for-in` 구문이나 변수 또는 상수 선언에서의 패턴으로 사용될 때, 오직 와일드카드 패턴, 식별자 패턴, 옵셔널 패턴, 또는 이들을 포함하는 다른 튜플 패턴만을 포함할 수 있다. 예를 들어, 다음의 코드는 튜플 패턴 `(x, 0)`에 있는 요소 `0`이 표현식 패턴이므로 유효하지 않다.

```swift
let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]
// This code isn't valid.
for (x, 0) in points {
    /* ... */
}
```

하나의 요소를 포함하는 튜플 패턴 주위에 있는 소괄호는 효과를 갖지 않는다. 해당 패턴은 단일 요소의 타입에 대한 값을 매칭한다. 예를 들어, 다음의 것들은 동일하다.

```swift
let a = 2        // a: Int = 2
let (a) = 2      // a: Int = 2
let (a): Int = 2 // a: Int = 2
```

## 열거형 케이스 패턴

*열거형 케이스 패턴*은 존재하는 열거형 타입의 케이스를 매칭한다. 열거형 케이스 패턴은 `switch` 구문의 케이스 레이블과 `if`, `while`, `guard`, `for-in` 구문의 조건 케이스에 나타난다.

매칭하려는 열거형 케이스가 연관 값을 가지고 있다면, 대응하는 열거형 케이스 패턴은 반드시 각각의 연관 값에 대하여 하나의 요소를 포함하는 튜플 패턴을 지정해야 한다.

열거형 케이스 패턴은 또한 옵셔널에 래핑된 케이스에 대한 값을 매칭한다. 이 단순화된 신택스는 옵셔널 패턴을 생략할 수 있게 한다. 알아둘 것은, `Optional`은 열거형으로 구현되어 있기 때문에, `.none`과 `.some`은 열거형 타입의 케이스로서 동일한 스위치에서 나타날 수 있다는 것이다.

```swift
enum SomeEnum { case left, right }
let x: SomeEnum? = .left
switch x {
case .left:
    print("Turn left")
case .right:
    print("Turn right")
case nil:
    print("Keep going straight")
}
// Prints "Turn left"
```

## 옵셔널 패턴

*옵셔널 패턴*은 `Optional<Wrapped>` 열거형의 `some(Wrapped)` 케이스에 래핑된 값을 매칭한다. 옵셔널 패턴은 식별자 패턴 바로 뒤에 물음표가 나타나는 것으로 구성되고, 열거형 케이스 패턴과 같은 장소에 나타난다.

옵셔널 패턴은 `Optional` 열거형 케이스 패턴에 대한 신택틱 슈거이므로, 다음의 것들은 동일하다.

```swift
let someOptional: Int? = 42
// Match using an enumeration case pattern.
if case .some(let x) = someOptional {
    print(x)
}

// Match using an optional pattern.
if case let x? = someOptional {
    print(x)
}
```

옵셔널 패턴은 `for-in` 구문에서, `nil`이 아닌 요소에 대해서만 루프의 구현부를 실행하기 위해 옵셔널 값을 갖는 배열을 반복할 수 있는 편리한 방법을 제공한다.

```swift
let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]
// Match only non-nil values.
for case let number? in arrayOfOptionalInts {
    print("Found a \(number)")
}
// Found a 2
// Found a 3
// Found a 5
```

## 타입 캐스팅 패턴

두 가지의 타입 캐스팅 패턴, `is` 패턴과 `as` 패턴이 있다. `is` 패턴은 오직 `switch` 구문의 케이스 레이블에서만 나타난다. `is`와 `as` 패턴은 다음의 형식을 갖는다.

```swift
is {type}
{pattern} as {type}
```

`is` 패턴은 값의 타입이 런타임에서 `is` 패턴의 우측에 지정된 타입, 또는 해당 타입의 서브클래스와 동일한 지를 매칭한다. `is` 패턴은 타입 캐스팅을 수행하지만 반환된 타입을 버린다는 관점에서 `is` 연산자와 같은 동작을 한다.

`as` 패턴은 런타임에서 값의 타입이 `as` 패턴의 우측에 지정된 타입 또는 해당 타입의 서브클래스와 같은 지를 매칭한다. 이 매칭이 성공하면, 매칭된 값의 타입은 `as` 패턴의 우측에 지정된 *pattern*으로 캐스팅된다.

## 표현식 패턴

*표현식 패턴*은 표현식의 값을 표현한다. 표현식 패턴은 오직 `switch` 구문의 케이스 레이블에서만 나타난다.

표현식 패턴이 표현하는 표현식은 Swift 표준 라이브러리의 `~=` 연산자가 사용하는 입력 표현식의 값과 비교된다. `~=` 연산자가 `true`를 반환하면 매칭은 성공한다. 기본적으로 `~=` 연산자는 `==` 연산자를 사용하여 동일한 타입의 두 개의 값을 비교한다. 또한 아래의 예시에 있는 것처럼, 해당 값이 범위에 포함되어 있는지를 확인하여 값을 값의 범위와 매칭할 수 있다.

```swift
let point = (1, 2)
switch point {
case (0, 0):
    print("(0, 0) is at the origin.")
case (-2...2, -2...2):
    print("(\(point.0), \(point.1)) is near the origin.")
default:
    print("The point is at (\(point.0), \(point.1)).")
}
// Prints "(1, 2) is near the origin."
```

커스텀 표현식 매칭 동작을 제공하기 위해 `~=` 연산자를 오버로딩할 수 있다. 예를 들어, `point` 표현식을 포인트의 문자열 표현과 비교하기 위해 위의 예시를 다시 작성할 수 있다.

```swift
// Overload the ~= operator to match a string with an integer.
func ~= (pattern: String, value: Int) -> Bool {
    return pattern == "\(value)"
}
switch point {
case ("0", "0"):
    print("(0, 0) is at the origin.")
default:
    print("The point is at (\(point.0), \(point.1)).")
}
// Prints "The point is at (1, 2)."
```