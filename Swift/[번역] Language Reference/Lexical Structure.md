# 어휘 구조

Swift의 *어휘 구조*는 어떤 문자 시퀀스가 언어의 유효한 토큰인지를 기술한다. 이렇게 유효한 토큰들은 연어의 가장 저수준의 유효한 토큰을 형성하고, 이어지는 챕터에서 언어의 나머지를 기술한다. 토큰은 식별자*identifier*, 키워드*keyword*, 구두점*punctuation*, 리터럴*literal*, 또는 연산자*operator*로 구성된다.

대부분의 경우, 토큰은 아래에 명시되는 문법의 제약 내에서 Swift 소스 파일의 문자들로부터 입력 텍스트의 가장 긴 가능한 부분 문자열을 고려하여 형성된다. 이 동작은 *longest match or maximal munch*라고 불린다.

## 공백 및 주석

공백은 두 개의 사용법이 있다. 소스 파일에서 토큰들을 분리하고, 연산자가 전위인지 후위인지 결정하는 것을 돕는다. 나머지는 무시된다. 다음의 문자들은 공백으로 고려된다.

- 스페이스 (U+0020)
- 라인 피드 (U+000A)
- 캐리지 리턴 (U+000D)
- 수평 탭 (U+0009)
- 수직 탭 (U+000B)
- 폼 피드 (U+000C)
- null (U+0000)

주석은 컴파일러에 의해 공백으로 취급된다. 단일 라인 주석은 `//`으로 시작하고 라인 피드 (U+000A) 나 캐리지 리턴 (U+000D) 까지 지속된다. 다중 라인 주석은 `/*`로 시작하고 `*/`로 끝난다. 중첩 다중 라인 주석은 허용되나, 주석 표시가 서로 균형을 이루어야 한다.

주석은 추가적인 포매팅 및 마크업을 포함할 수 있다.  

## 식별자

*식별자*는 A부터 Z까지의 대문자 또는 소문자, 언더스코어 (`_`), Basic Multilingual Plane에 있는 비조합 영숫자 유니코드 문자, 또는 Private Use Area 내에 있지 않은 Basic Multilingual Plane 바깥에 있는 문자로 시작한다. 첫 번째 문자 이후에, 숫자 및 조합 유니코드 문자도 허용된다.

예약어를 식별자로 사용하기 위해 역따옴표 (`) 를 앞뒤에 붙여라. 예를 들어, `class`는 유효한 식별자가 아니지만 ``class``는 유효하다. 역따옴표는 식별자의 일부분으로 고려되지 않는다; ``x``와 `x`는 같은 의미를 갖는다.

명시적인 매개변수 이름이 없는 클로저 내에서, 매개변수들은 `$0`, `$1`, `$2` 등으로 이름 지어져 암시적이게 된다. 이러한 이름들은 클로저 스코프 내에서 유효한 식별자다.

컴파일러는 프로퍼티 래퍼 투영을 갖는 프로퍼티에 대해 달러 기호 ($) 로 시작하는 식별자를 통합한다. 코드는 이러한 식별자와 상호작용 할 수 있지만 달러 기호를 앞에 붙인 식별자를 선언할 수 없다.

## 키워드 및 구두점

다음의 키워드는 예약되었고, 역따옴표로 감싸지지 않는다면 식별자로 사용될 수 없다. `inout`, `var`, `let` 이외의 키워드들은 역따옴표로 탈출 처리되지 않고도 함수 선언이나 함수 호출 안에서 매개변수 이름으로 사용될 수 있다. 멤버가 키워드와 같은 이름을 가지고 있다면, 그 멤버에 대한 참조는 역따옴표로 탈출 처리될 필요가 없고, 그 멤버에 대한 참조와 키워드를 사용하는 것 사이의 모호성이 있을 때는 제외한다. 예를 들어, `self`, `Type`, `Protocol`은 명시적인 멤버 표현식에서 특별한 의미를 가지므로, 그 컨텍스트 안에서 반드시 역따옴표를 사용하여 탈출 처리되어야 한다.

- 선언문에서 사용되는 키워드
  - `associatedtype`
  - `class`
  - `deinit`
  - `enum`
  - `extension`
  - `fileprivate`
  - `func`
  - `import`
  - `init`
  - `inout`
  - `internal`
  - `let`
  - `open`
  - `operator`
  - `private`
  - `protocol`
  - `public`
  - `rethrows`
  - `static`
  - `struct`
  - `subscript`
  - `typealias`
  - `var`
- 구문에서 사용되는 키워드
  - `break`
  - `case`
  - `continue`
  - `default`
  - `defer`
  - `do`
  - `else`
  - `fallthrough`
  - `for`
  - `guard`
  - `if`
  - `in`
  - `repeat`
  - `return`
  - `switch`
  - `where`
  - `while`
- 표현식과 타입에서 사용되는 키워드
  - `as`
  - `Any`
  - `catch`
  - `false`
  - `is`
  - `nil`
  - `super`
  - `self`
  - `Self`
  - `throw`
  - `throws`
  - `true`
  - `try`
- 패턴에서 사용되는 키워드
  - `_`
- 숫자 기호 (#) 로 시작하는 키워드
  - `#available`
  - `#colorLiteral`
  - `#column`
  - `#else`
  - `#elseif`
  - `#endif`
  - `#error`
  - `#file`
  - `#filePath`
  - `#fileLiteral`
  - `#function`
  - `#if`
  - `#imageLiteral`
  - `#line`
  - `#selector`
  - `#sourceLocation`
  - `#warning`
- 특정 컨텍스트에서 예약된 키워드
  - `associativity`
  - `convenience`
  - `dynamic`
  - `didSet`
  - `final`
  - `get`
  - `infix`
  - `indirect`
  - `lazy`
  - `left`
  - `mutating`
  - `none`
  - `nonmutating`
  - `optional`
  - `override`
  - `postfix`
  - `precedence`
  - `prefix`
  - `Protocol`
  - `required`
  - `right`
  - `set`
  - `Type`
  - `unowned`
  - `weak`
  - `willSet`
  - 문법에서 이들이 나타나는 컨텍스트 밖에서 식별자로 사용할 수 있다.

다음의 토큰들은 구두점으로 예약되어 있고 커스텀 연산자로 사용될 수 없다.

- `(`, `)`

- `{`, `}`

- `[`, `]`

- `.`

- `,`

- `:`

- `;`

- `=`

- `@`

- `#`

- `&` (전위 연산자로서)

- `->`

- ```
  
  ```

- `?`

- `!` (후위 연산자로서)

## 리터럴

*리터럴*은 숫자나 문자열과 같이 타입의 값을 소스 코드에서 표현하는 것이다.

다음은 리터럴의 예다.

```swift
42              // 정수 리터럴
3.14159         // 부동소수점 리터럴
"Hello, world!" // 문자열 리터럴
true            // 불리언 리터럴
```

리터럴은 그 자체로 타입을 갖지 않는다. 대신, 리터럴은 유한한 정밀도를 갖도록 파싱되고 Swift의 타입 추론이 리터럴에 대한 타입을 추론하는 것을 시도한다. 예를 들어, `let x: Int8 = 42` 선언문에서, Swift는 명시적인 타입 어노테이션 (`: Int8`) 을 사용하여 정수 리터럴 `42`가 `Int8` 타입이라는 것을 추론한다. 만약 사용 가능한 적절한 타입 정보가 없다면, Swift는 리터럴의 타입을 Swift 표준 라이브러리에 정의된 기본 리터럴 타입 중 하나로 추론한다. 정수 리터럴에 대한 기본 타입은 `Int`, 부동소수점 리터럴에 대해서는 `Double`, 문자열 리터럴에 대해서는 `String`, 불리언 리터럴에 대해서는 `Bool`이다. 예를 들어, `let str = "Hello, world"` 선언문에서, 스트링 리터럴 `"Hello, world"`의 기본 추론 타입은 `String`이다.

리터럴 값에 대해 타입 어노테이션을 명시한다면, 어노테이션의 타입은 반드시 그 리터럴 값으로부터 인스턴스가 생성될 수 있는 타입이어야 한다. 즉, 타입은 다음의 Swift 표준 라이브러리의 프로토콜 중 하나를 준수해야 한다.

- `ExpressibleByIntegerLiteral` : 정수 리터럴
- `ExpressibleByFloatLiteral` : 부동소수점 리터럴
- `ExpressibleByStringLiteral` : 문자열 리터럴
- `ExpressibleByBooleanLiteral` : 불리언 리터럴
- `ExpressibleByUnicodeScalarLiteral` : 오직 하나의 유니코드 스칼라를 갖는 문자열 리터럴
- `ExpressibleByExtendedGraphemeClusterLiteral` : 오직 하나의 확장된 서기소 클러스터*extended grapheme cluster*를 갖는 문자열 리터럴

예를 들어, `Int8`은 `ExpressibleByIntegerLiteral` 프로토콜을 준수하며, 그러므로 선언문 `let x: Int8 = 42`에서 정수 리터럴 `42`를 위해서 `Int8`은 타입 어노테이션으로 사용될 수 있다.

### 정수 리터럴

*정수 리터럴*은 지정되지 않은 정밀도의 정수 값을 표현한다. 기본적으로 정수 리터럴은 10진법의 형식으로 표현된다; 접두어를 사용하여 대안의 진법을 명시할 수 있다. 2진 리터럴은 `0b`, 8진 리터럴은 `0o`, 16진 리터럴은 `0x`로 시작한다.

10진 리터럴은 `0`에서 `9` 사이의 숫자를 포함한다. 2진 리터럴은 `0`과 `1`을 포함하고, 8진 리터럴은 `0`에서 `7` 사이를 포함하고, 16진 리터럴은 `0`에서 `9` 사이와 `A`부터 `F` 사이의 대문자 또는 소문자를 포함한다.

음수 정수 리터럴은 빼기 기호 (-) 를 정수 리터럴의 앞에 붙여서 표현된다. 예. `-42`

언더스코어 (`_`) 는 가독성을 위해 숫자 사이에서 허용되지만 무시되므로 리터럴의 값에 영향을 주지 않는다. 정수 리터럴은 `0`으로 시작할 수 있으나 무시되며 리터럴의 진법이나 값에 영향을 주지 않는다.

달리 지정하지 않는다면, Swift 표준 라이브러리에서 정수 리터럴의 기본 추론 타입은 `Int`다. Swift 표준 라이브러리는 또한 부호가 있는, 부호가 없는 정수들의 다양한 크기에 대한 타입들을 정의한다.

### 부동소수점 리터럴

*부동소수점 리터럴*은 지정되지 않은 정밀도의 부동소수점 값을 표현한다.

기본적으로 부동소수점 리터럴은 10진법으로 (접두어 없이) 표현된다. 하지만 16진법으로 (`0x` 접두어와 함께) 표현될 수도 있다.

10진 부동소수점 리터럴은 10진 가수*fraction*, 10진 지수*exponent* 또는 둘 다가 오는 일련의 10진 숫자로 구성된다. 10진 가수는 일련의 10진 숫자 다음에 오는 소수점 (`.`) 으로 구성된다. 지수는 대문자 또는 소문자 `e` 접두어와 `e` 앞에 오는 값에 10을 곱한 10의 거듭 제곱을 나타내는 일련의 10진 숫자들로 구성된다. 예를 들어, `1.25e2`는 1.25 x 10^2를 나타내며, 125.0으로 평가된다. 비슷하게, `1.25e-2`는 1.25 x 10^-2를 나타내며, 0.0125로 평가된다.

16진 부동소수점 리터럴은 `0x` 접두어로 시작하여 선택적인 16진 가수, 16진 지수로 구성된다. 16진 가수는 일련의 16진 숫자들 다음에 오는 소수점으로 구성된다. 지수는 대문자 또는 소문자 `p` 접두어와 `p` 앞에 오는 값에 2의 거듭 제곱을 곱하는 일련의 10진 숫자들로 구성된다. 예를 들어, `0xFp2`는 15 x 2^2를 나타내며, 60으로 평가된다. 비슷하게, `0xFp-2`는 15 x 2^-2를 나타내며, 3.75로 평가된다.

음수 부동소수점 리터럴은 빼기 기호 (-) 를 부동소수점 리터럴의 앞에 붙여서 표현된다. 예. `-42.5`

언더스코어 (`_`) 는 가독성을 위해 숫자 사이에서 허용되지만 무시되므로 리터럴의 값에 영향을 주지 않는다. 부동소수점 리터럴은 `0`으로 시작할 수 있으나 무시되며 리터럴의 진법이나 값에 영향을 주지 않는다.

달리 지정하지 않는다면, Swift 표준 라이브러리에서 부동소수점 리터럴의 기본 추론 타입은 `Double`이며, 64비트 부동소수점 숫자를 나타낸다. Swift 표준 라이브러리는 또한 32비트 부동소수점 숫자를 나타내는 `Float` 타입도 정의한다.

### 문자열 리터럴

문자열 리터럴은 따옴표에 둘러싸인 일련의 문자들이다. 단일 라인 문자열 리터럴은 큰따옴표에 둘러싸여 있으며 다음의 형식을 갖는다.

```swift
"{characters}"
```

문자열 리터럴은 탈출 처리되지 않은 큰따옴표 (`"`), 탈출 처리되지 않은 백슬래시 (`\`), 캐리지 리턴, 또는 라인 피드를 포함할 수 없다.

다중 라인 문자열 리터럴은 세 개의 큰따옴표로 둘러싸여 있으며 다음의 형식을 갖는다.

```swift
"""
{characters}
"""
```

단일 라인 문자열 리터럴과 달리, 다중 라인 문자열 리터럴은 탈출처리되지 않은 큰따옴표 (`"`), 캐리지 리턴, 그리고 라인 피드를 포함할 수 있다. 각각의 다음에 탈출 처리되지 않은 세 개의 큰따옴표를 포함할 수 없다.

다중 라인 문자열 리터럴을 시작하는 `"""` 다음에 오는 개행은 문자열의 일부분이 아니다. 리터럴을 끝내는 `"""` 이전의 개행 또한 문자열의 일부분이 아니다. 라인 피드와 함께 시작하거나 끝나는 다중 라인 문자열 리터럴을 만들기 위해, 첫 번째 또는 마지막 라인으로 공백 라인을 작성하라.

다중 라인 문자열 리터럴은 스페이스와 탭의 조합을 사용하여 들여쓰기 될 수 있다; 이 들여쓰기는 문자열에 포함되지 않는다. 리터럴 끝에 있는 `"""`은 들여쓰기를 결정한다: 리터럴에서 공백이 아닌 모든 라인은 `"""`으로 닫히기 전에 정확히 같은 들여쓰기로 시작해야 한다; 탭과 스페이스 간 변환은 없다. 들여쓰기 후에 추가적으로 스페이스와 탭을 포함할 수 있다; 그러한 스페이스와 탭은 문자열에 나타난다.

다중 라인 문자열 리터럴에 있는 개행은 라인 피드 문자를 사용하도록 일반화된다. 소스 파일이 캐리지 리턴과 라인 피드의 혼합으로 이루어져 있을지라도, 문자열에서 모든 개행은 같을 것이다.

다중 라인 문자열 리터럴에서, 라인 끝에서 백슬래시 (`\`) 를 작성하여 문자열에서 개행을 생략할 수 있다. 백슬래시와 개행 사이에 있는 어떠한 공백이라도 또한 생략된다. 이 신택스를 사용하면 결과 문자열의 값을 변경하지 않고 소스 코드에서 다중 라인 문자열 리터럴을 하드 래핑 할 수 있다.

특별한 문자들은 다음의 탈출 시퀀스를 사용하여 단일 라인 및 다중 라인 형식의 문자열 리터럴에서 포함될 수 있다.

- 널 문자 (`\0`)
- 백슬래시 (`\\`)
- 수평 탭 (`\t`)
- 라인 피드 (`\n`)
- 캐리지 리턴 (`\r`)
- 큰따옴표 (`"`)
- 작은따옴표 (`'`)
- 유니코드 스칼라 (`\u{n}`), `n`은 하나에서 여덟 개 까지의 숫자들을 갖는 16진수 숫자

표현식의 값은 백슬래시 (`\`) 이후의 소괄호 안에 표현식을 두어 문자열 리터럴에 삽입될 수 있다. 보간된 표현식은 문자열 리터럴을 포함할 수 있으나, 탈출 처리되지 않은 백슬래시, 캐리지 리턴, 또는 라인 피드를 포함할 수 없다.

예를 들어, 다음의 모든 문자열 리터럴들은 같은 값을 갖는다.

```swift
"1 2 3"
"1 2 \("3")"
"1 2 \(3)"
"1 2 \(1 + 2)"
let x = 3; "1 2 \(x)"
```

확장된 분리 문자에 의해 구분된 문자열은 따옴표로 둘러싸인 일련의 문자들이며, 하나 이상의 숫자 기호 (`#`) 으로 균형을 이룬다. 확장된 분리 문자에 의해 구분된 문자열은 다음의 형식을 갖는다.

```swift
#"{characters}"#
```

```swift
#"""
{characters}
"""#
```

확장된 분리 문자에 의해 구분된 문자열 내의 특별한 문자들은 결과 문자열에서 특별한 문자 대신에 일반적인 문자의 형태로 나타난다. 확장된 구분 기호를 사용하여 일반적으로 문자열 보간 생성, 탈출 시퀀스 시작 또는 문자열 종료와 같은 특수 효과가 있는 문자로 문자열을 만들 수 있다.

다음의 예시는 문자열 리터럴과 확장된 분리 문자에 의해 구분된 문자열을 나타내며, 동일한 문자열 값을 만든다.

```swift
let string = #"\(x) \ " \u{2603}"#
let escaped = "\\(x) \\ \" \\u{2603}"
print(string)
// "\(x) \ " \u{2603}"
print(string == escaped)
// true
```

확장된 분리 문자에 의해 구분된 문자열을 만들기 위해 한 개 이상의 숫자 기호를 사용한다면, 숫자 기호 사이에 공백을 둘 수 없다.

```swift
print(###"Line 1\###nLine 2"###) // OK
print(# # #"Line 1\# # #nLine 2"# # #) // Error
```

확장된 분리 문자를 사용하여 만든 다중 라인 문자열 리터럴은 일반적인 다중 라인 문자열 리터럴과 같은 들여쓰기 요구 조건을 갖는다.

문자열 리터럴의 기본 추론 타입은 `String`이다.

`+` 연산자로 이어 붙여진 문자열 리터럴은 컴파일 타임에 이어 붙여진다. 예를 들어 아래의 예제의 `textA`와 `textB` 값들은 동일하다. 런타임에서는 연결이 일어나지 않는다.

```swift
let textA = "Hello " + "world"
let textB = "Hello world"
```

## 연산자

Swift 표준 라이브러리는 사용을 위해 여러 연산자를 정의한다. 현재 섹션에서는 어떤 문자가 커스텀 연산자를 정의하기 위해 사용될 수 있는지에 대해 기술한다.

커스텀 연산자는 아스키 문자 `/`, `=`, `-`, `+`, `!`, `*`, `%`, `<`, `>`, `&`, `|`, `^`, `?`, `~` 중 하나 또는 아래의 문법에서 정의된 유니코드 문자 (*Mathematical Operators, Miscallaneous Symbols, Dingbats* 유니코드 블록 등) 중 하나로 시작할 수 있다. 첫 번째 문자 이후에 유니코드 문자를 결합하는 것 또한 허용된다.

점 (`.`) 으로 시작하는 커스텀 연산자도 정의할 수 있다. 이러한 연산자는 추가적인 점들을 포함할 수 있다. 예를 들어, `.+.`는 단일 연산자로 취급된다. 연산자가 점으로 시작하지 않는다면, 어느 곳에서도 점을 포함할 수 없다. 예를 들어, `+.+`는 `+` 연산자 다음에 `.+` 연산자가 온 것으로 취급된다.

물음표 (`?`) 를 포함한 커스텀 연산자를 정의할 수 있을지라도, 하나의 물음표 만으로는 구성할 없다. 추가적으로, 연산자가 느낌표 (`!`) 를 포함할 수 있을지라도, 후위 연산자는 물음표 또는 느낌표로 시작할 수 없다.

- 알아두기

  `=`, `->`, `//`, `/*`, `*/`, `.` 토큰들과 전위 연산자 `<`, `&`, `?`, 중위 연산자 `?`, 후위 연산자 `>`, `!`, `?`는 예약되었다. 이러한 토큰들은 오버로딩될 수 없고, 커스텀 연산자로도 사용될 수 없다.

연산자 주변의 공백은 연산자가 전위 연산자로 사용될지, 후위 연산자로 사용될지, 또는 이항 연산자로 사용될지 결정하기 위해 사용된다. 이 동작은 다음의 규칙으로 요약된다.

- 연산자가 양 쪽에 공백을 가지고 있거나, 양 쪽에 공백을 가지고 있지 않다면, 이항 연산자로 취급된다. 예를 들어, `a+++b`와 `a +++ b`에서의 `+++` 연산자는 이항 연산자로 취급된다.
- 연산자가 오직 왼쪽에만 공백을 가지고 있다면, 전위 단항 연산자로 취급된다. 예를 들어, `a +++b`에서의 `+++` 연산자는 전위 단항 연산자로 취급된다.
- 연산자가 오직 오른쪽에만 공백을 가지고 있다면, 후위 단항 연산자로 취급된다. 예를 들어, `a+++ b`에서의 `+++` 연산자는 후위 단항 연산자로 취급된다.
- 연산자가 왼쪽에 공백을 가지지 않지만 점 (`.`) 바로 뒤에 온다면, 후위 단항 연산자로 취급된다. 예를 들어, `a+++.b`에서의 `+++` 연산자는 후위 단항 연산자로 취급된다 (`a +++ .b`가 아니라 `a+++ .b`).

이러한 규칙의 목적을 위해, 연산자 이전의 `(`, `[`, `{`와 연산자 이후의 `)`, `]`, `}`, 그리고 `,`, `;`, `:` 문자들 또한 공백으로 간주된다.

위의 규칙들에는 한 가지 경고가 있다. 사전 정의된 연산자인 `!`나 `?`가 왼쪽에 공백을 가지고 있지 않다면, 오른쪽에 공백을 가지고 있는지에 상관 없이 후위 연산자로 취급된다. 옵셔널 체이닝 연산자로 `?`를 사용하려면 왼쪽에 공백이 없어야 한다. 삼항 조건 (`? :`) 연산자를 사용하려면 양 쪽에 공백이 있어야 한다.

특정 구조에서, `<`나 `>`가 앞에 오는 연산자는 두 개 이상의 토큰으로 분리될 수 있다. 나머지는 같은 방식으로 취급되고 다시 분리된다. 결과적으로 `Dictionary<String, Array<Int>>`와 같은 구조에서 닫는 `>` 문자들 사이에 모호함을 없애기 위해 공백을 사용할 필요가 없다. 이 예시에서, 닫는 `>` 문자는 단일 토큰으로 취급되지 않아서 비트 시프트 연산자 `>>`로 잘못 번역되지 않게 된다.