# 연산자

## 사용자 정의 연산자

토큰으로 사용되는 `=, ->, //, /*, */` 등과 전위 연산자 `<, &, ?`, 중위 연산자 `?`, 후위 연산자 `>, !, ?` 등은 Swift에서 예약한 상태이므로 재정의할 수 없으며 사용자 정의 연산자로 사용될 수 앖다.

### 전위 연산자 정의와 구현

```swift
prefix operator **
prefix func **(value: Int) -> Int {
    return value * value
}
```

### 후위 연산자 정의와 구현

```swift
postfix operator **
postfix func **(value: Int) -> Int {
    return value * value
}
```

### 중위 연산자 정의와 구현

중위 연산자는 우선순위 그룹*precedenceGroup*을 명시해줄 수 있음

```swift
precedenceGroup 우선순위_그룹_이름 {
    higherThan: 더_낮은_우선순위_그룹_이름
    lowerThan: 더_높은_우선순위_그룹_이름
    associativity: 결합방향(left / right / none)
    assignment: 할당방향_사용(true / false)
}
```

Swift에 정의된 우선순위 그룹이 있음.

```swift
infix operator **: MultiplicationPrecedence
func **(lhs: String, rhs: String) -> Bool {
    return lhs.contains(rhs)
}
```

# 함수

## 종료되지 않는 함수

비반환 함수(메소드)는 반환 타입을 `Never`로 명시해준다.

```swift
func crash() -> Never {
    fatalError("CRASH!")
}
crash()	// 프로세스 종료 후 오류 보고
```

# 옵셔널

- **옵셔널은 열거형으로 구현되어 있음!** 그러므로 `switch`문으로 `some`과 `none`인 케이스에 접근할 수 있으나 일반적을 옵셔널 바인딩 등의 방법을 활용한다.
- 함수의 매개 변수 타입이 옵셔널이면, 매개 변수 기본값이 `nil`이 아니어도 함수 호출 시 그 부분에 아무런 값을 주지 않아도 `nil`이 들어올 것임을 알아야 한다.

# 구조체와 클래스

### 구조체를 사용해야 하나? 클래스를 사용해야 하나?

다음의 조건 중 하나 이상에 해당된다면 구조체를 사용하는 것을 권장한다.

- 연관된 간단한 값의 집합을 캡슐화하는 것만이 목적일 때
- 캡슐화한 값을 참조하는 것보다 복사하는 것이 합당할 때
- 구조체에 저장된 프로퍼티가 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때
- 다른 타입으로부터 상속받거나 자신을 상속할 필요가 없을 때

# 프로퍼티와 메소드

### 지연 저장 프로퍼티

- 지연 저장 프로퍼티*lazy stored property*는 호출이 있어야 값을 초기화하며, 주로 복잡한 클래스나 구조체를 구현할 때 많이 사용된다.
  - 다중 스레드 환경에서 지연 저장 프로퍼티에 동시다발적으로 접근할 때 한 번만 초기화된다는 보장이 없다.

### 키 경로

- 키 경로*keyPath*를 활용하여 어떤 프로퍼티의 위치만 참조할 수 있도록 할 수 있다. 키 경로를 사용하여 간접적으로 특정 타입의 어떤 프로퍼티 값을 가리켜야 할지 미리 지정해두고 사용할 수 있다.

- 각 인스턴스의 `KeyPath` 서브스크립트 메소드에 키 경로를 전달하여 프로퍼티에 접근할 수 있다.
- 키 경로를 잘 활용하면 타입 간의 의존성을 낮추는 데 많은 도움을 준다.
- 키 경로는 타입 외부로 공개된 **인스턴스 프로퍼티**에 한하여 표현할 수 있다.

```swift
class Person {
    var name: String
    init(name: String) {
        self.name = name
    }
}
let person = Person(name: "presto")
let keyPath = \Person.name
person[keyPath: keyPath]	// Presto
```

### self 프로퍼티

- 인스턴스 메소드에서는 `self`가 인스턴스를 가리키지만, 타입 메소드에서는 `self`가 타입 그 자체를 가리킨다.
- `self` 프로퍼티를 활용하여 값 타입 인스턴스 자체의 값을 치환할 수 있다.
  - 클래스의 인스턴스는 참조 타입이므로 `self` 프로퍼티에 다른 참조를 할당할 수 없다.

```swift
struct Level {
    var level: Int = 0
    mutating func levelUp() {
        level += 1
    }
    mutating func reset() {
        self = Level()
    }
}
```

### 타입 메소드

`static` 키워드를 사용하여 정의할 수 있으며, 상속 후 메소드 정의를 가능하게 하려면 `class` 키워드를 사용하여 정의한다.

# 접근 제어

설정자만 더 낮은 접근 수준을 갖도록 제한할 수 있다.

```swift
public struct SomeType {
    // 저장 프로퍼티의 접근 수준 다르게 하기. 설정자는 비공개 접근수준, 접근자는 공개 접근수준.
    public private(set) var property: Int = 0
    // 서브스크립트의 접근 수준 다르게 하기. 설정자는 내부 접근수준, 접근자는 공개 접근수준.
    public internal(set) subscript(some: Int) -> Int {
        get { return property }
        set { property += some }
    }
    // 저장 프로퍼티도 같은 방법으로 구현할 수 있다.
}
```

# 클로저

**클로저는 참조 타입.** Swift에서 클래스와 클로저는 참조 타입. 나머지는 값 타입.

## 자동 클로저

- 자동 클로저는 전달 인자를 갖지 않는다.
- 자동 클로저는 호출되었을 때 자신이 감싸고 있는 코드의 결과값을 반환한다.
- 자동 클로저는 클로저가 호출되기 전까지 클로저 내부의 코드가 동작하지 않으므로 연산을 지연시킬 수 있다.
- 자동 클로저 속성을 부여한 매개변수는 클로저 대신에 **실행 결과 타입을 전달인자로 받게 되며**, 이것이 자동 클로저 매개변수에 전달되면 **매개변수가 없는 결과 값의 타입을 반환하는 클로저**로 변환해준다.

```swift
var strings = ["a", "b", "c"]
func first(_ function: @autoclosure () -> String) {
    function()
}
first(strings.removeFirst())
// strigns.removeFirst()의 결과인 a가 전달인자로 들어가며, String 값을 반환하는 매개변수가 없는 클로저로 변환해준다.
```

# 옵셔널 체이닝과 빠른종료

## 빠른종료

- `guard`문의 조건에는 `Bool` 타입이 오므로, 옵셔널 바인딩의 역할을 하지 않을 때도 빠른 종료를 위해 사용할 수 있다.
- 쉼표를 사용하여 추가 조건을 나열할 수 있으므로, AND 연산과 같은 결과를 낸다.
- 제어문 전환 명령어를 사용해야 하므로 특정 블록 내부에 위치하지 않는다면 사용이 제한된다.

# 맵, 필터, 리듀스

Swift는 함수를 일급 객체로 취급. 그러므로 함수를 다른 함수의 전달 인자로 사용할 수 있음.

**고차함수** : 매개 변수로 함수를 갖는 함수

## 맵

**자신을 호출할 때 매개변수로 전달된 함수를 실행하여 그 결과를 다시 반환해주는 함수**

`Sequence`, `Collection` 프로토콜을 준수하는 타입과 옵셔널은 맵을 사용할 수 있음

기존 데이터를 변형하는 데 많이 사용함

`for-in` 구문과 비교하여 코드 재사용 측면과 컴파일러 최적화 측면에서 유리하며, 다중 스레드 환경에서 사이드 이펙트를 방지할 수 있다.

## 필터

**컨테이너 내부의 값을 걸러서 추출하는 역할을 하는 고차함수**

특정 조건에 맞게 걸러내는 역할을 할 수 있음. 전달되는 함수 객체의 반환값이 `Bool`이므로 필터링될 조건에 대해 서술함

## 리듀스

**컨테이너 내부의 컨텐츠를 하나로 합하는 기능을 실행하는 고차함수**

적절하게 활용하면 코드의 양을 줄이면서, 보기 좋은 코드를 작성할 수 있음.

# 모나드

특정한 상태로 값을 포장. Swift에서는 옵셔널이 모나드를 구현한 형태. 값이 있을지 없을지 모르는 상태 속에 포장.

## 컨텍스트

**컨텐츠를 담은 어떤 것**

```swift
// Swift의 옵셔널 타입 정의
public enum Optional<Wrapped>: ExpressibleByNilLiteral {
    case none
    case some(Wrapped)
}
```

옵셔널에 값이 있다면 열거형의 `.some` 케이스의 값을 갖게 됨, 값이 없다면 열거형의 `.none` 케이스 값을 갖게 됨

옵셔널을 추출한다는 것은 `.some` 케이스의 연관 값을 꺼내오는 것

**옵셔널은 `some`과 `none` 두 가지의 컨텍스트를 가짐**

- 컨텍스트는 2라는 값을 가지고 있다 : `some` 컨텍스트
- 컨텍스트는 존재하지만 내부에 값이 없다 : `none` 컨텍스트

## 함수객체

**`map` 함수를 적용할 수 있는 컨테이너 타입.** `Array`, `Dictionary`, `Set` 등등 많은 컬렉션 타입은 함수객체임.

```swift
extension Optional {
    func map<U>(f: (Wrapped) -> U) -> U? {
        switch self {
            case .some(let x): return f(x)
            case .none: return .none
        }
    }
}
```

옵셔널에 `map` 함수를 호출하면, `some` 컨텍스트인지 `none` 컨텍스트인지 확인함

- `some` 컨텍스트이면 컨텍스트에 들어있는 컨텐츠를 가지고 인자로 전달된 함수를 수행한 후 컨텍스트에 다시 포장하여 반환
- `none` 컨텍스트이면 `none` 컨텍스트를 반환

## 모나드

**값이 있을 수도 있고 없을 수도 있는 컨텍스트를 갖는 함수객체 타입**

**옵셔널(모나드)**에서의 `flatMap`

- `func flatMap<U>(_ transform: (Wrapped) throws -> U?) rethrows -> U?`

  - `Optional` 인스턴스가 `nil`이 아닐 때 주어진 클로저를 평가하는데, 매개변수로 래핑되지 않은 값을 넘긴다.

  - 내부의 값을 알아서 더 추출해주어 내부에 포장된 값도 추출해낼 수 있다

  - ```swift
    let a: Int? = 3
    let b = a.map { Optional($0) }
    let c = a.flatMap { Optional($0) }
    print(b)	// Optional(Optional(3))
    print(c)	// Optional(3)
    ```

  - `map`에서 `U == Int?` 이므로 결과의 타입은 `Int??`임

  - `flatMap`에서 `U? == Int?` 이므로 결과의 타입은 `Int?`임

시퀀스에서의 `flatMap`

- `func flatMap<SegmentOfResult>(_ transform: (Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence`
  - 시퀀스의 각 요소에 주어진 변형을 호출하여 이어진 결과를 포함하는 배열을 반환
  - [[1, 2], [3, 4]]에 호출하여 [1, 2, 3, 4] 와 같이 만들 수 있는 메소드. 내부의 값을 1차원적으로 펼쳐놓음
- `func flatMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]`
  - 시퀀스의 각 요소에 주어진 변형을 호출하여 `nil`이 아닌 결과를 포함하는 배열을 반환
  - ["1", "2", nil, "5"]에 호출하여 [1, 2, 5]와 같이 만들 수 있는 메소드
  - Swift 4.1에서 `compactMap`으로 이름이 바뀜

**옵셔널 체이닝, 옵셔널 바인딩, 플랫맵 등은 모나드와 관련된 연산**

어렵다...

# 서브스크립트

**클래스, 구조체, 열거형에서 컬렉션, 리스트, 시퀀스 등 타입 요소에 접근하는 단축 문법**

별도의 설정자, 접근자를 구현하지 않아도 **인덱스**를 통해 값을 설정하거나 접근할 수 있음

- 인덱스라고 해서 반드시 `Int` 타입인 것은 아님. 어떤 타입이든 사용 가능

여러 개의 서브스크립트 정의 가능 / 다른 타입을 인덱스로 갖는 여러 개의 서브스크립트 중복 정의 가능

```swift
subscript(_ index: Int) -> Int {
    get {
        // 적절한 서브스크립트 결과값 반환
    }
    set(newValue) {
        // 적절한 설정자 역할 수행
    }
}
```

`newValue`의 타입은 서브스크립트의 반환 타입과 동일하다.

읽기 전용 서브스크립트를 정의하려면 `get` 키워드만 사용하여 정의하거나 키워드를 사용하지 않고 정의하면 된다.

인스턴스의 이름 뒤에 대괄호로 감싼 값을 써주어 사용한다. 값은 서브스크립트의 매개 변수에 정의한 타입을 가져야 한다.

# 상속

**클래스는 메소드나 프로퍼티를 다른 클래스로부터 상속받을 수 있다.**

상속받은 메소드나 프로퍼티, 서브스크립트 등을 재정의하는 것 또한 가능하다.

상속받은 프로퍼티에 프로퍼티 감시자를 구현할 수 있다. 그것이 연산 프로퍼티든 저장 프로퍼티든.

기반 클래스 : 다른 클래스로부터 상속받지 않은 클래스

## 클래스 상속

수직적. 기반클래스를 다른 클래스에서 물려받는 것

다른 클래스를 상속받으면 똑같은 기능을 구현하기 위하여 코드를 다시 작성할 필요가 없어 **코드를 재사용하기 용이**하고 더불어 기능을 확장할 때 기존 클래스를 변경하지 않고도 새로운 추가 기능을 정의할 수 있다.

자식클래스는 부모클래스의 모든 특성(인스턴스 메소드, 타입 메소드, 인스턴스 프로퍼티, 타입 프로퍼티, 서브스크립트 등)을 포함하면서 추가적인 기능을 구현할 수 있다.

이를 위해 클래스 디자인을 초기에 잘 하는 것이 좋겠지만… 그것이 힘들다면 리팩토링이라도 잘 하는게 중요하겠다.

## 재정의

`super` 키워드를 사용하여 부모 클래스의 특성에 접근할 수 있다.

- 타입 메소드 내에서 부모 클래스의 타입 프로퍼티와 타입 메소드에 접근 가능
- 인스턴스 메소드 내에서 부모 클래스의 인스턴스 프로퍼티와 인스턴스 메소드, 서브스크립트에 접근 가능
  - `super.메소드_이름()`
  - `super.프로퍼티_이름`
  - `super[index]`

#### 프로퍼티 재정의

프로퍼티 자체를 재정의하는 것이 아님

프로퍼티의 접근자, 설정자, 프로퍼티 감시자 등을 재정의하는 것을 의미한다.

- 그러므로 저장 프로퍼티로 재정의할 수는 없다.

프로퍼티를 상속받은 자식클래스에서는 조상클래스의 프로퍼티의 이름과 타입만을 알 뿐, 종류(저장, 연산 등)은 알지 못하므로 재정의할 수 있는 것.

읽기 쓰기 모두 가능했던 연산 프로퍼티를 읽기 전용 프로퍼티로 재정의할 수 없다.

- 읽기 전용 프로퍼티를 읽고 쓰기 모두 가능한 프로퍼티로 재정의할 수 있다.
- 읽기 쓰기 모두 가능한 프로퍼티의 설정자만 따로 재정의할 수 없다. 접근자와 설정자를 모두 재정의 해주어야 하며, 이 경우 접근자에서 특별한 기능 변경이 없다면 `super.프로퍼티_이름`을 반환해주면 된다.

### 프로퍼티 감시자 재정의

조상클래스에 정의한 프로퍼티가 연산 프로퍼티인지 저장 프로퍼티인지는 상관 없다.

- 상수 저장 프로퍼티, 읽기 전용 연산 프로퍼티의 경우 프로퍼티 감시자 재정의가 불가능하다.
  - 상수 저장 프로퍼티는 값이 바뀔 일이 없음
  - 읽기 전용 연산 프로퍼티는 설정자가 없으므로 값을 설정할 수 없음

프로퍼티 감시자를 재정의하더라도 조상클래스에 정의한 프로퍼티 감시자도 동작한다.

프로퍼티의 접근자와 프로퍼티 감시자는 동시에 재정의할 수 없으며, 재정의하는 접근자에 프로퍼티 감시자 역할을 구현해야 한다.

### 서브스크립트 재정의

서브스크립트도 매개변수와 반환형이 다르면 다른 서브스크립트로 취급되므로 자식클래스에서 재정의하려는 서브스크립트는 부모클래스의 서브스크립트의 매개변수와 반환타입과 같아야 한다.

다만 자동완성이 안되는 것에 주의하자.

### 재정의 방지

`final` 키워드를 명시하여 재정의를 할 수 없도록 제한할 수 있다.

- `final class 클래스명`과 같이 정의된 클래스는 상속되거나 재정의될 수 없다.

## 클래스의 이니셜라이저 - 상속과 재정의

값 타입의 이니셜라이저는 상속을 고려할 필요가 없었으나 클래스는 상속이 가능하므로 상속받았을 때 이니셜라이저를 어떻게 재정의하는지도 중요하다.

두 종류의 이니셜라이저가 존재하고, 다양한 패턴의 이니셜라이저가 생길 수 있어 클래스 디자인에 더 많은 고민이 필요하다.

### 지정 이니셜라이저와 편의 이니셜라이저

**지정 이니셜라이저**

- 주요 이니셜라이저. 일반적인 의미의 이니셜라이저
- 이니셜라이저가 정의된 클래스의 모든 프로퍼티를 초기화해야함
- 클래스에 하나 이상 정의함
- 조상클래스에 정의된 지정 이니셜라이저가 자손클래스의 지정 이니셜라이저 역할을 충분히 해낸다면 자손클래스는 지정 이니셜라이저를 갖지 않을 수 있음
  - 자손클래스에서 새로 선언한 프로퍼티가 옵셔널 타입일 때 등의 경우

**편의 이니셜라이저**

- `convenience` 키워드를 `init` 앞에 명시하여 편의 이니셜라이저 정의
- 초기화를 좀 더 쉽게 할 수 있도록 도와주는 역할
- 지정 이니셜라이저를 내부에서 호출
  - 부모클래스의 이니셜라이저를 호출할 수 없음
- 클래스 설계자의 의도대로 외부에서 사용하길 원하거나 인스턴스 생성 코드를 작성하는 수고를 덜 때 유용하게 사용 가능

### 클래스의 초기화 위임

- 자식클래스의 **지정 이니셜라이저**는 부모클래스의 **지정 이니셜라이저**를 반드시 호출해야 한다.
- **편의 이니셜라이저**는 자신을 정의한 클래스의 다른 **이니셜라이저**를 반드시 호출해야 한다.
- **편의 이니셜라이저**는 궁극적으로는 **지정 이니셜라이저**를 반드시 호출해야 한다.

> 어떤 이니셜라이저는 지정 이니셜라이저에게 초기화를 반드시 위임한다.
>
> 편의 이니셜라이저는 어떤 이니셜라이저에게 초기화를 반드시 위임한다.

개념적으로 이해하자.

### 2단계 초기화

Swift에서 클래스 초기화는 2단계로 이루어진다.

- 프로퍼티를 초기화하기 전에 프로퍼티 값에 접근하는 것을 막아 초기화를 안전하게 할 수 있게 함
- 다른 이니셜라이저가 프로퍼티의 값을 변경하는 것을 방지함

**안전확인**

- 자식클래스의 지정 이니셜라이저가 부모클래스의 이니셜라이저를 호출하기 전에 자신의 프로퍼티를 모두 초기화했는지 확인
- 자식클래스의 지정 이니셜라이저는 상속받은 프로퍼티에 값을 할당하기 전에 반드시 부모클래스의 이니셜라이저를 호출해야 함
  - 부모클래스의 이니셜라이저가 부모클래스의 프로퍼티 값을 초기화할 가능성이 있음
- 편의 이니셜라이저는 자신의 클래스에 정의한 프로퍼티를 포함하여 그 어떤 프로퍼티라도 값을 할당하기 전에 다른 이니셜라이저를 호출해야 함
  - 클래스 내에 있는 다른 이니셜라이저가 프로퍼티 값을 초기화할 가능성이 있음
- 초기화 1단계를 마치기 전까지 이니셜라이저는 인스턴스 메소드를 호출할 수 없음. 인스턴스 프로퍼티의 값을 읽어들일 수도없음. `self` 프로퍼티를 자신의 인스턴스를 나타내는 값으로 활용할 수 없음

클래스의 인스턴스는 초기화 1단계를 마치기 전에는 유효하지 않다. 1단계를 마쳐야 비로소 유효한 인스턴스가 된다.

**1단계**

1. 클래스가 지정 또는 편의 이니셜라이저를 호출함
2. 해당 클래스의 새로운 인스턴스를 위한 메모리가 할당됨. 그 메모리는 아직 초기화되지 않은 상태
3. 지정 이니셜라이저는 클래스에 정의된 모든 저장 프로퍼티에 값이 있는지 확인. 현재 클래스 부분까지의 저장 프로퍼티를 위한 메모리가 초기화됨
4. 지정 이니셜라이저는 부모클래스의 이니셜라이저가 같은 동작을 행할 수 있도록 초기화를 양도함
5. 부모클래스

**2단계**