# 연산자

## 사용자 정의 연산자

토큰으로 사용되는 `=, ->, //, /*, */` 등과 전위 연산자 `<, &, ?`, 중위 연산자 `?`, 후위 연산자 `>, !, ?` 등은 Swift에서 예약한 상태이므로 재정의할 수 없으며 사용자 정의 연산자로 사용될 수 앖다.

### 전위 연산자 정의와 구현

```swift
prefix operator **
prefix func **(value: Int) -> Int {
    return value * value
}
```

### 후위 연산자 정의와 구현

```swift
postfix operator **
postfix func **(value: Int) -> Int {
    return value * value
}
```

### 중위 연산자 정의와 구현

중위 연산자는 우선순위 그룹*precedenceGroup*을 명시해줄 수 있음

```swift
precedenceGroup 우선순위_그룹_이름 {
    higherThan: 더_낮은_우선순위_그룹_이름
    lowerThan: 더_높은_우선순위_그룹_이름
    associativity: 결합방향(left / right / none)
    assignment: 할당방향_사용(true / false)
}
```

Swift에 정의된 우선순위 그룹이 있음.

```swift
infix operator **: MultiplicationPrecedence
func **(lhs: String, rhs: String) -> Bool {
    return lhs.contains(rhs)
}
```

# 함수

## 종료되지 않는 함수

비반환 함수(메소드)는 반환 타입을 `Never`로 명시해준다.

```swift
func crash() -> Never {
    fatalError("CRASH!")
}
crash()	// 프로세스 종료 후 오류 보고
```

# 옵셔널

- **옵셔널은 열거형으로 구현되어 있음!** 그러므로 `switch`문으로 `some`과 `none`인 케이스에 접근할 수 있으나 일반적을 옵셔널 바인딩 등의 방법을 활용한다.
- 함수의 매개 변수 타입이 옵셔널이면, 매개 변수 기본값이 `nil`이 아니어도 함수 호출 시 그 부분에 아무런 값을 주지 않아도 `nil`이 들어올 것임을 알아야 한다.

# 구조체와 클래스

### 구조체를 사용해야 하나? 클래스를 사용해야 하나?

다음의 조건 중 하나 이상에 해당된다면 구조체를 사용하는 것을 권장한다.

- 연관된 간단한 값의 집합을 캡슐화하는 것만이 목적일 때
- 캡슐화한 값을 참조하는 것보다 복사하는 것이 합당할 때
- 구조체에 저장된 프로퍼티가 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때
- 다른 타입으로부터 상속받거나 자신을 상속할 필요가 없을 때

# 프로퍼티와 메소드

### 지연 저장 프로퍼티

- 지연 저장 프로퍼티*lazy stored property*는 호출이 있어야 값을 초기화하며, 주로 복잡한 클래스나 구조체를 구현할 때 많이 사용된다.
  - 다중 스레드 환경에서 지연 저장 프로퍼티에 동시다발적으로 접근할 때 한 번만 초기화된다는 보장이 없다.

### 키 경로

- 키 경로*keyPath*를 활용하여 어떤 프로퍼티의 위치만 참조할 수 있도록 할 수 있다. 키 경로를 사용하여 간접적으로 특정 타입의 어떤 프로퍼티 값을 가리켜야 할지 미리 지정해두고 사용할 수 있다.

- 각 인스턴스의 `KeyPath` 서브스크립트 메소드에 키 경로를 전달하여 프로퍼티에 접근할 수 있다.
- 키 경로를 잘 활용하면 타입 간의 의존성을 낮추는 데 많은 도움을 준다.
- 키 경로는 타입 외부로 공개된 **인스턴스 프로퍼티**에 한하여 표현할 수 있다.

```swift
class Person {
    var name: String
    init(name: String) {
        self.name = name
    }
}
let person = Person(name: "presto")
let keyPath = \Person.name
person[keyPath: keyPath]	// Presto
```

### self 프로퍼티

- 인스턴스 메소드에서는 `self`가 인스턴스를 가리키지만, 타입 메소드에서는 `self`가 타입 그 자체를 가리킨다.
- `self` 프로퍼티를 활용하여 값 타입 인스턴스 자체의 값을 치환할 수 있다.
  - 클래스의 인스턴스는 참조 타입이므로 `self` 프로퍼티에 다른 참조를 할당할 수 없다.

```swift
struct Level {
    var level: Int = 0
    mutating func levelUp() {
        level += 1
    }
    mutating func reset() {
        self = Level()
    }
}
```

### 타입 메소드

`static` 키워드를 사용하여 정의할 수 있으며, 상속 후 메소드 정의를 가능하게 하려면 `class` 키워드를 사용하여 정의한다.

# 접근 제어

설정자만 더 낮은 접근 수준을 갖도록 제한할 수 있다.

```swift
public struct SomeType {
    // 저장 프로퍼티의 접근 수준 다르게 하기. 설정자는 비공개 접근수준, 접근자는 공개 접근수준.
    public private(set) var property: Int = 0
    // 서브스크립트의 접근 수준 다르게 하기. 설정자는 내부 접근수준, 접근자는 공개 접근수준.
    public internal(set) subscript(some: Int) -> Int {
        get { return property }
        set { property += some }
    }
    // 저장 프로퍼티도 같은 방법으로 구현할 수 있다.
}
```

# 클로저

**클로저는 참조 타입.** Swift에서 클래스와 클로저는 참조 타입. 나머지는 값 타입.

## 자동 클로저

- 자동 클로저는 전달 인자를 갖지 않는다.
- 자동 클로저는 호출되었을 때 자신이 감싸고 있는 코드의 결과값을 반환한다.
- 자동 클로저는 클로저가 호출되기 전까지 클로저 내부의 코드가 동작하지 않으므로 연산을 지연시킬 수 있다.
- 자동 클로저 속성을 부여한 매개변수는 클로저 대신에 **실행 결과 타입을 전달인자로 받게 되며**, 이것이 자동 클로저 매개변수에 전달되면 **매개변수가 없는 결과 값의 타입을 반환하는 클로저**로 변환해준다.

```swift
var strings = ["a", "b", "c"]
func first(_ function: @autoclosure () -> String) {
    function()
}
first(strings.removeFirst())
// strigns.removeFirst()의 결과인 a가 전달인자로 들어가며, String 값을 반환하는 매개변수가 없는 클로저로 변환해준다.
```

# 옵셔널 체이닝과 빠른종료

## 빠른종료

- `guard`문의 조건에는 `Bool` 타입이 오므로, 옵셔널 바인딩의 역할을 하지 않을 때도 빠른 종료를 위해 사용할 수 있다.
- 쉼표를 사용하여 추가 조건을 나열할 수 있으므로, AND 연산과 같은 결과를 낸다.
- 제어문 전환 명령어를 사용해야 하므로 특정 블록 내부에 위치하지 않는다면 사용이 제한된다.

# 맵, 필터, 리듀스

Swift는 함수를 일급 객체로 취급. 그러므로 함수를 다른 함수의 전달 인자로 사용할 수 있음.

**고차함수** : 매개 변수로 함수를 갖는 함수

## 맵

**자신을 호출할 때 매개변수로 전달된 함수를 실행하여 그 결과를 다시 반환해주는 함수**

`Sequence`, `Collection` 프로토콜을 준수하는 타입과 옵셔널은 맵을 사용할 수 있음

기존 데이터를 변형하는 데 많이 사용함

`for-in` 구문과 비교하여 코드 재사용 측면과 컴파일러 최적화 측면에서 유리하며, 다중 스레드 환경에서 사이드 이펙트를 방지할 수 있다.

## 필터

**컨테이너 내부의 값을 걸러서 추출하는 역할을 하는 고차함수**

특정 조건에 맞게 걸러내는 역할을 할 수 있음. 전달되는 함수 객체의 반환값이 `Bool`이므로 필터링될 조건에 대해 서술함

## 리듀스

**컨테이너 내부의 컨텐츠를 하나로 합하는 기능을 실행하는 고차함수**

적절하게 활용하면 코드의 양을 줄이면서, 보기 좋은 코드를 작성할 수 있음.

# 모나드

특정한 상태로 값을 포장. Swift에서는 옵셔널이 모나드를 구현한 형태. 값이 있을지 없을지 모르는 상태 속에 포장.

## 컨텍스트

**컨텐츠를 담은 어떤 것**

```swift
// Swift의 옵셔널 타입 정의
public enum Optional<Wrapped>: ExpressibleByNilLiteral {
    case none
    case some(Wrapped)
}
```

옵셔널에 값이 있다면 열거형의 `.some` 케이스의 값을 갖게 됨, 값이 없다면 열거형의 `.none` 케이스 값을 갖게 됨

옵셔널을 추출한다는 것은 `.some` 케이스의 연관 값을 꺼내오는 것

**옵셔널은 `some`과 `none` 두 가지의 컨텍스트를 가짐**

- 컨텍스트는 2라는 값을 가지고 있다 : `some` 컨텍스트
- 컨텍스트는 존재하지만 내부에 값이 없다 : `none` 컨텍스트

## 함수객체

**`map` 함수를 적용할 수 있는 컨테이너 타입.** `Array`, `Dictionary`, `Set` 등등 많은 컬렉션 타입은 함수객체임.

```swift
extension Optional {
    func map<U>(f: (Wrapped) -> U) -> U? {
        switch self {
            case .some(let x): return f(x)
            case .none: return .none
        }
    }
}
```

옵셔널에 `map` 함수를 호출하면, `some` 컨텍스트인지 `none` 컨텍스트인지 확인함

- `some` 컨텍스트이면 컨텍스트에 들어있는 컨텐츠를 가지고 인자로 전달된 함수를 수행한 후 컨텍스트에 다시 포장하여 반환
- `none` 컨텍스트이면 `none` 컨텍스트를 반환

## 모나드

**값이 있을 수도 있고 없을 수도 있는 컨텍스트를 갖는 함수객체 타입**

**옵셔널(모나드)**에서의 `flatMap`

- `func flatMap<U>(_ transform: (Wrapped) throws -> U?) rethrows -> U?`

  - `Optional` 인스턴스가 `nil`이 아닐 때 주어진 클로저를 평가하는데, 매개변수로 래핑되지 않은 값을 넘긴다.

  - 내부의 값을 알아서 더 추출해주어 내부에 포장된 값도 추출해낼 수 있다

  - ```swift
    let a: Int? = 3
    let b = a.map { Optional($0) }
    let c = a.flatMap { Optional($0) }
    print(b)	// Optional(Optional(3))
    print(c)	// Optional(3)
    ```

  - `map`에서 `U == Int?` 이므로 결과의 타입은 `Int??`임

  - `flatMap`에서 `U? == Int?` 이므로 결과의 타입은 `Int?`임

시퀀스에서의 `flatMap`

- `func flatMap<SegmentOfResult>(_ transform: (Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence`
  - 시퀀스의 각 요소에 주어진 변형을 호출하여 이어진 결과를 포함하는 배열을 반환
  - [[1, 2], [3, 4]]에 호출하여 [1, 2, 3, 4] 와 같이 만들 수 있는 메소드. 내부의 값을 1차원적으로 펼쳐놓음
- `func flatMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]`
  - 시퀀스의 각 요소에 주어진 변형을 호출하여 `nil`이 아닌 결과를 포함하는 배열을 반환
  - ["1", "2", nil, "5"]에 호출하여 [1, 2, 5]와 같이 만들 수 있는 메소드
  - Swift 4.1에서 `compactMap`으로 이름이 바뀜

**옵셔널 체이닝, 옵셔널 바인딩, 플랫맵 등은 모나드와 관련된 연산**

어렵다...

# 서브스크립트

**클래스, 구조체, 열거형에서 컬렉션, 리스트, 시퀀스 등 타입 요소에 접근하는 단축 문법**

별도의 설정자, 접근자를 구현하지 않아도 **인덱스**를 통해 값을 설정하거나 접근할 수 있음

- 인덱스라고 해서 반드시 `Int` 타입인 것은 아님. 어떤 타입이든 사용 가능

여러 개의 서브스크립트 정의 가능 / 다른 타입을 인덱스로 갖는 여러 개의 서브스크립트 중복 정의 가능

```swift
subscript(_ index: Int) -> Int {
    get {
        // 적절한 서브스크립트 결과값 반환
    }
    set(newValue) {
        // 적절한 설정자 역할 수행
    }
}
```

`newValue`의 타입은 서브스크립트의 반환 타입과 동일하다.

읽기 전용 서브스크립트를 정의하려면 `get` 키워드만 사용하여 정의하거나 키워드를 사용하지 않고 정의하면 된다.

인스턴스의 이름 뒤에 대괄호로 감싼 값을 써주어 사용한다. 값은 서브스크립트의 매개 변수에 정의한 타입을 가져야 한다.

# 상속

**클래스는 메소드나 프로퍼티를 다른 클래스로부터 상속받을 수 있다.**

상속받은 메소드나 프로퍼티, 서브스크립트 등을 재정의하는 것 또한 가능하다.