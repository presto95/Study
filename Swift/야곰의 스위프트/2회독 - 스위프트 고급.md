# 타입 중첩

타입 내부에 타입을 정의하고 구현할 수 있으며, 이렇게 구현된 타입을 중첩 타입이라고 함

- 클래스나 구조체 내부에서 자신의 역할을 구분짓고 자신의 내부에서만 사용 가능하게 할 수 있음
- 득정 데이터 타입들을 하나의 클래스나 구조체에 구현하여 외부와의 혼선을 피할 수 있음

타입의 목적성을 명확히 하는 데 도움을 줄 수 있음

# 패턴

이러이러한 것을 표현하고 싶다면 이러이러한 패턴을 통해 표현하면 된다.

대부분의 패턴은 `switch`, `if`, `guard`, `for` 등의 키워드가 두 개 이상 합을 이뤄 동작하며, `switch` 구문에서 강력한 힘을 발휘함

`case`를 사용하는 패턴은 `case` 뒤에 패턴이 위치함

- 값을 해체(추출)하거나 무시하는 패턴
  - 와일드카드 / 식별자 / 값 바인딩 / 튜플 패턴
- 패턴 매칭을 위한 패턴
  - 열거형 케이스 / 옵셔널 / 표현 / 타입캐스팅 패턴

## 와일드카드 패턴

**와일드카드 식별자 `_`를 사용하여 이 자리에 무엇이 오든 상관 없음을 나타냄.** 와일드카드 식별자가 위치한 곳의 값은 무시됨

```swift
for _ in 0...2 {
    print("HO")
}
let info = ("presto", 24, 0)
switch info {
    case (_, 24, _): print(info)
    case (_, _, _): print("~~")
}
```

## 식별자 패턴

**변수 또는 상수의 이름에 알맞는 값을 어떤 값과 매치시키는 패턴**

```swift
let value: Int = 42
```

`value`의 타입인 `Int`와 할당하려는 값인 `42`의 타입이 매치된다면 `value`는 `42`라는 값의 식별자가 되므로 식별자 패턴이 성립함

`42`라는 값을 `value`라는 상수로 식별함

값 바인딩 패턴의 일종

## 값 바인딩 패턴

**변수 또는 상수의 이름에 매치된 값을 바인딩**

식별자 패턴은 매칭되는 값을 새로운 이름의 변수 또는 상수에 바인딩하는 것

- 튜플의 요소를 해체하여 그에 대응하는 식별자 패턴에 각각의 요소를 바인딩

```swift
let info = ("presto", 24, true)
switch info {
    // 다음과 같은 형식으로 튜플의 요소을 해체하여 대응하는 식별자 패턴에 각 요소를 바인딩할 수 있음
    case let (nickname, age, isMale): print(nickname, age, isMale)
    case (let nickname, let age, let isMale): print(nickname, age, isMale)
    case (let nickname, _, let isMale): print(nickname, isMale)
}
```

## 튜플 패턴

**소괄호 내에 쉼표로 분리하는 리스트.** 그에 상응하는 튜플 타입과 값을 매치함

```swift
let (x, y): (Int, Int) = (2, 3)
print(x, y)
let name = "presto"
let age = 24
let isMale = true
switch (name, age, isMale) {
    // name, age isMale이 이에 상응하는 튜플 타입과 값이 매치됨
    case ("presto", _, _): print(1)
    case (_, _, true): print(2)
}
let points: [(Int, Int)] = [(0, 0), (0, 1)]
// points의 요소와 (x, y)가 매치됨
for (x, y) in points {
    print(x, y)
}
```

## 열거형 케이스 패턴

**값을 열거형 타입의 `case`와 매치시킴**

`switch` 구문의 `case` 레이블 / `if`, `while`, `guard`, `for-in` 구문의 `case` 조건에서 볼 수 있음

연관 값이 있는 열거형 케이스와 매치하려고 한다면 열거형 케이스 패턴에는 반드시 튜플 패턴이 함께해야 함

```swift
let someValue = 30
// if (0...100).contains(someValue)
if case 0...100 = someValue {
    print("0 <= \(someValue) <= 100")
}
let anotherValue = "ABC"
// if "ABC" == anotherValue
if case "ABC" = anotherValue {
    print(anotherValue)
}
```

## 옵셔널 패턴

**옵셔널*Optional* 또는 암시적 추출 옵셔널*ImplicitlyUnwrappedOptional* 열거형에 감싸져 있는 값을 매치시킬 때 사용**

식별자 패턴 뒤에 **물음표**를 넣어 표기하며 열거형 케이스 패턴과 동일한 위치에 자리함

- 옵셔널은 열거형으로 구현되어 있음

```swift
public enum Optional<Wrapped>: ExpressibleByNilLiteral {
    case none
    case some(Wrapped)
}
```

```swift
let optional: Int? = 100
// if let value = optional
if case .some(let value) = optional {
    print(value)	// 100
}
// if let value = optional
if case let value? = optional {
    print(value)	// 100
}
func hasValue(_ optional: Int?) -> Bool {
    // guard case let value? = optional else { return false }
    // guard let value = optional else { return false }
    guard case .some(let value) = optional else { return false }
    return true
}
let numbers = [1, nil, 4, 6, nil]
// 옵셔널 저장하는 배열의 `for-in` 구문을 통한 순환에서 `nil`이 아닌 값을 찾는 데 유용하게 사용됨
for case let number? in numbers {
    print(number, terminator: " ")
}
// 1 4 6
```

## 타입캐스팅 패턴

**타입캐스팅을 하거나 타입을 매치시킴**

`is` 패턴은 `is 타입_이름`과 같이 작성하여 값의 타입이 `is` 우측에 작성된 타입 또는 그 타입의 자식클래스 타입이면 값과 매치시킴

`as` 패턴은 `패턴 as 타입_이름`과 같이 작성하여 값의 타입이 `as` 우측에 작성된 타입 또는 그 타입의 자식클래스 타입이면 값과 매치시키고, 매치된 값의 타입은 `as` 패턴이 원하는 타입으로 캐스팅됨 

```swift
let value: Any = 100
switch value {
    case is String: print("It is String")
    case let value as Int: print(value)
    default: break
}
// 100
```

## 표현 패턴

**표현식의 값을 평가한 결과를 이용**

`switch` 구문의 `case` 레이블에서만 사용 가능

Swift 표준 라이브러리의 패턴 연산자인 `~=` 연산자의 반환값이 `true`이면 매치시킴

- 같은 타입의 두 값을 비교할 때 `~=` 연산자는 `==` 연산자를 사용함

연산자를 중복 정의하거나 재정의, 또는 자신이 만든 타입에 `~=` 연산자를 구현해주어 자신이 원하는대로 패턴을 완성시킬 수 있음

`~=` 연산자 재정의 또는 중복 정의하기

- 첫 번째 인자에 `case` 레이블에 작성될 패턴이 위치함

- 두 번째 인자에 `switch`문의 조건에 작성될 값이 위치함

- ```swift
  func ~=(pattern: String, value: Person) -> Bool {
      return pattern == value.name
  }
  ```

- 패턴 자체가 함수일 수도 있음. `case` 레이블에 이전에 정의한 함수 이름을 작성할 수 있음. 함수의 인자로 `switch`문의 조건에 작성된 값이 들어가 최종적으로 반환된 `Bool` 값으로 패턴 매칭을 판별함

# where 절

**특정 패턴과 결합하여 조건을 추가**

## where 절의 활용

- 패턴과 결합하여 조건 추가 : 특정 패턴에 `Bool` 타입 조건 지정

- 타입에 대한 제약 추가 : 어떤 타입의 특정 프로토콜 준수 조건 추가

- ```swift
  // 옵셔널 패턴에서 `where`절 사용하기
  let array: [Int?] = [nil, 2, 3, nil, 5]
  for case let number? in array where number > 2 {
      print(number)
  }
  // 3
  // 5
  // 값 바인딩 패턴, 타입캐스팅 패턴 등 다양한 패턴과 조합하여 사용 가능
  ```

프로토콜 익스텐션에 `where`절을 사용하여 해당 익스텐션이 특정 프로토콜을 준수하는 타입에만 적용될 수 있도록 제약을 줄 수 있음

- ```swift
  // SelfPrintable 프로토콜을 준수하는 타입 중 Container 프로토콜도 준수하는 타입에만 해당 익스텐션이 적용
  extension SelfPrintable where Self: Container
  ```

- 여러 프로토콜을 제시하려면 쉼표로 구분해줌

타입 매개변수와 연관 타입의 제약을 추가하는 데 `where`절을 사용할 수 있음

```swift
func doubled<T>(value: T) -> T where T: BinaryInteger {
    return value * 2
}
// 위의 표현과 아래의 표현 같음
func doubled<T: BinaryInteger>(value: T) -> T {
    return value * 2
}
```

```swift
func compareTwoSequences<S1, S2>(a: S1, b: S2) where S1: Sequence, S2: Sequence, S1.SubSequence: Equatable, S1.SubSequence == S2.SubSequence { ... }
// 위의 표현과 아래의 표현 같음
func compareTwoSequences<S1: Sequence, S2: Sequence>(a: S1, b: S2) where S1.SubSequence: Equatable, S1.SubSequence == S2.Iterator.Element { ... }
```

```swift
protocol Container {
    associatedtype ItemType where ItemType == BinaryInteger
    ...
}
// 위의 표현과 아래의 표현 같음
protocol Container where ItemType == BinaryInteger {
    associatedtype ItemType
    ...
}
```

`where`절을 다른 패턴과 조합하여 원하는 추가 요구사항을 자유롭게 더할 수 있음. 익스텐션과 제네릭에 사용하여 프로토콜 또는 타입에 대한 제약을 추가할 수 있음.

조건문이나 논리 연산으로 구현한 코드보다 훨씬 더 명확하고 간편하게 사용할 수 있다.

# ARC

Automatic Reference Counting

Swift는 프로그램의 메모리 사용을 관리하기 위해 ARC라는 메모리 관리 기법을 사용함

참조 타입인 클래스의 인스턴스에만 적용되는 개념

## ARC란

GC와의 차이

- 컴파일 시 참조 카운팅
  - 컴파일 시 인스턴스의 해제 시점이 결정되어 인스턴스가 언제 메모리에서 해제될지 예측할 수 있음
  - 메모리 관리를 위한 추가적인 시스템 자원이 불필요함

**ARC의 작동 규칙을 모르고 사용하면 인스턴스가 메모리에서 영원히 해제되지 않을 가능성이 있음.**

- 클래스의 인스턴스를 생성할 때마다 ARC는 그 인스턴스에 대한 정보를 저장하기 위한 메모리 공간을 따로 또 할당함
- 그 공간에는 인스턴스의 타입 정보와 함께 그 인스턴스와 관련된 저장 프로퍼티의 값 등을 저장함
- 인스턴스가 더이상 필요 없는 상태가 되면 인스턴스가 차지하던 메모리 공간을 다른 용도로 활용할 수 있도록 ARC가 메모리에서 인스턴스를 없앰
- 인스턴스가 지속해서 필요한 상황에서 ARC는 인스턴스가 메모리에서 해제되지 않도록 인스턴스 참조 여부를 계속 추적함
  - 다른 인스턴스의 프로퍼티나 변수, 상수 등이 어느 한 곳에서 인스턴스를 참조한다면 ARC가 해당 인스턴스를 해제하지 않고 유지해야 하는 명분이 됨

## 강한참조

**인스턴스가 계속해서 메모리에 남아있어야 하는 명분을 만들어 주는 것**

인스턴스는 참조 횟수가 0이 되는 순간 메모리에서 해제됨

강한참조를 사용하여 인스턴스를 다른 인스턴스의 프로퍼티나 변수, 상수 등에 할당하면 참조 횟수가 1 증가함

강한참조를 사용하는 프로퍼티, 변수, 상수 등에 nil을 할당해주면 원래 자신에게 할당되어 있던 인스턴스의 참조 횟수가 1 감소함

기본적으로 강한참조함

강한참조 지역변수(상수)가 사용된 범위의 코드 실행이 종료되면 그 지역변수(상수)가 참조하던 인스턴스의 참조 횟수가 1 감소함

## 강한참조 순환 문제

인스턴스가 서로가 서로를 강한참조함. 변수가 참조하던 클래스의 인스턴스에 접근할 방법이 없으나 인스턴스는 해제되지 않은 채 메모리에 존재하여 메모리 누수가 발생함

## 약한참조

자신이 참조하는 인스턴스의 참조 횟수를 증가시키지 않음

`weak` 키워드를 참조 타입의 프로퍼티나 변수의 선언 앞에 명시하면 그 프로퍼티나 변수는 자신이 참조하는 인스턴스를 약한참조함

자신이 참조하던 인스턴스가 메모리에서 해제된다면 `nil`이 할당될 수 있으므로 옵셔널 변수만 약한참조를 할 수 있음

## 미소유참조

약한참조와 마찬가지로 인스턴스의 참조 횟수를 증가시키지 않음

`unowned` 키워드를 참조 타입의 프로퍼티나 변수의 선언 앞에 명시하면 그 프로퍼티나 변수는 자신이 참조하는 인스턴스를 미소유참조함

자신이 참조하는 인스턴스가 항상 메모리에 존재할 것이라는 전제를 기반으로 동작하며, 자신이 참조하는 인스턴스가 메모리에서 해제되더라도 `nil`을 할당해주지 않음. 그러므로 옵셔널 변수가 아니어도 미소유참조를 사용할 수 있음

미소유참조를 하면서 메모리에서 해제된 인스턴스에 접근하려 할 때 런타임 에러가 발생함