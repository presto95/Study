# 타입 중첩

타입 내부에 타입을 정의하고 구현할 수 있으며, 이렇게 구현된 타입을 중첩 타입이라고 함

- 클래스나 구조체 내부에서 자신의 역할을 구분짓고 자신의 내부에서만 사용 가능하게 할 수 있음
- 득정 데이터 타입들을 하나의 클래스나 구조체에 구현하여 외부와의 혼선을 피할 수 있음

타입의 목적성을 명확히 하는 데 도움을 줄 수 있음

# 패턴

이러이러한 것을 표현하고 싶다면 이러이러한 패턴을 통해 표현하면 된다.

대부분의 패턴은 `switch`, `if`, `guard`, `for` 등의 키워드가 두 개 이상 합을 이뤄 동작하며, `switch` 구문에서 강력한 힘을 발휘함

`case`를 사용하는 패턴은 `case` 뒤에 패턴이 위치함

- 값을 해체(추출)하거나 무시하는 패턴
  - 와일드카드 / 식별자 / 값 바인딩 / 튜플 패턴
- 패턴 매칭을 위한 패턴
  - 열거형 케이스 / 옵셔널 / 표현 / 타입캐스팅 패턴

## 와일드카드 패턴

**와일드카드 식별자 `_`를 사용하여 이 자리에 무엇이 오든 상관 없음을 나타냄.** 와일드카드 식별자가 위치한 곳의 값은 무시됨

```swift
for _ in 0...2 {
    print("HO")
}
let info = ("presto", 24, 0)
switch info {
    case (_, 24, _): print(info)
    case (_, _, _): print("~~")
}
```

## 식별자 패턴

**변수 또는 상수의 이름에 알맞는 값을 어떤 값과 매치시키는 패턴**

```swift
let value: Int = 42
```

`value`의 타입인 `Int`와 할당하려는 값인 `42`의 타입이 매치된다면 `value`는 `42`라는 값의 식별자가 되므로 식별자 패턴이 성립함

`42`라는 값을 `value`라는 상수로 식별함

값 바인딩 패턴의 일종

## 값 바인딩 패턴

**변수 또는 상수의 이름에 매치된 값을 바인딩**

식별자 패턴은 매칭되는 값을 새로운 이름의 변수 또는 상수에 바인딩하는 것

- 튜플의 요소를 해체하여 그에 대응하는 식별자 패턴에 각각의 요소를 바인딩

```swift
let info = ("presto", 24, true)
switch info {
    // 다음과 같은 형식으로 튜플의 요소을 해체하여 대응하는 식별자 패턴에 각 요소를 바인딩할 수 있음
    case let (nickname, age, isMale): print(nickname, age, isMale)
    case (let nickname, let age, let isMale): print(nickname, age, isMale)
    case (let nickname, _, let isMale): print(nickname, isMale)
}
```

## 튜플 패턴

**소괄호 내에 쉼표로 분리하는 리스트.** 그에 상응하는 튜플 타입과 값을 매치함

```swift
let (x, y): (Int, Int) = (2, 3)
print(x, y)
let name = "presto"
let age = 24
let isMale = true
switch (name, age, isMale) {
    // name, age isMale이 이에 상응하는 튜플 타입과 값이 매치됨
    case ("presto", _, _): print(1)
    case (_, _, true): print(2)
}
let points: [(Int, Int)] = [(0, 0), (0, 1)]
// points의 요소와 (x, y)가 매치됨
for (x, y) in points {
    print(x, y)
}
```

## 열거형 케이스 패턴

**값을 열거형 타입의 `case`와 매치시킴**

`switch` 구문의 `case` 레이블 / `if`, `while`, `guard`, `for-in` 구문의 `case` 조건에서 볼 수 있음

연관 값이 있는 열거형 케이스와 매치하려고 한다면 열거형 케이스 패턴에는 반드시 튜플 패턴이 함께해야 함

```swift
let someValue = 30
// if (0...100).contains(someValue)
if case 0...100 = someValue {
    print("0 <= \(someValue) <= 100")
}
let anotherValue = "ABC"
// if "ABC" == anotherValue
if case "ABC" = anotherValue {
    print(anotherValue)
}
```

## 옵셔널 패턴

**옵셔널*Optional* 또는 암시적 추출 옵셔널*ImplicitlyUnwrappedOptional* 열거형에 감싸져 있는 값을 매치시킬 때 사용**

식별자 패턴 뒤에 **물음표**를 넣어 표기하며 열거형 케이스 패턴과 동일한 위치에 자리함

- 옵셔널은 열거형으로 구현되어 있음

```swift
public enum Optional<Wrapped>: ExpressibleByNilLiteral {
    case none
    case some(Wrapped)
}
```

```swift
let optional: Int? = 100
// if let value = optional
if case .some(let value) = optional {
    print(value)	// 100
}
// if let value = optional
if case let value? = optional {
    print(value)	// 100
}
func hasValue(_ optional: Int?) -> Bool {
    // guard case let value? = optional else { return false }
    // guard let value = optional else { return false }
    guard case .some(let value) = optional else { return false }
    return true
}
let numbers = [1, nil, 4, 6, nil]
// 옵셔널 저장하는 배열의 `for-in` 구문을 통한 순환에서 `nil`이 아닌 값을 찾는 데 유용하게 사용됨
for case let number? in numbers {
    print(number, terminator: " ")
}
// 1 4 6
```

## 타입캐스팅 패턴

**타입캐스팅을 하거나 타입을 매치시킴**

`is` 패턴은 `is 타입_이름`과 같이 작성하여 값의 타입이 `is` 우측에 작성된 타입 또는 그 타입의 자식클래스 타입이면 값과 매치시킴

`as` 패턴은 `패턴 as 타입_이름`과 같이 작성하여 값의 타입이 `as` 우측에 작성된 타입 또는 그 타입의 자식클래스 타입이면 값과 매치시키고, 매치된 값의 타입은 `as` 패턴이 원하는 타입으로 캐스팅됨 

```swift
let value: Any = 100
switch value {
    case is String: print("It is String")
    case let value as Int: print(value)
    default: break
}
// 100
```

## 표현 패턴

**표현식의 값을 평가한 결과를 이용**

`switch` 구문의 `case` 레이블에서만 사용 가능

Swift 표준 라이브러리의 패턴 연산자인 `~=` 연산자의 반환값이 `true`이면 매치시킴

- 같은 타입의 두 값을 비교할 때 `~=` 연산자는 `==` 연산자를 사용함

연산자를 중복 정의하거나 재정의, 또는 자신이 만든 타입에 `~=` 연산자를 구현해주어 자신이 원하는대로 패턴을 완성시킬 수 있음

`~=` 연산자 재정의 또는 중복 정의하기

- 첫 번째 인자에 `case` 레이블에 작성될 패턴이 위치함

- 두 번째 인자에 `switch`문의 조건에 작성될 값이 위치함

- ```swift
  func ~=(pattern: String, value: Person) -> Bool {
      return pattern == value.name
  }
  ```

- 패턴 자체가 함수일 수도 있음. `case` 레이블에 이전에 정의한 함수 이름을 작성할 수 있음. 함수의 인자로 `switch`문의 조건에 작성된 값이 들어가 최종적으로 반환된 `Bool` 값으로 패턴 매칭을 판별함

