# Swift 3에서의 전체 모듈 최적화(Whole-Module Optimization)

전체 모듈 최적화는 Swift 컴파일러의 최적화 모드다. 전체 모듈 최적화가 얻어내는 성능적 이점은 전적으로 프로젝트에 달려 있으나, 두 배, 심지어 다섯 배까지 좋아질 수 있다.

전체 모듈 최적화는 `-whole-module-optimization` (또는 `-wmo`) 컴파일러 플래그로 활성화할 수 있으며, Xcode 8에서 이것은 새로운 프로젝트에 대해서 기본적으로 설정되어 있다. 또한 Swift Package Manager는 릴리즈 빌드에 대해서 전체 모듈 최적화를 사용하여 컴파일한다.

그래서 이것은 무엇인가? 먼저 전체 모듈 최적화를 하지 않고 컴파일러가 동작하는 방법을 알아보자.

## 모듈들, 그리고 그것들을 컴파일하는 방법

모듈은 Swift 파일들의 집합이다. 각각의 모듈은 단일 배포 단위(프레임워크 또는 실행 파일)로 컴파일된다. 단일 파일 컴파일*single-file compilation*(`-wmo` 설정 안됨)에서 Swift 컴파일러는 모듈에 있는 각각의 파일에 대하여 개별적으로 컴파일한다. 실제로 이는 이면에서 일어나는 일이다. 당신은 사용자로서 이것을 직접 할 필요가 없다. 이는 컴파일러 드라이버나 Xcode 빌드 시스템에 의해서 자동으로 수행된다.

```text
                ----------
file_1.swift -> | swiftc | -> file_1.o --\
                ----------                \
                ----------                 \  ------
file_2.swift -> | swiftc | -> file.2_o -----> | ld | -> binary
                ----------                 /  ------
                ----------                /
file_n.swift -> | swiftc | -> file.n_o --/
                ----------
```

소스 파일을 읽고 파싱한 후(그리고 타입 검사와 같은 몇 가지 다른 작업을 수행한 후) 컴파일러는 Swift 코드를 최적화하고, 기계어를 생성하고 오브젝트 파일을 작성한다. 마지막으로 링커는 모든 오브젝트 파일을 조합하고 공유 라이브러리나 실행 파일을 생성한다.

단일 파일 컴파일에서 컴파일러 최적화의 스코프는 단지 단일 파일일 뿐이다. 이는 함수 인라이닝*function inlining*이나 제네릭 특수화*generic specialization*와 같은 함수 교차 최적화*cross-function optimizations*를 같은 파일에서 호출되고 정의된 함수들로 제한한다.

예제를 살펴보자. 모듈에 utils.swift라는 하나의 파일만 있다고 가정하자. 이는 제네릭 유틸리티 자료구조 `Container<T>`를 포함하고, `getElement` 메소드를 가지고 있으며, 이 메소드는 모듈 곳곳에서 호출된다.

```swift
// main.swift
func add(c1: Container<Int>, c2: Container<Int>) -> Int {
  return c1.getElement() + c2.getElement()
}

// utils.swift
struct Container<T> {
  var element: T
  
  func getElement() -> T {
    return element
  }
}
```

컴파일러가 main.swift를 최적화할 때 그것은 `getElement`가 구현된 방법을 알지 못한다. 단지 그것이 존재한다는 것만을 알 뿐이다. 그러므로 컴파일러는 `getElement`에 대한 호출을 생성한다. 한편으로는 컴파일러가 utils.swift를 최적화할 때, 컴파일러는 함수가 호출되는 구체 타입에 대해 알지 못한다. 그러므로 컴파일러는 오직 함수의 제네릭 버전만을 생성할 수 있으며, 이는 구체 타입에 대해 특수화된 코드보다 훨씬 더 느리다.

심지어 `getElement`에 있는 단순한 반환문은 요소를 복사하는 방법을 알아내기 위해 타입의 메타데이터를 찾아야 할 필요가 있다. 이는 단순히 `Int`일 수도 있으나, 더 큰 타입일 수도 있으며, 심지어 참조 카운팅 작업 하는 것을 포함할 수도 있다. 컴파일러는 이러한 것을 알지 못한다.

## 전체 모듈 최적화

전체 모듈 최적화로 컴파일러는 훨씬 더 잘 수행할 수 있다. `-wmo` 옵션과 함께 컴파일할 때, 컴파일러는 모듈에 있는 모든 파일을 전체적으로 최적화한다.

```text
file_1.swift --\   ----------
file_2.swift ----> | swiftc | -> output files
file_n.swift --/   ----------
```

이는 두 개의 큰 이점을 갖는다. 먼저 컴파일러는 모듈에 있는 모든 함수의 구현을 알기 때문에, 함수 인라이닝과 함수 특수화와 같은 최적화를 수행할 수 있다. 함수 특수화는 컴파일러가 특정 호출 컨텍스트에 대해 최적화된 새로운 버전의 함수를 생성한다는 것을 의미한다. 예를 들어 컴파일러는 제네릭 함수를 구체 타입에 대해 특수화할 수 있다.

예제에서 컴파일러는 `Int` 구체 타입에 대해 특수화된 제네릭 `Container`의 한 버전을 생산한다.

```swift
struct Container {
  var element: Int
  
  func getElement() -> Int {
    return element
  }
}
```

그러면 컴파일러는 특수화된 `getElement` 함수를 `add` 함수로 인라이닝할 수 있다.

```swift
func add(c1: Container<Int>, c2: Container<Int>) -> Int {
  // 이전 : c1.getElement() + c2.getElement()
  return c1.element + c2.element
}
```

이것은 단지 몇 개의 기계 명령어로 컴파일된다. 제네릭 `getElement` 함수에서 두 개의 호출을 한 단일 파일 코드와 비교하여 큰 차이가 생겼다.

파일 간 함수 특수화와 인라이닝은 컴파일러가 전체 모듈 최적화로 할 수 있는 최적화들의 예시일 뿐이다. 컴파일러가 함수를 인라이닝하지 않는다고 결정할지라도, 컴파일러가 함수의 구현을 알고 있다면 많은 도움이 된다. 예를 들어 컴파일러는 참조 카운팅 작업과 관련한 행위에 대해 추론할 수 있다. 이러한 지식을 바탕으로 컴파일러는 함수 호출 주위에 있는 중복된 참조 카운팅 작업을 제거할 수 있다.

전체 모듈 최적화의 두 번째 중요한 이점은 컴파일러가 공개 수준이 아닌 함수들의 모든 사용에 대해 추론할 수 있다는 것이다. 공개 수준이 아닌 함수들은 모듈 내에서만 사용 가능하므로, 컴파일러는 이러한 함수의 모든 참조들을 알고 있다고 확신할 수 있다. 컴파일러는 이 정보를 가지고 무엇을 할 수 있을까?

매우 기본적인 최적화 중 하나는 소위 "죽은" 함수와 메소드를 제거하는 것이다. 이들은 절대 호출되지 않거나 사용되지 않는 함수와 메소드다. 전체 모듈 최적화를 통해 컴파일러는 공개 수준이 아닌 함수나 메소드가 전혀 사용되지 않는지, 이러한 경우에 그것을 제거할 수 있는지 알게 된다. 그러면 프로그래머는 왜 전혀 사용되지 않는 함수를 작성하는가? 이것은 죽은 함수의 제거에 대한 가장 중요한 유스케이스가 아니다. 종종 함수들은 다른 최적화의 부작용으로 죽게 된다.

`add` 함수가 `Container.getElement`가 호출되는 유일한 장소라고 가정하자. `getElement`를 인라이닝한 후, 이 함수는 더이상 사용되지 않으므로 제거할 수 있다. 컴파일러가 `getElement`를 인라이닝하지 않기로 결정할지라도, 컴파일러는 `getElement`의 기존 제네릭 버전을 제거할 수 있다. `add` 함수는 오직 특수화된 버전만을 호출하기 때문이다.

## 컴파일 타임

단일 파일 컴파일에서 컴파일러 드라이버는 개별 프로세스에서 각각의 파일에 대한 컴파일을 시작하며, 이것은 병렬적으로 수행될 수 있다. 또한 마지막 컴파일 이래로 수정되지 않은 파일들은 다시 컴파일될 필요가 없다(모든 의존성 또한 수정되지 않았다고 가정한다). 이를 증분 컴파일*incremental compilation*이라고 부른다. 이는 많은 컴파일 타임을 절약하며, 특히 당신이 작은 변경만을 했을 때 그렇다. 이것은 전체 모듈 컴파일에서 어떻게 동작하는가? 컴파일러가 전체 모듈 최적화 모드에서 동작하는 방법을 더 자세하게 알아보자.

```text
                   --------------swiftc--------------|
file_1.swift --\   |                   /---- LLVM  --|-- file_1.o --\    ------
file_2.swift ------|-> SIL optimizer ------- LLVM  --|-- file_2.o -----> | ld | -> binary
file_n.swift --/   |                   \---- LLVM  --|-- file_n.o --/    ------
                   ----------------------------------|
```

내부적으로 컴파일러는 여러 개의 단계(파서, 타입 검사, SIL 최적화, LLVM 백엔드)에서 동작한다.

파싱과 타입 검사는 대부분의 경우에 매우 빠르며, 뒤이은 Swift 릴리즈에서 이는 훨씬 더 빨라질 것이라고 기대된다. SIL 최적화기(SIL은 "Swift Intermediate Language"(Swift 중간 언어)의 약자)는 제네릭 특수화, 함수 인라이닝 등등, 모든 중요한 Swift에 특정한 최적화를 수행한다. 컴파일러의 해당 단계는 일반적으로 전체 컴파일 타임의 3분의 1 정도를 차지한다. 컴파일 타임의 대부분은 LLVM 백엔드에 의해 소비되며, 이는 저수준 최적화를 수행하고 코드 생성을 한다.

SIL 최적화기에서 전체 모듈 최적화를 수행한 후, 모듈은 다시 여러 개의 부분으로 나뉘어진다. LLVM 백엔드는 여러 개의 스레드에서 나뉘어진 부분을 처리한다. 또한 이전 빌드 이래로 변경되지 않은 부분이 있다면 그 부분을 다시 처리하지 않는다. 그러므로 전체 모듈 최적화를 수행할지라도, 컴파일러는 컴파일 작업의 큰 부분을 병렬적으로(멀티쓰레드), 증분으로 수행할 수 있다.

## 결론

전체 모듈 최적화는 Swift 코드를 모듈 내의 파일 간에 분배하는 방법에 대해 걱정할 필요 없이 최대의 퍼포먼스를 낼 수 있도록 하는 훌륭한 방법이다. 위에서 기술된 것처럼, 최적화가 임계 코드 구역*critical code section*에서 일어난다면, 퍼포먼스는 단일 파일 최적화와 비교하여 다섯 배까지 더 나아질 수 있다. 그리고 획일화된 전체 모듈 최적화 접근으로 이러한 높은 퍼포먼스를 훨씬 더 나은 컴파일 타임과 함께 얻을 수 있다.

## 참고

[Whole-Module Optimization in Swift 3](https://swift.org/blog/whole-module-optimizations/)