[http://reactivex.io/intro.html]

# ReactiveX

`ReactiveX`는 `Observable` 시퀀스를 사용하여 비동기 및 이벤트 기반 프로그램을 구성하기 위한 라이브러리다.

이는 옵저버 패턴을 확장하여 데이터 및 이벤트, 데이터 또는 데이터의 시퀀스를 지원하고, 저수준 쓰레딩, 동기화, 쓰레드 안전, 병렬 데이터 구조, 논블로킹 입출력과 같은 것에 대한 관심을 추상화하면서 선언적으로 시퀀스를 함께 구성하게 하는 연산자를 추가한다.

**옵저버블은 많은 아이템의 비동기 시퀀스에 접근하기 위한 이상적인 방법이 되어 그 차이를 채워준다.**

|        | 단일 아이템           | 다중 아이템               |
| ------ | --------------------- | ------------------------- |
| 동기   | `T getData()`         | `Iterable<T> getData()`   |
| 비동기 | `Future<T> getData()` | `Observable<T> getData()` |

이는 때때로 "함수형 리액티브 프로그래밍"이라고 불리지만 잘못된 호칭이다. `ReactiveX`는 함수형일 수 있고, 리액티브할 수 있다. 그러나 "함수형 리액티브 프로그래밍"은 다른 것이다. 한 가지 중요한 차이점은 함수형 리액티브 프로그래밍은 시간이 지나면서 *연속적으로* 변화하는 값에 대한 연산을 수행하는 반면에, `ReactiveX`는 시간이 지나면서 산출되는 *이산적인* 값에 대한 연산을 수행한다는 것이다.

# 왜 Observable을 사용하는가?

`ReactiveX`의 `Observable` 모델은 비동기 이벤트 스트림을 같은 종류의 간단하고 구성 가능한 작업으로 취급할 수 있게 하여 배열처럼 데이터 아이템의 컬렉션으로 사용할 수 있게 한다. 이는 콜백의 그물에서 뒤엉켜지지 않게 하며, 그렇기 때문에 코드의 가독성은 좋아지고 버그가 일어날 가능성을 줄인다.

## Observable은 구성 가능하다

`Java`의 `Future`와 같은 테크닉은 직접적으로 단일 수준의 비동기 실행을 위해 사용된다. 하지만 그것들이 중첩될 때 사소하지 않은 복잡함을 더하기 시작한다.

Future를 사용하여 조건적인 비동기 실행 흐름 구성을 최적화하는 것은 어렵다. 또는 런타임에서 각각의 요청에 대해 지연이 다양하게 일어나므로 불가능하다. 물론 이는 해결 가능하나 빠르게 복잡해지며 에러가 발생하기 쉽다. 또는 `Future.get()` 에서 조기에 차단되므로 비동기 실행의 이점을 없애버린다.

반면에 `ReactiveX` 의 `Observable` 은 비동기 데이터의 흐름과 시퀀스를 구성하기 위해 의도된 것이다.

## Observable은 유연하다

`ReactiveX` 의 `Observable` 은 `Future`가 하는 것과 같이 단일 스칼라 값을 내는 것뿐만 아니라 값의 시퀀스 또는 심지어 무한한 스트림에서의 산출 또한 지원한다. `Observable` 은 이러한 사용 사례들 중 어떠한 경우에도 사용될 수 있는 단일 추상화다. `Observable` 은 그 사촌격인 `Iterable` 과 관련된 모든 유연함과 우아함을 가지고 있다.

 **`Iterable` 이 동기/풀*pull* 이라면, `Observable` 은 비동기/푸시*push* 다.**

| 이벤트      | `Iterable` (pull)  | `Observable` (push)  |
| ----------- | ------------------ | -------------------- |
| 데이터 회수 | `T next()`         | `onNext(T)`          |
| 에러 발견   | throws `Exception` | `onError(Exception)` |
| 완료        | `!hasNext()`       | `onCompleted()`      |

## Observable은 독단적이지 않다

`ReactiveX` 는 병렬성이나 비동기성의 어떠한 특정 소스에 치우치지 않는다. `Observable` 은 쓰레드 풀, 이벤트 루프, 논블로킹 입출력, `Akka` 에서와 같은 *actor*, 또는 당신의 필요, 스타일, 전문성에 맞는 어떠한 구현을 사용하여 구현될 수 있다. 클라이언트 코드는 `Observable` 과 함께 하는 모든 인터렉션을 비동기적으로 취급하며, 기본 구현은 블로킹일 수 있고 논블로킹일 수 있으나 그것을 구현하는 것은 당신의 선택이다.

**이 `Observable` 은 어떻게 구현되는가?**

`public Observable<data> getData();`

- 호출자와 같은 쓰레드에서 동기적으로 동작하는가?
- 개별 쓰레드에서 비동기적으로 동작하는가?
- 여러 개의 쓰레드로 작업을 분산하여 어떠한 순서로 호출자에게 데이터를 반환하는가?
- 쓰레드 풀 대신 `Actor` (또는 다중 `Actor`)를 사용하는가?
- 비동기 네트워크 접근을 하기 위해 이벤트 루프와 함께 NIO(New I/O)를 사용하는가?
- 콜백 쓰레드로부터 작업 쓰레드를 분리시키기 위해 이벤트 루프를 사용하는가?

**`Observer` 의 관점에서 문제될 것은 없다!**

`ReactiveX` 와 함께 당신의 마음은 이후에 변화할 수 있다. 그리고 `Observable` 의 컨슈머를 부수지 않고 급진적으로 당신의 `Observable` 구현 기반에 깔려 있는 본성이 변화하게 된다.

## 콜백은 그 자체로 문제를 가지고 있다

콜백은 차단되는 어떠한 것도 허용하지 않는 것으로 `Future.get()` 에 의한 조기 블로킹 문제를 해결합니다. 이들은 응답이 준비될 때 실행되기 때문에 본질적으로는 능률적입니다.

하지만 `Future` 가 중첩 구성될 때 이들은 다루기 힘들게 됩니다. 콜백은 단일 수준의 비동기 실행에서 사용하기 쉽기 때문입니다.

## ReactiveX는 여러 언어로 구현되었다

`ReactiveX` 는 현재 다양한 언어로 구현되었으며, 각 언어의 특성이 존중되었다. 그리고 많은 언어들이 빠르게 추가되고 있다.

# 리액티브 프로그래밍

`ReactiveX` 는 `Observable` 을 필터, 선택, 변형, 조합, 구성할 수 있는 연산자 컬렉션을 제공한다. 이는 효율적인 실행과 구성을 가능하게 한다.

당신은 `Observable` 클래스를 *pull* 인 `Iterable` 과 동일한 *push* 로 생각할 수 있다. `Iterable` 을 사용하여 컨슈머는 프로듀서로부터 값을 끌어오며 쓰레드는 이 값들이 도착할 때까지 차단된다. 대조적으로, `Observable` 을 사용하여 프로듀서는 값이 사용 가능할 때마다 컨슈머에게 값을 내준다. 이 접근법은 더 유연하다. 값은 동기적 또는 비동기적으로 도착할 수 있기 때문이다.

**예제 코드는 비슷한 고차 함수가 `Iterable` 과 `Observable` 에서 적용될 수 있는 방법을 보여준다.**

- `Iterable`

  ```swift
  getDataFromLocalMemory()
  	.skip(10)
  	.take(5)
  	.map { "\($0) transformed" }
  	.forEach { print("next => \($0)") }
  ```

- `Observable`

  ```swift
  getDataFromNetwork()
  	.skip(10)
  	.take(5)
  	.map { "\($0) transformed" }
  	.subscribe { print("onNext => \($0)") }
  ```

`Observable` 타입은 GoF의 옵저버 패턴에서 빠진 두 가지 의미론을 더하여 `Iterable` 타입에서 사용 가능한 것들과 일치시킨다.

1. 사용 가능한 데이터가 더 이상 없을 때 프로듀서가 컨슈머에게 신호를 보낼 수 있는 능력 (이 경우 `Iterable` 에서는 foreach 루프에서 완료되고 정상적으로 반환한다. `Observable` 에서는 그 옵저버의 `onCompleted` 메소드를 호출한다.)
2. 에러가 발생했을 때 프로듀서가 컨슈머에게 신호를 보낼 수 있는 능력 (이 경우 `Iterable` 에서는 반복 중에 에러가 발생했을 때 예외를 던진다. `Observable` 에서는 그 옵저버의 `onError` 메소드를 호출한다.)

이러한 추가들로 `ReactiveX` 는 `Iterable` 타입과 `Observable` 타입과의 조화를 이루어낸다. 데이터 흐름의 방향이 유일한 차이점이다. 이는 매우 중요하다. 이제 당신이 `Iterable` 에서 수행하던 작업들은 `Observable` 에서도 수행되기 때문이다.