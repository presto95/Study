# 설계 근거

#### Design Rationale

## 에러 타입이 제네릭이 아닌 이유

#### Why error type isn't generic

```swift
enum Event<Element> {
  case next(Element)  // 시퀀스의 다음 요소
  case error(Error)   // 에러와 함께 실패한 시퀀스
  case completed      // 성공적으로 종료된 시퀀스
}
```

`Error` 가 제네릭이 될 때의 장단점에 대해 논의해 봅시다.

에러 타입이 제네릭이면 두 개의 observable 사이에 부가적인 임피던스 불일치가 발생할 것입니다.

`Observable<String, E1>` 과 `Observable<String, E2>` 가 있다고 합시다.

결과 에러 타입이 무엇이 될지 알아내지 않으면 이것들을 가지고 할 수 있는 것은 많지 않습니다.

`E1`, `E2`, 또는 새로운 `E3` 은 무엇이 될까요? 이러한 임피던스 불일치를 해결하기 위한 새로운 오퍼레이터 집합이 필요할 것입니다.

이는 속성 조합을 못하게 하고, Rx는 시퀀스가 실패하는 이유에는 관심이 없습니다. 단지 옵저버블 체인을 따라 실패를 내려줄 뿐입니다.

문제는 더 있습니다. 몇몇 경우에, 오퍼레이터는 어떠한 내부적인 에러로 인해 실패할 수 있습니다. 이러한 경우 결과 에러를 구축하고 실패를 보고하는 것을 할 수 없습니다.

하지만 괜찮습니다. 이런 것들은 무시하고, 에러를 배출하지 않는 시퀀스를 모델링하기 위해 이것을 사용할 수 있다고 가정합시다. 이것이 목적에 잘 맞을까요?

어떠한 명백한 애플리케이션은 전체 UI를 일으키는 UI 레이어에서의 영구적인 스트림을 요구할 것입니다. 이러한 경우를 고려할 때, 시퀀스가 에러를 배출하지 않는다는 것만을 컴파일러가 입증하도록 사용하는 것은 정말 충분하지 않습니다. 다른 속성도 입증할 필요가 있습니다. 예를 들어, 요소들은 `MainScheduler` 에서 관찰되어야 합니다.

정말로 필요한 것은 관찰 가능한 시퀀스를 위한 특성을 입증하는 일반적인 방식입니다. 당신이 관심을 갖는 많은 속성이 있습니다. 예를 들어,

- 시퀀스를 유한한 시간 내에 종료됩니다. (서버 사이드)
- 시퀀스는 오직 하나의 요소만을 포함합니다. (어떠한 계산을 수행 중이라면)
- 시퀀스는 에러를 배출하지 않고, 절대 종료되지 않으며, 요소는 메인 스케줄러에서 전달됩니다. (UI)
- 시퀀스는 에러를 배출하지 않고, 절대 종료되지 않으며, 요소는 메인 스케줄러에서 전달되고, 공유됩니다. (UI)
- 시퀀스는 에러를 배출하지 않고, 절대 종료되지 않으며, 요소는 특정 백그라운드 스케줄러에서 전달됩니다. (오디오 엔진)

정말로 필요한 것은 관찰 가능한 시퀀스를 위한 특성에 대한 일반적인 컴파일러가 강제하는 시스템과 그러한 원하는 속성을 위한 변하지 않는 오퍼레이터 집합입니다.

```text
1, 3.14, e, 2.79, 1 + 1i      <->    Observable<E>
1m/s, 1T, 5kg, 1.3 pounds     <->    Errorless observable, UI observable, Finite observable ...
```

Swift에서 observable의 조합이나 상속을 사용하여 이러한 것을 하기 위한 많은 방법이 있습니다.

단위 시스템을 사용하는 부가적인 이득은 UI 코드가 같은 스케줄러에서 실행되고 있으며 그러므로 모든 변환에 대하여 lock이 없는 오퍼레이터를 사용한다는 것을 입증할 수 있다는 것입니다.

RxSwift는 이미 단일 시퀀스 오퍼레이션에 대하여 lock을 걸지 않기 때문에, 그리고 존재하는 모든 lock은 상태 있는 컴포넌트 (예. UI) 에 존재하기 때문에, RxSwift 코드에는 실제적으로 lock이 없으며, 이는 컴파일러가 강제하는 그러한 세부 사항을 허용합니다.

Rx의 구성 상의 의미를 유지하면서 다른 더욱 명확한 방법으로 얻을 수 없는, 타입 있는 Error를 사용하는 것은 실제로 이점이 없습니다.