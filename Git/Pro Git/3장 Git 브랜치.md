# 3장 Git 브랜치

코드를 통째로 복사하여 원래 코드와는 상관 없이 독립적으로 개발을 진행할 수 있다.

git의 최고 장점, git이 다른 형상 관리 도구와 구분되는 특징

브랜치는 매우 가볍고 빠름. 브랜치를 만들어 나중에 merge하는 방법을 권장함

## 브랜치란 무엇인가

git은 데이터를 change set이나 diff로 기록하지 않고, **일련의 스냅샷**으로 기록한다.

### 커밋의 동작 원리

- 파일을 스테이징할 때, git 저장소에 파일(Blob)을 저장하고 스테이징 에이리어에 해당 파일의 체크섬을 저장함 (SHA-1 활용)
- 현재 스테이징 에이리어에 있는 데이터의 스냅샷에 대한 포인터, 저자/나 커밋 메시지 같은 메타데이터, 이전 커밋에 대한 포인터 등을 포함하는 커밋 오브젝트를 저장함
  - 최초 커밋을 제외한 나머지 커밋은 이전 커밋 포인터가 적어도 하나는 있음
  - 3-way merge를 통해 merge된 커밋은 여러 개의 이전 커밋 포인터를 가질 수 있음
- 각 파일에 대한 Blob / 파일과 디렉토리 구조가 들어 있는 트리 개체 하나 / 메타데이터와 루트 트리를 가리키는 포인터가 담긴 커밋 오브젝트 하나가 생성됨
  - 커밋 오브젝트에 이전 커밋(부모 커밋)의 체크섬이 저장됨

git의 브랜치는 커밋 사이를 가볍게 이동할 수 있는 어떠한 포인터 같은 것일 뿐이다.

### 새 브랜치 생성하기

> ```sh
> git branch [브랜치_이름]
> ```

현재 커밋 위치에서 주어진 브랜치 이름을 갖는 브랜치를 생성한다.

현재 작업 중인 브랜치는 HEAD라는 특수한 포인터가 가리킨다.

`git log` 명령에 `--decorate` 옵션을 사용하면 브랜치가 어떤 커밋을 가리키는지 확인할 수 있다.

### 브랜치 이동하기

> ```sh
> git checkout [브랜치_이름]
> ```

다른 브랜치로 이동하기 위해 사용한다. HEAD는 주어진 브랜치를 가리키게 된다.

`git log --oneline --decorate --graph --all` : 커밋 히스토리를 보기 좋게 출력

git의 브랜치는 실제로는 40글자의 SHA-1 체크섬 파일, 41바이트 파일에 불과하기 때문에 매우 가볍다. 그렇기 때문에 브랜치를 수시로 사용하여 프로젝트의 안정성을 유지하는 것이 좋다.

## 브랜치와 Merge의 기초

**fast-forward merge**

merge하려는 브랜치가 가리키는 커밋과 현재 체크아웃된 브랜치가 가리키는 커밋이 같은 라인에 있을 때 merge를 하게 되면 단순하게 브랜치가 가리키는 커밋의 포인터를 옮기는 것이 된다.

**3-way merge**

merge하려는 브랜치가 가리키는 커밋과 현재 체크카웃된 브랜치가 가리키는 커밋이 같은 라인에 있지 않을 때, 각각의 커밋과 그 커밋들의 공통 조상, 총 세 개의 커밋을 활용하여 merge하게 된다. 커밋들을 모두 가리키는 merge된 커밋이 하나 만들어진다.

### 충돌의 기초

merge하는 두 브랜치에서 같은 파일의 한 부분을 동시에 수정하고 merge한다면 충돌*conflict*이 발생한다.

```text
<<<<<<< HEAD
print(1)
=======
print(2)
>>>>>>> develop
```

`=======` 위쪽의 내용은 `HEAD`, 아래쪽의 내용은 `develop` 브랜치의 것이다. 적절하게 수정하고 자동으로 만들어진 `>>>>>>>`, `=======`, `<<<<<<<` 기호들을 지워준 다음, `git add` 명령을 통해 다시 git에 저장하여 충돌을 해결한다.

이후 `git commit`을 통해 커밋하게 되면, 충돌이 발생한 merge에 대한 커밋 메세지를 작성할 수 있는 템플릿이 자동으로 편집기에 나타나게 된다.

## 브랜치 관리

> ```sh
> git branch
> ```

브랜치의 목록을 확인한다.

`*` 기호가 붙어 있는 브랜치는 현재 체크아웃된 브랜치라는 것을 나타낸다.

**옵션**

- `-d` : 주어진 브랜치를 삭제한다.
  - `-D` : merge하지 않은 브랜치를 강제로 삭제한다.
- `-v` : 브랜치마다 마지막 커밋 메세지도 함께 보여준다.
- `--merged` : merge된 브랜치 목록을 확인한다.
  - `*` 기호가 없는 브랜치는 이미 merge되었으므로 삭제해도 되는 브랜치다.
- `--no-merged` : merge되지 않은 브랜치 목록을 확인한다.

## 브랜치 워크플로우

### Long-Running 브랜치

개발 과정에서 필요한 용도에 따라 브랜치를 만들어 두고 계속 사용하며, 정기적으로 브랜치를 다른 브랜치와 merge한다.

`master` 브랜치에는 배포했거나 배포할 코드만 두도록 한다.

`develop` 브랜치에는 개발을 진행하고 안정화하기 위한 용도로 사용한다.

기타 토픽 브랜치를 사용하여 호흡을 짧게 유지하고, 개발한 기능을 테스트하여 버그가 없어 안정적이면 merge한다.

개발 브랜치는 공격적으로 히스토리를 만들어 나가고, 안정 브랜치는 이미 만든 히스토리를 뒤따르며 나아간다. 안정적인 브랜치일수록 커밋 히스토리가 뒤쳐지게 된다.

### 토픽 브랜치

어떠한 한 가지 주제나 작업을 위해 만든 짧은 호흡의 브랜치.

`hotfix`, `feature-???` 등

## 원격 브랜치

원격 refs : 원격 저장소에 있는 포인터인 레퍼런스. 원격 저장소에 있는 브랜치, 태그 등등

> ```sh
> git ls-remote [원격_브랜치_이름]
> ```

모든 원격 refs를 조회할 수 있다.

> ```sh
> git remote show [원격_브랜치_이름]
> ```

모든 원격 브랜치와 그 정보를 보여준다.

**원격 트래킹 브랜치**

원격 브랜치를 추적하는 브랜치

로컬에 있으나 움직일 수 없음. 원격 서버에 연결할 때마다 원격 브랜치에 따라 자동으로 동기화됨

`origin/master`와 같이 `(원격_저장소_이름)/(원격_브랜치_이름)`의 형식으로 된 이름을 가짐

> ```sh
> git fetch [원격_저장소_이름]
> ```

원격 서버와 로컬의 정보를 동기화한다.

로컬 저장소가 가지고 있지 않은 새로운 정보가 있으면 모두 내려받고, 그 데이터를 로컬 저장소에 업데이트한 후, 원격 트래킹 브랜치가 가리키는 위치를 최신 커밋으로 이동시킨다.

### Push 하기

> ```sh
> git push [원격_저장소_이름] [브랜치_이름]
> git push [원격_저장소_이름] [로컬_브랜치_이름]:[원격_브랜치_이름]
> ```

원격 저장소에 로컬의 브랜치 데이터를 push한다.

### 브랜치 추적

원격 트래킹 브랜치를 로컬 브랜치로 체크아웃하면 자동으로 트래킹 브랜치가 만들어진다.