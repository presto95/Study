# 2장. 메모리 관리

메모리 사용을 최적화하는 과정은 CPU 사용률에 직간접적 영향을 주고, 결과적으로 배터리 소모량에도 영향을 미친다.

효율적으로 메모리를 관리하는 것은 성능에 영향을 주는 아주 중요한 사항이다.

## 2.1. 메모리와 객체

이론적으로 64bit 시스템에서는 2<sup>64</sup>의 크기를 갖는 가상 주소 공간에 접근할 수 있다.

물리 메모리는 위의 프로세스 주소 공간보다 작으므로 가상 메모리 방식을 사용한다. CPU와 메모리 관리 유닛에서 일정한 크기를 가진 페이지 단위로 나누어 메모리를 관리한다.

기본적으로 페이지의 크기는 4KB이다.

가상 메모리 페이지 중에 읽을 데이터가 없어 Page Fault가 발생하면 4KB 단위씩 새로운 페이지를 읽어나가므로 성능에 좋지 않다.

### 2.1.1. 객체 인스턴스 생성

```objective-c
Pen *pen = [[Pen alloc] init];
```

클래스 객체에 `+alloc` 메세지를 보내면 생성할 객체 메타 클래스에 명시된 속성 데이터 타입 크기를 확인하여 힙 메모리를 할당한다.

메모리 할당의 최소 단위는 16Byte이다. (ex. 24Byte 요청시 32Byte 할당)

힙 공간에 생성된 객체 인스턴스에 `-init` 메세지를 보내면 생성자를 호출하여 필요한 초기 값을 설정한다.

객체 인스턴스가 메모리에 할당된 이후, 생성자 메소드가 호출되는 시점부터 객체의 생명주기가 시작된다.

#### 메모리 할당 단위

일반적으로 최신 macOS와 iOS에서는 다음의 메모리 할당 단위를 갖는다.

|단위 명칭|메모리 할당 범위|할당 단위|비고|
|---|---|---|---|
|NANO|1~255Byte|16Byte|macOS에만 해당|
|TINY|256~992Byte|16Byte|
|SMALL|993Byte~127KB|512Byte|
|LARGE|128KB~|4KB|

각 단위의 메모리 조각들이 구분 없이 만들어지면 파편화 현상이 발생하게 된다. 그러므로 실제로는 힙 영역에 각 단위에 대한 영역을 만들고 구분하여 할당된다.

#### 메모리 영역과 가상메모리

`magazine_malloc` 이라는 개념의 magazine 영역은 멀티스레드 환경에서 메모리 할당 영역에 대한 오버헤드를 줄이기 위해 스레드별로 메모리를 관리하는 단위다.

이 때 TINY 단위는 스레드와 상관 없이 최상위 수준에서 생성되고 각 스레드에 할당되는 구조로 동작한다. Objective-C 객체 인스턴스는 TINY의 크기보다 작을 것이라고 가정했기 때문이다.

따라서 객체를 설계할 때 1KB보다 작게 설계하는 것이 권장된다.

힙 공간에는 객체 인스턴스만 존재하는 것이 아니다. 비트맵 이미지나 데이터베이스가 캐싱되기도 한다.

`UIImage` 클래스의 `+imageNamed:` (`init?(named:)`) 메소드를 사용하는 경우 시스템이 내부에 이미지를 캐싱하므로 주의하여 사용해야 한다.

#### 메모리 지역*zone*

같은 zone의 메모리 또는 같은 가상 메모리 페이지에 객체를 할당하면 지역성*localizy*가 좋아져 성능이 향상되곤 했으나 Objective-C 최신 런타임에서는 이러한 것을 관리할 필요가 없어졌다.

현재 zone 관련 메소드는 deprecated되었다.

### 2.1.2. 객체 인스턴스 소멸

Objective-C에서는 객체 인스턴스에 `-release` 메세지를 보내면 해당 객체의 `-dealloc` 메소드를 호출하여 하위 객체를 해제할 수 있도록 도와준다.

Swift의 클래스에도 `-deinit` 메소드가 있으나 ARC를 사용하므로 소멸 시점을 지정할 수 없다.

### 2.1.3. 요약

객체 인스턴스를 메모리에 생성해서 소멸할 때까지의 과정을 메모리 관리 측면에서 이해하면 효율적인 프로그램을 작성할 수 있을 것이다.

이미지나 데이터베이스 캐시를 위해 내부적으로 할당하는 메모리 공간에 대해서도 고려해야 한다.

## 2.2. 참조 계산

특정 객체가 다른 객체를 참조하는 경우, 참조할 객체의 메모리 존재 여부를 판단할 필요가 있다.

이를 위해 애플은 참조 계산*reference counting* 방식을 제공한다.

Cocoa 프레임워크가 제공하는 모든 객체는 참조 카운터 공간을 갖는다. 여기에 해당 객체의 참조 횟수를 계산한 값이 기록된다.

객체가 만들어질 때 참조 횟수는 초기 값 1로 설정되고, 그 객체를 참조하는 다른 객체가 있을 때마다 참조 횟수가 1 증가한다. 참조하던 객체가 더 이상 참조하지 않으면 1 감소한다.

macOS의 옛 버전에서 가비지 컬렉션 방식을 지원했었으나 지금은 지원하지 않는다. iOS는 가바지 컬렉션 방식을 지원하지 않는다.

### 2.2.1. 객체 소유권

다른 객체를 참조한다는 것은, 다른 객체의 힙 메모리 주소를 포인터 변수에 담아 갖고 있다는 것을 의미한다.

```objective-c
Pen *aPen = [[Pen alloc] init];
Pen *bPen = aPen;
[aPen release];
bPen.color = [UIColor yellowColor];
```

위의 코드는 오류를 발생시킨다. `bPen`이 가리키고 있는 힙 영역이 메모리에서 해제되었기 때문이다.

ARC를 지원하지 않을 때, 객체 소유권을 명시적으로 관리할 필요가 있다.

#### 객체 소유권 규칙

- 특정 객체를 새로 만드는 경우 소유권을 갖는다.
- 다른 객체가 생성한 객체를 참조하기 전 소유권을 요청하여 받아야 한다.
- 소유권을 얻는 객체를 더 이상 참조하지 않으면 소유권을 반환한다.
- 소유권을 갖고 있지 않는 객체를 반환하면 안 된다.

'소유권을 갖는다'는 말은 참조 횟수를 1 증가시킨다 / retain한다는 의미다.

'소유권을 반환한다'는 말은 참조 횟수를 1 감소시킨다 / release한다는 의미다.

위의 네 규칙을 Cocoa 프레임워크의 메소드와 관련해서 다시 쓰면 다음과 같다.

- `alloc`, `new`, `copy`, `mutableCopy` 계열의 메소드로 특정 객체를 생성하거나 복사하여 새로운 객체 인스턴스를 만들면 참조 횟수를 1로 설정하고 소유권을 갖는다.
- 다른 객체가 이미 만들어 놓은 객체 인스턴스를 참조하는 경우 `retain` 메소드를 사용하여 객체 소유권을 요청하며, 참조 횟수를 1 증가시키고 소유권을 갖게 된다.
- 위에서 소유권을 얻는 객체를 더 이상 참조하지 않는 경우 `release` 또는 `autorelease` 메소드를 사용하여 객체 소유권을 반환하며, 참조 횟수를 1 감소시킨다.
- 소유권을 요청한 적이 없거나 이미 소유권을 반환한 경우라면 `release` 또는 `autorelease` 메세지를 해당 객체에 보내면 안 된다.