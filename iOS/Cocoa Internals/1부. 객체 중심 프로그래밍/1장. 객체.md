# 1장. 객체

> 글쓴이는 일반적으로 객체 지향 프로그래밍*Object-Oriented Programming*이라고 불리는 개념의 객체 단위 추상화의 중요성을 강조하기 위해 '객체 중심 프로그래밍'이라는 용어를 사용하고 있다.

> Swift에서 인스턴스라는 표현은 클래스뿐만 아니라 구조체, 열거형 등에서도 사용되고, 클래스의 인스턴스에 대해서는 특별히 객체라는 용어를 사용하므로, 이후 정리하는 글에서 '객체 인스턴스'와 같은 표현은 '객체'로 나타내기로 한다.

## 1.1. 클래스와 객체 인스턴스

절차 중심 프로그래밍과는 다르게, 객체 중심 프로그래밍은 객체 안에 프로퍼티와 메소드의 형태로 변수와 함수를 구현하고, 프로그램을 구성하는 객체들끼리 메세지를 주고받아 상호 협력하는 형태로 동작한다.

- 클래스 : 개발자가 문제 해결을 위해 추상화하여 만드는 코드
- 객체 : 클래스가 메모리에 구체화된 실체. 인스턴스. 하나의 클래스 코드에서 여러 개의 객체가 생성될 수 있다.

### 1.1.1. 객체에 대한 철학

서양 철학에서, 객체*object*라는 단어는 나를 중심으로 세상을 바라봤을 때 세상의 모든 것을 지칭한다.

이처럼 자연에 실존하는 객체를 그에 대응하는 형체가 없는 개념과 언어로 추상화시켜 생각하는 방식을 프로그래밍에 도입한 것이 객체 중심 프로그래밍이다.

실생활의 객체들을 책임과 역할에 따라 구분하고, 객체 사이의 관계와 연결하도록 생각하는 방식은 객체 중심 프로그래밍 패러다임을 이루는 골격이다.

|추상화|구체화|
|---|---|
|클래스|객체|
|개념|구체|
|일반화|개별화|
|무형|유형|
|추상화|구상화|
|이론|실제|

### 1.1.2. 객체 중심 프로그래밍

#### 랑그

langue

같은 언어를 사용하는 사람들끼리 생각하는 방식에 대한 원칙.

프로그래밍에 도입하여 생각해봤을 때, 어떠한 알고리즘(개념)이라고 말할 수 있음.

#### 파롤

parole

실제 대화나 상황에 따라서 표현이나 발음이 달라지는 것.

프로그래밍에 도입하여 생각해봤을 때, 어떠한 알고리즘의 각기 다른 구현이라고 말할 수 있음.

---

SOLID 법칙은 프로그램을 객체 중심으로 설계하기 위한 다섯 가지 원칙을 제시한다. 

(단일 책임 / 개방-폐쇄 / 리스코프 치환 / 인터페이스 분리 / 의존성 역전)

이를 활용하면 객체가 어떻게 동작할지 잘 추상화하여, 명확하고 깔끔한 책임 구조, 높은 응집력과 낮은 의존성, 변화에 대한 유용성 등에서 이점을 얻을 수 있다.

### 1.1.3. Objective-C 객체

#### Objective-C 기초 문법

- +로 시작하는 메소드는 클래스 메소드
- -로 시작하는 메소드는 인스턴스 메소드

#### 클래스 명세와 객체 인스턴스

메모리에 구체화된 객체는 해당 클래스 코드를 공유하며, 다른 인스턴스와는 구분되는 고유한 데이터를 가진다.

이처럼 클래스로 작성한 코드는 모든 객체가 공유하며, 클래스 명세를 기준으로 만들어진 각각의 객체가 클래스 코드를 재사용한다.

### 1.1.4. Objective-C 2.0 이후 변화

- `objc_object` 구조체는 객체에 대한 타입이다.
  - Objective-C 2.0부터 인스턴스의 클래스를 가리키는 `isa` 포인터에 직접 접근할 수 없다.
  - `NSObject`의 `-(Class)class`에 메세지를 보내거나  `object_getClass()` 런타임 API를 사용하여 객체의 클래스를 알아낼 수 있다.
- `id` 는 객체를 가리키는 포인터 타입이다.
- `Class` 는 Objective-C 클래스를 표현하는 불투명 타입이다.

### 1.1.5. Swift 네이티브 객체

Swift 중간 언어*Swift Intermediate Langugae*를 살펴본다.

> Swift 컴파일러 swiftc는 Swift 언어로 작성한 코드 파일을 읽어서 SIL을 만들고 LLVM IR로 변환하며, LLVM IR 최적화기를 거쳐 최종적으로 타겟 머신에 맞는 기계 코드를 생성한다.

Swift 네이티브 객체는 Objective-C와의 호환을 위해 Objective-C 객체와 비슷한 모양으로 만들어지는 것을 확인할 수 있다.

Swift의 클래스 타입은 `NSObject`를 상속받지 않는 경우 Objective-C와 호환되지 않는 네이티브 객체가 된다.

> 글쓴이는 독자의 이해를 돕기 위해 SIL 중 일부 코드를 수정하거나 제거하였다. 실제 SIL 표현과는 다를 수 있다.

다음의 코드에 대한 SIL을 살펴본다.

```swift
class NativePen {
  let id = 512
  var sequence = 1024
}
```

#### Swift 네이티브 객체의 생성 및 소멸 함수

`allocating_init()`과 `init()`, `deallocating_deinit()`과 `deinit()` 함수가 만들어진다.

특히 Objective-C에서는 `alloc` 과정 후 `init` 과정을 나누어서 해야 하는데, Swift에서는 `allocating_init()` 함수 내부에서 `init()`을 호출하여 초기화하는 것을 확인할 수 있다.

`deallocation_deinit()` 함수는 `self` 객체 레퍼런스를 `deinit()` 함수에 넘겨서 힙에 만들어진 레퍼런스 변수가 있다면 소멸시키는 과정을 거친다.

```text
// deallocating_deinit 간단 정리
@<변형된_이름> : $@convention(method) (@owned NativePen) -> () {
  %0 : $NativePen, let, name "self", argno 1  // 숨겨진 첫 번째 인자는 `self`.
  %3 = class.NativePen.deinit($0)             // `self`에 대한 `deinit()` 호출.
  %4 = unchecked_ref_cast(%3)
  dealloc_ref(%4)                             // 자기 자신을 메모리에서 해제.
}

// deinit 간단 정리
@<변형된_이름> : $@convention(method) (@guaranteed NativePen) -> @owned Buildin.NativeObject {
  %0 : $NativePen, let, name "self", argno 1 // 숨겨진 첫 번째 인자는 `self`.
  %2 = unchecked_ref_cast($0)
  return %2
}

// init 간단 정리
@<변형된_이름> : $@convention(method) (@owned NativePen) -> @owned NativePen {
  %0 : $NativePen, let, name "self"
  %2 : mark_uninitialized([rootself], %0)

  // `let id = 512` 초기화 과정.
  // Int 타입 / 정수 리터럴로 작성된 512의 정보를 사용하여 Int 타입의 인스턴스 생성.
  %4 = metatype(Int.Type)
  %5 = integer_literal($Builtin.Int2048, 512)
  %6 = Swift.Int.init(%5, %4)
  %7 = ref_element_addr(%2 : $NativePen, #NativePen.id)
  assign(%6 to %7)

  // `var sequence = 1024` 초기화 과정.
  // Int 타입 / 정수 리터럴로 작성된 1024의 정보를 사용하여 Int 타입의 인스턴스 생성.
  %10 = metatype(Int.Type)
  %11 = integer.literal($Builtin.Int2048, 1024)
  %12 = Swift.Int.init(%11, %10)
  %13 = ref_element_addr(%2 : $NativePen, #NativePen.sequence)
  assign(%12 to %13)
  
  return %2
}

// allocating_init 간단 정리
@<변형된_이름> : $@convention(thin) (@thick NativePen.Type) -> @owned NativePen {
  %1 = alloc_ref($NativePen)      // 객체 생성을 위한 메모리 공간 할당.
  %3 = class.NativePen.init(%1)   // 할당된 메모리 공간에 대하여 `init()` 호출.
  return %3
}
```

#### Swift 네이티브 객체의 getter 및 setter 함수

Swift 클래스의 프로퍼티에 대하여 getter 함수와 setter 함수가 만들어진다.

`id`는 `let`으로 선언되었으므로 setter가 만들어지지 않는다.

```text
// id.getter 간단 정리
@<변형된_이름> : $@convention(method) (@guaranteed NativePen) -> Int {
  %0 : $NativePen, let, name "self", argno 1            // 숨겨진 첫 번째 인자 `self`.
  %2 = ref_element_addr(%0 : $NativePen, #NativePen.id) // `self`로부터 `NativePen.id` 참조.
  %3 = load(%2)                                         // 참조된 `NativePen.id`로부터 값 복사.
  return %3
}

// sequence.getter 간단 정리
@<변형된_이름> : $@convention(method) (@guaranteed NativePen) -> Int {
  %0 : $NativePen, let, name "self", argno 1                  // 숨겨진 첫 번째 인자 `self`.
  %2 = ref_element_addr(%0 : $NativePen, $NativePen.sequence) // `self`로부터 `NativePen.sequence` 참조.
  %3 = load(%2)                                               // 참조된 `NativePen.sequence`로부터 값 복사.
  return %3
}

// sequence.setter 간단 정리
@<변형된_이름> : $@convention(method) (Int, @guaranteed NativePen) -> () {
  %0 : $Int, let, name "value", argno 1                       // 첫 번째 인자로 들어간 할당될 값
  %1 : $NativePen, let, name "self", argno 2                  // 두 번째 인자로 들어간 `self`.
  %4 = ref_element_addr(%1 : $NativePen, #NativePen.sequence) // `self`로부터 `NativePen.sequence` 참조.
  assign(%0 to %4)                                            // `NativePen.sequence` 참조에 할당될 값(%0) 할당.
}
```

### 1.1.6. Swift - Objective-C 호환 객체

Objective-C 코드에서 Swift 객체를 사용하려면 해당 Swift 객체는 반드시 `NSObject`를 최상위 클래스로 지정하여 상속받아 만들어져야 한다.

Objective-C와의 호환을 위해 중간 코드에 변형이 생긴다. `NSObject`의 메소드를 호출하기도 하며, 레퍼런스 카운트를 관리하는 코드도 추가된다.

### 1.1.7. 요약

디자인 패턴이나 객체 중심 디자인 원칙은 객체 중심으로 생각하는 과정을 반복적으로 경험하고 분석하여 규칙으로 만들어 놓은 것이다.

객체는 객관적이어야 한다. 객체를 표현한 코드는 누군가와 생각을 공유하기 위한 언어적 표현일 뿐이다.

Swift 네이티브 객체는 Objective-C 호환 객체와는 다르게 참조 계산 함수를 다루지 않고 부가적인 함수도 만들지 않는다.

Cocoa 프레임워크는 Swift 네이티브 객체를 사용하도록 포팅되고 있다.