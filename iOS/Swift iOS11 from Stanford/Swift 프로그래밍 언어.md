## 계산 프로퍼티

- 메모리에 초기화되지 않고 호출할 때마다 계산
- 설정자 / 접근자가 행하는 것이 복잡하다면 함수로 빼서 만들 수도 있음

## 접근 제어

- 애플리케이션 내부
  - internal : 접근 제어 기본값. 프로젝트 내에서 메소드나 프로퍼티에 접근 가능
  - private : 객체의 내부적인 구현의 형태를 의미. 다른 객체로 불러올 수 없음
  - private(set) : 프로퍼티에 적용 가능. 설정은 비공개(private), 접근은 객체 외부에서 접근 가능
  - fileprivate : 파일 내부에서만 접근 가능
- 프레임워크 관련
  - public : 프레임워크 외부에서 접근 가능
  - open : 프레임워크 외부에서 접근 가능. 상속 / 재정의 가능

모든 곳에 `private`을 설정하고 다른 사용자에게 공유할 필요가 생기면 그 때 조정하는 것도 좋은 전략

내부에서만 사용 가능한지, 외부에서 접근은 가능하나 설정은 금지시켜야 하는지 등에 대하여 잘 생각하여 `private` / `private(set)` 등을 잘 선택해야 한다.

`IBOutlet`이나 `IBAction` 등은 거의 모두 `private`인데, UI의 내부 구현 방식의 일종이기 떄문

## assertion

- 어떤 것이 참임을 단언하는 함수. 거짓이면 에러 발생
- 배포용 빌드에서는 무시되나 개발용 빌드에서는 에러를 발생시킬 수 있음
- API를 보호하는 좋은 수단
  - 잘못된 방법으로 API를 사용할 때 에러 메세지를 전달할 수 있음

## 익스텐션

- 프로퍼티나 함수를 다른 클래스 / 구조체 / 열거형 등에 추가할 수 있음
- 저장 프로퍼티는 정의할 수 없음
- 클래스에 어울리지 않는 프로퍼티나 함수를 확장하는 것을 경계하기
  - 익스텐션으로 추가되는 함수나 프로퍼티는 그 클래스를 더 나은 클래스로 만들어주는 것
  - 특정 클래스에서만 사용되는 기능을 익스텐션으로 정의할 필요는 없음
- 유틸리티나 함수를 익스텐션으로 확장하여 코드를 정리할 수 있음

## 열거형

- 각각의 case가 연관 값을 가질 수 있음
  - 튜플 패턴 사용하여 값 바인딩
- `switch`문과 잘 어울림
- 메소드나 계산 프로퍼티를 가질 수 있고, 저장 프로퍼티는 가질 수 없음
  - case의 연관 값이 저장 프로퍼티의 역할을 할 수 있음
- 쉼표를 사용하여 여러 개의 case를 나열할 수 있음
- 열거형 내에 정의된 메소드가 `self`를 재할당한다면 `mutating` 키워드를 명시해야 함. 값 타입이므로.
  - 값 타입은 복제되면서 전달이 이루어짐
  - 쓰기할 때 복제가 일어남 : 쓰기를 실행하기 전에는 복제가 생기지 않음
  - 어떤 함수가 쓰기를 실행하는지 알아야 함

```swift
// 옵셔널은 열거형. some case의 연관 값으로 값을 가지고 있음
enum Optional<T> {
    case none
    case some(<T>)
}
```

## Swift의 자료구조

### 클래스

- 객체 지향 프로그래밍 : 기능과 데이터 모두에게 단일 상속을 지원함
- 참조 타입 : 힙에 존재함
- ARC : 클래스가 메모리에서 해제되는 시점을 결정
  - 힙 내의 참조 타입에 포인터를 만들 때마다 Swift는 어딘가에 있는 카운터에 1을 더함, 포인터가 없어지면 카운터에서 1을 뺌.
  - 0이 되면 메모리에서 해제됨
  - strong : 기본 명시. strong으로 지정된 포인터가 인스턴스를 가리키고 있다면, 인스턴스는 힙에 계속 머무름
  - weak : 나 때문에 어떤 것을 힙에 두지 않음. 인스턴스를 가리키는 모든 strong 포인터가 관심이 없으면 nil이 할당됨. 옵셔널.
    - IBOutlet / delegate에 사용됨. 이외에는 자주 사용하지는 않음
  - unowned : 나 때문에 어떤 것을 힙에 두지 않음. 거의 사용되지 않음. 내가 아무것도 가리키지 않는데 접근하면 런타임 에러 발생.
    - 클로저의 경우 캡처링 때문에 뷰컨트롤러와 클로저가 서로 참조하는, 메모리 사이클이 자주 발생함. unowned 활용 가능

### 구조체

- 값 타입 : 쓰기 시 복사*copy on write*
- 함수형 프로그래밍 디자인 지원
- `let`과 `var` 선언에 따라 가변성*mutability* 결정됨
- 프로토콜을 통한 기능 상속

### 열거형

- 값 타입. 분리된 값
- 프로토콜을 통한 기능 상속

### 프로토콜

- 기능을 정의하는 타입
- 기능에 대하여 다중 상속의 효과를 낼 수 있음