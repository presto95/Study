# Safe Area

iPhone X의 출시와 함께 Layout Guide를 대체하기 위해 등장함

노치 디자인을 적용하지 않은 iPhone의 경우 (SE, 8, 8+ 등) 

- 세로 화면일 때는 상태 표시줄을 제외한 화면
- 가로 화면일 때는 전체 디바이스 화면

노치 디자인을 적용한 iPhone의 경우 (XS, XR, XS Max 등)

- 세로 화면일 때는 상태 표시줄과 하단의 시스템에서 사용하는 부분을 제외한 화면
- 가로 화면일 때는 노치 디자인을 적용한 부분과 반대 쪽의 그만큼의 부분, 그리고 하단의 시스템에서 사용하는 부분을 제외한 화면

# Hugging Priority

어떤 뷰가 Intrinsic Size를 고수하는 데 우선순위가 더 있는가에 대한 우선순위

# Compression Resistance Priority

어떤 뷰가 다른 뷰에 의해 Intrinsic Size를 고수하지 못하는 것에 대해 Intrinsic Size를 고수할 수 있게 하는 것에 대한 우선순위

# Scroll View

스크롤뷰는 스토리보드 상에서 적절하게 위치를 잡아주고, 스크롤뷰 내에 들어갈 컨텐츠의 제약 사항만 잘 걸어주면 스크롤뷰가 알아서 처리해준다. 

스크롤뷰 내에 들어갈 컨텐츠는 x, y, 너비, 높이 모두 적절하게 설정되어야 한다. 

스크롤뷰는 수평수직 스크롤이 가능하므로 컨텐츠의 크기를 조정하는 것이 매우 중요하다.

스크롤뷰에 들어갈 여러 뷰들을 스크롤뷰 내에서 작업하기보다는, 여러 뷰들을 하나의 뷰로 묶은 후 스크롤뷰에 붙여서 작업하는 것이 편할 수 있다.

# Margin

뷰의 바깥쪽과는 상관 없는 개념. 뷰의 안에 들어갈 것과 상관 있음. 뷰의 상위 뷰와 관련된 개념

제약 조건을 추가할 때 Constrain to margin을 체크하면 해당 뷰가 들어가 있는 뷰의 마진에 대하여 제약 조건이 설정되고, 체크하지 않으면 뷰 자체에 대하여 제약 조건이 설정됨

뷰의 내부에 들어가는 것과의 간격을 미리 정의하는 느낌? 여러 개의 뷰가 들어갈 때 유용하게 사용될 수 있겠다.

유용하게 사용될 수 있는 경우를 생각해보자.

# Stack View

오브젝트를 정렬하여 나열

- Axis : 방향 (수직 / 수평)
- Alignment
  - 스택뷰 내에서 오브젝트들이 어떻게 정렬되는가
  - Axis가 수평일 때 Fill / Top / Center / Bottom / First Baseline / Last Baseline
  - Axis가 수직일 때 Fill / Leading / Center / Trailing
- Distribution
  - 오브젝트 간 관계
  - Fill : 컨텐츠 크기에 맞추어 채움. 특별한 간격, 비율 등은 정의되어 있지 않음. 세부적인 설정을 해주어야 함
  - Fill Equally : 컨텐츠 간 Spacing에 정의된 값만큼 간격을 두어 채움
  - Fill Proportionally : 컨텐츠 간 비율에 따라 그 크기와 간격이 결정됨
  - Equal Spacing : 컨텐츠 간 간격을 같게 함. Spacing 값은 최소값의 개념으로 사용되므로 컨텐츠 간 간격이 Spacing보다 작으면 오류 발생
  - Equal Centering : 컨텐츠의 가운데를 기준으로 컨텐츠 간 간격을 같게 함. Spacing 값은 최소값의 개념으로 사용되므로 컨텐츠 간 간격이 Spacing보다 작으면 오류 발생
- Spacing
  - 컨텐츠 간 간격을 나타내는 값

# Image Resolution

pixel과 point의 차이.

iPhone X와 Plus들은 3x(@3x), 나머지는 2x(@2x) 이미지를 사용한다.

@1x, @2x, @3x같은 것들을 이미지 파일 이름 끝에 붙이지 않으면 이미지 크기 그대로 사용됨

- 이미지 크기(픽셀)과 iOS에서 사용하는 크기(포인트)가 동일시됨

@2x의 이미지 크기가 100x100, @3x의 이미지 크기가 150x150인 이미지가 있으면, 앱이 실행되는 기종에 따라 이미지를 선택하여 표시함

- 앱에서는 50포인트x50포인트로 표시됨

# Button Inset

UIButton의 경우 Intrinsic Content Size를 가지고 있으나 위아래는 UILabel과 비교했을 때 좀더 여백이 있음. 사용자의 입력을 받아야 하는 부분이기 때문이다.

Content Insets / Title Insets / Image Insets를 이용하여 버튼 안에 들어갈 컨텐츠의 위치 등을 조절할 수 있다.

Title Insets와 Image Insets의 경우 버튼 내부의 이미지뷰와 레이블에 대해서 인셋을 조절하고, 이 경우에 Content Insets을 항상 함께 생각해주어야 함. 버튼 내부의 이미지뷰와 레이블의 크기가 바뀌는 것이 아니기 때문이다.

음수값도 인셋의 값으로 사용 가능

버튼 내부의 이미지뷰와 레이블의 순서는 정해져 있으나, Attribute Inspector의 Semantic에서 Force Right-to-Left를 사용하여 순서를 바꿀 수 있음

인셋을 잘 사용하여 디자인을 할 수 있는 경우를 생각해보자

# Anchor

iOS 11부터 UIView의 safeAreaLayoutGuide 프로퍼티를 사용할 수 있으며, 뷰컨트롤러 루트뷰의 가장자리에서의 간격을 정의할 때는 safeAreaLayoutGuide의 Anchor들을 사용하는 것이 좋다.

# 실습1 - 스택뷰 활용

iPhone 8 이전 디바이스 화면과 iPhone X 계열의 디바이스 화면의 비율이 다름 (세로로 더 김)

이 경우 iPhone 8에서 표시되는 화면과 iPhone X에서 표시되는 화면을 완전히 같게 하는 것은 어렵다.

해결책

- 제약 조건의 **우선순위를 조절**하기
- greater than or equal, less than or equal을 사용하여 제약 조건을 유연하게 설정하기
  - 하나의 item에 대하여 여러 가지 제약 조건을 설정할 수 있다. ex) height <= 150 / height >= 60

### 우선 순위

- Required(1000) : 이 제약 조건은 반드시 유효함
- High(750) : 컨텐츠가 잘리는 것을 방지하는 기본 우선순위
- Low(250) : 뷰가 그 컨텐츠들의 크기를 유지하게 하는 기본 우선순위
- Content Hugging Priority의 기본값은 250
- Content Compression Resistance Priority의 기본값은 750
- 우선 순위를 잘 설정해 주어야 각 디바이스에 잘 대응하는 화면을 구성할 수 있겠다.

# 실습2 - 텍스트 동적 변환

ViewController의 루트 뷰에 ImageView와 Label을 추가하는 경우

`Label.Top = (multiplier) * Image View.Top + (constant)`

위의 식에서 ImageView.Top은 루트 뷰를 기준으로 계산되므로 ImageView가 루트뷰의 맨 위에 붙어있는 것이 아니라면, multiplier에 값을 주어 제약 조건을 조절하는 것이 가능하다.

ImageView를 View에 embed하여 같은 효과를 내도록 제약 조건을 설정하는 경우, ImageView.Top은 ImageView를 감싸는 View를 기준으로 계산되므로 ImageView.Top == 0이고, multiplier에 값을 주어 제약 조건을 조절할 수 없다. 0*x = 0이기 때문이다.

이처럼 **이미지뷰의 특정 위치에 오브젝트를 위치시키고 싶다면 그 컨테이너 뷰를 하나 만들어 제약 조건을 설정하는 것이 좋다.**

컨테이너의 가로세로 비율에 따라 크기가 동적으로 변할 때(Aspect Ratio), 그 안에 들어갈 오브젝트들의 Top과 Bottom 제약 조건을 컨테이너에 맞추고 Bottom의 multiplier를 조절하면 컨테이너의 크기에 대응하여 그 위치를 동적으로 설정할 수 있다.

텍스트 레이블에 들어가는 텍스트의 크기를 동적으로 변경하고 싶다면 Autoshrink 프로퍼티를 사용하는데, 커지고 작아지는 것이 아닌 작아지는 것과 관련된 개념이므로 가장 큰 디바이스 크기를 기준으로 설정해준다.

multiplier를 잘 활용해야 여러 디바이스의 크기에 잘 대응할 수 있다.

# 실습3 - 커스텀 키보드

스택뷰를 적절하게 활용하여 키보드 형태의 뷰를 쉽게 구성할 수 있음

`Bundle.main.loadNibNamed(_:owner:options) -> Any?` : .xib 파일 가져오기. 익스텐션으로 정의하여 사용하면 편리함

.xib 파일에 하나의 뷰만 정의되어 있다면 first 프로퍼티로 우리가 원하는 뷰를 가져올 수 있음

- .xib 파일에 여러 개의 뷰나 뷰 컨트롤러를 정의할 수 있음

키보드 입력을 받을 수 있는 오브젝트(UITextField, UITextView 등)의 inputView 프로퍼티에 사용자 정의 뷰를 할당하여 커스텀 키보드 역할을 해낼 수 있음

뷰에서 뷰컨트롤러에 값이나 이벤트를 전달할 때 델리게이트 패턴을 사용할 수 있음

# 실습4 - 테이블뷰셀의 동적 높이 변환

