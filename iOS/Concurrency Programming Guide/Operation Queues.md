# Operation Queues

코코아의 오퍼레이션은 비동기적으로 수행하기 원하는 작업을 캡슐화하는 객체 지향적 방법입니다. 오퍼레이션은 오퍼레이션 큐 또는 오퍼레이션 간 결합에서 사용되도록 설계되었습니다. Objective-C에 기반하기 때문에, 오퍼레이션은 macOS와 iOS에서 코코아 기반 애플리케이션에서 가장 흔하게 사용됩니다.

이 챕터는 오퍼레이션을 정의하고 사용하는 방법에 대해 보여줍니다.

## 오퍼레이션 오브젝트에 대하여

*오퍼레이션 오브젝트*는 Foundation 프레임워크에 있는 `NSOperation` 클래스의 인스턴스이며, 애플리케이션에서 수행하기 원하는 작업을 캡슐화할 때 사용합니다. `NSOperation` 클래스는 그 자체가 추상화된 기반 클래스이기 때문에 어떤 유용한 작업을 하기 위해서는 서브클래싱 되어야 합니다. 추상화되었다 할지라도, 이 클래스는 당신이 서브클래스에서 해야 하는 작업량을 최소화하기 위해 상당한 양의 인프라를 제공합니다. 게다가, Foundation 프레임워크는 두 개의 구체적인 서브클래스를 제공하며, 존재하는 코드에서 있는 그대로 사용할 수 있습니다.

| 클래스                | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| NSInvocationOperation | 애플리케이션에서 어떠한 오브젝트와 셀렉터에 기반하여 오퍼레이션 오브젝트를 있는 그대로 생성하기 위해 사용하는 클래스. 필요한 작업을 이미 수행하고 있는 존재하는 메소드를 가지고 있는 경우에 이 클래스를 사용할 수 있습니다. 서브클래싱을 요구하지 않기 때문에, 이 클래스를 사용하여 더욱 동적인 방식으로 오퍼레이션 오브젝트를 생성할 수도 있습니다.<br/>Creating an NSInvocationOperation Object에서 이 클래스를 사용하는 방법에 대한 정보를 확인할 수 있습니다. |
| NSBlockOperation      | 하나 또는 그 이상의 블록 오브젝트를 병렬적으로 실행하기 위해 있는 그대로 사용하는 클래스. 하나 이상의 블록을 실행할 수 있기 때문에, 블록 오퍼레이션 오브젝트는 그룹 의미론을 사용하여  동작합니다. 이는 모든 연관된 블록의 실행이 종료되어야 그 자체가 종료된 것으로 간주된다는 것을 의미합니다.<br/>Creating an NSBlockOperation Object에서 이 클래스를 사용하는 방법에 대한 정보를 확인할 수 있습니다. 블록에 대해서는 Blocks Programming Topics를 참고하십시오. |
| NSOperation           | 커스텀 오퍼레이션 오브젝트를 정의하기 위한 기반 클래스. `NSOperation`을 서브클래싱하여 당신 자신의 오퍼레이션 구현에 완전한 통제를 할 수 있으며, 당신의 오퍼레이션이 실행하고 그 상태를 보고하는 기본 방법을 바꾸는 능력을 포함합니다.<br/>Defining a Custom Operation Object에서 커스텀 오퍼레이션 오브젝트를 정의하는 방법에 대한 정보를 확인할 수 있습니다. |

모든 오퍼레이션 오브젝트는 다음의 주요 특징을 지원합니다.

- 오퍼레이션 오브젝트 간 그래프 기반 의존성 확립을 지원합니다. 이러한 의존성들은 의존하는 모든 작업의 실행이 완료될 때까지 주어진 작업이 실행되는 것을 방지합니다. Configuring Interoperation Dependencies를 참고하십시오.
- 선택적인 컴플리션 블록을 지원합니다. 이는 오퍼레이션의 주요 작업이 완료된 후 실행됩니다. Setting Up a Completion Block을 참고하십시오.
- KVO 알림을 사용하여 오퍼레이션의 실행 상태 변화를 모니터링하는 것을 지원합니다. Key-Value Observing Programming Guide를 참고하십시오.
- 오퍼레이션의 우선 순위 지정을 지원하며 상대적인 실행 순서에 영향을 줍니다. Changing an Operation's Execution Priority를 참고하십시오.
- 실행 중일 때 오퍼레이션을 중지하는 것을 허락하는, 의미적 취소를 지원합니다. Canceling Operations에서 오퍼레이션을 취소하는 방법, Responding to Cancellation Events에서 커스텀 오퍼레이션에서 취소를 지원하는 방법을 알아보십시오.

오퍼레이션은 애플리케이션에서 동시성의 수준을 향상시키는 것을 돕기 위해 설계되었습니다. 오퍼레이션은 또한 간단한 개별 묶음으로 애플리케이션의 행동을 조직하고 캡슐화하는 좋은 방법입니다. 애플리케이션의 메인 쓰레드에서 코드를 실행시키는 대신, 하나 또는 그 이상의 오퍼레이션 오브젝트를 큐에 제출할 수 있고, 이에 상응하는 작업이 하나 또는 그 이상의 개별 쓰레드에서 비동기적으로 수행되게 할 수 있습니다.

## 동시 vs. 비(非)동시 오퍼레이션

일반적으로 오퍼레이션 큐에 오퍼레이션을 추가하여 그것을 실행한다 할지라도, 필수적으로 그렇게 해야 하는 것은 아닙니다. 오퍼레이션의 `start` 메소드를 호출하여 오퍼레이션 오브젝트를 수동으로 실행하는 것도 가능하나, 이렇게 하는 것은 나머지 코드와 함께 그 오퍼레이션이 동시적으로 동작할 것이라는 것을 보장하지 않습니다. `NSOperation` 클래스의 `isAsynchronous` 프로퍼티는 `start` 메소드를 호출한 쓰레드의 관점에서 어떠한 오퍼레이션이 동기적인지 비동기적인지에 대해 알려줍니다. 기본적으로, 이 메소드는 `false`를 반환하며, 이는 호출 쓰레드에서 동기적으로 해당 오퍼레이션이 동작하고 있다는 것을 의미합니다.

*동시 작업*을 구현하기 원한다면, 즉, 호출 쓰레드의 관점에서 비동기적으로 오퍼레이션이 동작하기 원한다면, 오퍼레이션을 비동기적으로 시작하게 하기 위해 추가 코드를 작성해야 합니다. 예를 들어, 별도의 쓰레드를 생성하거나, 비동기적인 시스템 함수를 호출하거나, `start` 메소드가 작업을 시작하고 작업이 완료되기 전에 즉시 반환하게 할 수 있습니다.

대부분의 개발자들은 동시적인 오퍼레이션 오브젝트를 구현할 필요가 없습니다. 항상 오퍼레이션 큐에 당신의 오퍼레이션을 추가한다면, 동시 오퍼레이션을 구현할 필요가 없습니다. 동시적이지 않은 오퍼레이션을 오퍼레이션 큐에 제출할 때, 큐 자체적으로 그 오퍼레이션이 동작할 쓰레드를 생성합니다. 그러므로, 동시적이지 않은 오퍼레이션을 오퍼레이션 큐에 추가하는 것은 여전히 당신의 오퍼레이션 오브젝트 코드의 비동기적 실행의 결과를 가져옵니다. 동시 오퍼레이션을 정의하는 능력은 오퍼레이션 큐에 작업을 추가하지 않고 그것을 비동기적으로 실행할 필요가 있는 경우에만 필수적입니다.

동시 오퍼레이션을 생성하는 방법을 Configuring Operations for Concurrent Execution 및 NSOperation Class Reference에서 확인하십시오.

## NSInvocationOperation 오브젝트 생성하기

> NSInvocationOperation은 Swift에서 지원하지 않는다.
>
> 그래서 Swift로 예제 코드를 다시 작성할 수 없겠다...

`NSInvocationOperation` 클래스는 `NSOperation` 클래스의 구체적인 서브클래스이며, 실행될 때 당신이 지정한 오브젝트에 지정한 셀렉터를 호출합니다. 이 클래스를 사용하여 애플리케이션에서 각각의 작업에 대한 수많은 커스텀 오퍼레이션 오브젝트를 정의하지 않게 하십시오. 특히 이미 존재하는 애플리케이션을 수정하고 있으며, 필수 작업을 수행하기 위해 필요한 오브젝트와 메소드를 이미 가지고 있을 때 그렇게 하십시오. 또한 당신이 호출하기 원하는 메소드가 상황에 따라 변화할 수 있다면 이것을 사용할 수 있습니다. 예를 들어, 사용자 입력에 기반하여 동적으로 선택되는 셀렉터를 수행하기 위해 호출 오퍼레이션invocation operation을 사용할 수 있습니다.

호출 오퍼레이션을 생성하기 위한 프로세스는 직관적입니다. 초기화 메소드를 실행하기 위한 원하는 오브젝트와 셀럭터를 넘겨주어, 클래스의 새로운 인스턴스를 생성하고 초기화할 수 있습니다. 다음의 코드는 생성 프로세스를 보여주기 위해 커스텀 클래스로부터의 두 개의 메소드를 보여줍니다. `taskWithData(_:)` 메소드는 새로운 호출 오브젝트를 생성하고, 작업 구현을 포함하는 또다른 메소드의 이름과 함께 그것을 공급합니다.

## NSBlockOperation 오브젝트 생성하기

`NSBlockOperation` 클래스는 `NSOperation`의 구체적인 서브클래스이며 하나 또는 그 이상이 블록 오브젝트를 위한 래퍼로서 동작합니다. 이 클래스는 이미 오퍼레이션 큐를 사용하고 있으며, 디스패치 큐를 생성하기 싶지 않은 애플리케이션에 객제 지향적 래퍼를 제공합니다. 또한 디스패치 큐에서 이용 가능하지 않은 오퍼레이션 의존성, KVO 알림, 그리고 다른 기능들의 이점을 취하기 위해 블록 오퍼레이션을 사용할 수 있습니다.

블록 오퍼레이션을 생성할 때, 전형적으로 초기화 시점에 적어도 하나의 블록을 추가합니다. 필요할 때 나중에 더 많은 블록을 추가할 수 있습니다. `NSBlockOperation` 오브젝트를 실행할 시간이 올 때, 그 오브젝트는 기본 우선순위, 동시적 디스패치 큐에 그 모든 블록을 제출합니다. 그리고 나서 모든 블록의 실행이 종료될 때까지 기다립니다. 마지막 블록의 실행이 종료될 때, 오퍼레이션 오브젝트는 스스로 종료되었다는 표시를 합니다. 그러므로, 실행 중인 블록 그룹을 추적하기 위해 블록 오퍼레이션을 사용할 수 있으며, 이는 여러 쓰레드의 결과를 병합하기 위해 쓰레드 조인을 사용하는 것과 마찬가지입니다. 블록 오퍼레이션은 스스로 분리된 쓰레드에서 동작하기 때문에, 애플리케이션의 다른 쓰레드는 블록 오퍼레이션이 완료되는 것을 기다리는 동안 작업을 지속할 수 있다는 것이 차이점입니다.

```swift
let operation: BlockOperation = BlockOperation {
  print("Beginning operation.")
  print(1 + 2)
}
```

블록 오퍼레이션 오브젝트를 생성한 후, `addExecutionBlock` 메소드를 사용하여 더 많은 블록을 추가할 수 있습니다. 직렬적으로 블록들을 실행할 필요가 있다면, 바람직한 디스패치 큐에 그것들을 직접 제출해야 합니다.

```swift
operation.addExecutionBlock {
  print(2 + 3)
}
```

## 커스텀 오퍼레이션 오브젝트 정의하기

블록 오퍼레이션 및 호출 오퍼레이션*invocation operation* 오브젝트가 애플리케이션의 니즈를 잘 충족시키지 않는다면, 직접 `NSOperation` 클래스를 서브클래싱하여 당신이 필요로 하는 행동이 어떤 것이든지 추가할 수 있습니다. `NSOperation` 클래스는 모든 오퍼레이션 오브젝트들에 대하여 일반적인 서브클래싱 지점을 제공합니다. 또한 의존성 및 KVO 알림을 위해 필요한 대부분의 작업을 처리하기 위한 상당한 양의 인프라를 제공합니다. 그러나, 당신의 오퍼레이션들이 올바르게 동작하는 것을 보장하기 위해 존재하는 인프라를 보충해야 할 필요가 있을 때도 있을 것입니다. 당신이 해야 하는 여분의 작업량은 동시적 오퍼레이션을 구현하는 것인지 아닌지에 달려 있습니다.

동시적이지 않은 오퍼레이션을 정의하는 것은 동시적인 오퍼레이션을 정의하는 것보다 훨씬 간단합니다. 동시적이지 않은 오퍼레이션에 대하여, 당신이 해야 하는 모든 것은 주요 작업을 수행하고 취소 이벤트에 적절하게 응답하는 것뿐입니다. 이미 존재하는 클래스 인프라가 다른 작업들을 모두 해줍니다. 동기적인 오퍼레이션에 대하여, 당신은 커스텀 코드를 작성하여 존재하는 인프라 중 몇몇을 교체해야 합니다. 다음의 섹션은 두 가지 타입의 오브젝트를 구현하는 방법을 보여줍니다.

### 주요 작업 수행하기

최소한, 모든 오퍼레이션은 적어도 다음의 메소드들은 구현해야 합니다.

- 커스텀 초기화 메소드
- `main`

오퍼레이션 오브젝트를 알려진 상태에 넣기 위해 커스텀 초기화 메소드가 필요하고, 작업을 수행하기 위해 커스텀 `main` 메소드가 필요합니다. 물론 필요하다면 다음과 같은 추가 메소드를 구현할 수 있습니다.

- `main` 메소드의 구현으로부터 호출하기 위한 계획을 정의한 커스텀 메소드
- 데이터 값을 설정하고 오퍼레이션의 결과에 접근하기 위한 접근자 메소드
- 오퍼레이션 오브젝트를 아카이빙하고 언아카이빙하게 하는 `NSCoding` 프로토콜의 메소드

다음의 코드는 커스텀 `NSOperation` 서브클래스를 위한 시작 템플릿을 보여줍니다. 취소를 처리하는 방법은 보여주지 않으나, 전형적으로 사용하는 메소드에 대해서는 보여줍니다. Responding to Cancellation Events에서 취소를 처리하는 것에 대한 정보를 참고하십시오. 이 클래스의 초기화 메소드는 데이터 매개변수로 하나의 오브젝트를 취하며, 오퍼레이션 오브젝트 내에 그 참조를 저장합니다. `main` 메소드는 표면상으로는 결과를 애플리케이션에 반환하기 전에 데이터 오브젝트를 가지고 작업할 것입니다.

```swift
class NonConcurrentOperation: Operation {
  
  let myData: Data?
  
  init(data: Data?) {
    myData = data
    super.init()
  }
  
  override func main() {
    print(1)
  }
}
```

### 취소 이벤트에 응답하기

오퍼레이션이 실행을 시작한 후, 그것이 끝나거나 코드가 명시적으로 오퍼레이션을 취소할 때까지 작업 수행을 지속합니다. 취소는 어느 때나 일어날 수 있으며, 심지어 오퍼레이션이 실행을 시작하기 전에도 일어날 수 있습니다. `NSOperation` 클래스가 클라이언트들에게 오퍼레이션을 취소할 수 있는 방법을 제공한다 할지라도, 취소 이벤트를 인식하는 것은 필요에 따라 자발적입니다. 오퍼레이션이 분명하게 종료되었다면, 할당된 리소스를 되찾을 방법은 없을 수도 있습니다. 결과적으로, 오퍼레이션 오브젝트는 취소 이벤트를 확인하는 것을 기대하며, 오퍼레이션 도중에 취소 이벤트가 일어날 때 우아하게 종료됩니다.

오퍼레이션 오브젝트에 취소를 지원하기 위해, 그 오브젝트의 `isCancelled` 프로퍼티를 커스텀 코드에서 주기적으로 호출하고, 그것이 `true`를 반환한 직후 반환하기만 하면 됩니다. 취소를 지원하는 것은 오퍼레이션의 지속 시간이나, `NSOperation` 클래스를 직접 서브클래싱하였거나, 그 구체적인 서브클래스 중 하나를 사용한 것과 관계 없이 중요합니다. `isCancelled` 프로퍼티는 그 자체로 매우 가벼우며 어떠한 의미 있는 퍼포먼스 패널티 없이 주기적으로 호출될 수 있습니다. 당신의 오퍼레이션 오브젝트를 설계할 때, 코드에서 다음의 위치에 `isCancelled` 프로퍼티를 호출하는 것을 고려할 필요가 있습니다.

- 어떠한 실제 작업을 수행하기 직전
- 어떠한 루프의 각 반복 동안 적어도 한 번, 또는 각 반복이 상대적으로 오래 걸린다면 더욱 주기적으로
- 상대적으로 오퍼레이션을 중단하기 쉬운 코드 지점 어디든지

다음의 코드는 오퍼레이션 오브젝트의 `main` 메소드에서 취소 이벤트에 응답하는 매우 간단한 예제를 보여줍니다. 이 경우, `isCancelled` 프로퍼티는 while 루프의 각각의 반복에서 호출되며, 작업이 시작하기 전 빠른 종료를 허용합니다.

```swift
override func main() {
  var isDone = false
  while !isCancelled && !isDone {
    print(1)
  }
}
```

이전의 예제가 클린업 코드를 포함하고 있지 않을지라도, 커스텀 코드에 의해 할당되는 어떠한 리소스를 할당 해제하도록 해야 합니다.

### 동시적 실행을 위한 오퍼레이션 구성하기

오퍼레이션 오브젝트들은 기본적으로 동기 방식으로 실행됩니다. 즉, 그들의 `start` 메소드를 호출한 쓰레드에서 그들의 작업을 수행합니다. 그럼에도 불구하고, 오퍼레이션 큐들은 동시적이지 않은 오퍼레이션을 위한 쓰레드를 제공하기 때문에, 대부분의 오퍼레이션들은 여전히 비동기적으로 동작합니다. 그러나, 오퍼레이션들을 수동으로 실행할 계획을 갖고 있고 비동기적으로 동작하기를 원한다면, 그것들이 그렇게 하도록 적절한 액션을 취해야 합니다. 오퍼레이션 오브젝트를 동시 오퍼레이션으로 정의하여 이렇게 할 수 있습니다.

다음의 테이블은 동시 오퍼레이션을 구현하기 위해 일반적으로 재정의해야 하는 메소드 및 프로퍼티를 보여줍니다.

| 메소드 / 프로퍼티        | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| start                    | (필수) 모든 동시적 오퍼레이션은 이 메소드를 재정의하고 커스텀 구현으로 기본 행동을 교체해야 합니다. 수동으로 오퍼레이션을 실행하기 위해 `start` 메소드를 호출합니다. 그러므로, 이 메소드에 대한 구현은 오퍼레이션의 시작 지점이며, 쓰레드를 설정하는 곳이며, 다른 실행 환경을 설정하는 곳입니다. 어떠한 경우에도 `super`를 호출해서는 안됩니다. |
| main                     | (선택) 이 메소드는 일반적으로 오퍼레이션 오브젝트와 관련된 작업을 구현하기 위해 사용됩니다. `start` 메소드에서 작업을 수행할 수 있을지라도, 이 메소드를 사용하여 작업을 구현하는 것은 당신의 설정 및 작업 코드에서 더 깔끔한 분리의 결과를 가져올 수 있습니다. |
| isExecuting / isFinished | (필수) 동시 오퍼레이션은 그들의 실행 환경을 설정하고 클라이언트 바깥에 그 환경 상태를 보고할 책임이 있습니다. 그러므로, 동시 오퍼레이션은 그것이 작업을 실행하고 있는 때, 작업에 완료된 때를 알기 위한 몇몇 상태 정보를 가지고 있어야 합니다. 그리고 나서 이러한 프로퍼티를 사용하여 상태를 보고해야 합니다.<br/>이 프로퍼티의 구현은 다른 쓰레드로부터의 동시 호출에 안전해야 합니다. 또한 이 프로퍼티에 의해 보고되는 값들이 변화할 때 기대되는 키 경로를 위한 적절한 KVO 알림을 생성해야 합니다. |
| isAsynchronous           | (필수) 오퍼레이션을 동시 오퍼레이션으로서 식별하기 위해, 이 프로퍼티를 재정의하고 `true`를 반환하십시오. |

이 섹션의 나머지 부분은 `MyOperation` 클래스의 간단한 구현을 보여줍니다. 이는 동시 오퍼레이션을 구현하기 위해 필요한 기본 코드를 보여줍니다. `MyOperation` 클래스는 간단하게 그 자신의 `main` 메소드를 그것을 생성한 것과는 별개의 쓰레드에서 실행합니다. `main` 메소드가 수행하는 실제 작업은 관계가 없습니다. 샘플의 요점은 동시 오퍼레이션을 정의할 때 제공할 필요가 있는 인프라를 보여주는 것입니다.

다음의 코드는 `MyOperation` 클래스의 구현부를 보여줍니다. `isAsynchronous`, `isExecuting`, `isFinished` 프로퍼티의 구현은 상대적으로 직관적입니다. `isAsynchronous` 프로퍼티는 단순하게 `true`를 반환하여 이것이 동시 오퍼레이션이라는 것을 가리킵니다. `isExecuting`과 `isFinished` 프로퍼티는 단순하게 프로퍼티에 저장된 값을 반환합니다.

```swift
class MyOperation: Operation {
  
  var executing: Bool
  var finished: Bool
  
  override init() {
    super.init()
    executing = false
    finished = false
  }
  
  override var isAsynchronous: Bool { return true }
  
  override var isExecuting: Bool { return executing }
  
  override var isFinished: Bool { return finished }
}
```

다음의 코드는 `MyOperation` 의 `start` 메소드를 보여줍니다. 이 메소드의 구현은 필수적으로 수행해야 하는 작업을 보여지기 위해 최소한의 것만을 구현합니다. 이 경우, 메소드는 간단하게 새로운 쓰레드로 시작하고 `main` 메소드를 호출하여 그것을 구성합니다. 또한 `executing` 프로퍼티를 갱신하고 그 값의 변화를 반영하기 위해 `isExecuting` 키 경로를 위한 KVO 알림을 생성합니다. 그 작업이 완료되면, 이 메소드는 단순하게 반환되어, 실제 작업을 수행하기 위해 새롭게 분리된 쓰레드를 떠납니다.

```swift
override func start() {
  if isCancelled {
    willChangeValue(forKey: "isFinished")
    finished = true
    didChangeValue(forKey: "isFinished")
    return
  }
  willChangeValue(forKey: "isExecuting")
  Thread.detachNewThreadSelector(#selector(main), toTarget: self, with: nil)
  executing = true
  didChangeValue(forKey: "isExecuting")
}
```

다음의 코드는 `MyOperation` 클래스를 위한 나머지 구현을 보여줍니다. 위의 코드에서 확인할 수 있듯이, `main` 메소드는 새로운 쓰레드를 위한 진입점입니다. 그것은 오퍼레이션 오브젝트와 관련 있는 작업을 수행하고, 그 작업이 마침내 완료되었을 때 커스텀 `completeOperation` 메소드를 호출합니다. `completeOperation` 메소드는 오퍼레이션의 상태 변화를 반영하기 위해 `isExecuting` 및 `isFinished` 키 경로에 대한 필요한 KVO 알림을 생성합니다.

```swift
override func main() {
  complete()
}

func complete() {
  willChangeValue(forKey: "isFinished")
  willChangeValue(forKey: "isExecuting")
  executing = false
  finished = true
  didChangeValue(forKey: "isExecuting")
  didChangeValue(forKey: "isFinished")
}
```

어떠한 오퍼레이션이 취소되었을지라도, 당신은 KVO 옵저버에게 당신의 오퍼레이션이 그 작업과 함께 종료되었는지에 대해 통지해야 합니다. 오퍼레이션 오브젝트가 다른 오퍼레이션 오브젝트의 완료에 의존적일 때, 그러한 오브젝트의 `isFinished` 키 경로를 모니터링합니다. 모든 오브젝트가 완료되었다고 보고된 경우에만 종속적인 오퍼레이션의 신호가 실행 준비가 되었음을 알립니다. 그러므로 완료 알림을 생성하는 데 실패한 것은 애플리케이션에서 다른 오퍼레이션의 실행을 방지합니다.

### KVO 준수 유지하기

`NSOperation` 클래스는 다음의 키 경로에 대하여 키-값 옵저빙(KVO)를 준수합니다.

- `isCancelled`
- `isConcurrent` (`isAsynchronous` 사용하기)
- `isExecuting`
- `isFinished`
- `isReady`
- `dependencies`
- `queuePriority`
- `completionBlock`

당신이 `start` 메소드를 재정의하거나 재정의하는 대신 `NSOperation` 오브젝트에 어떠한 의미 있는 커스터마이징을 한다면, 커스텀 오브젝트가 이러한 키 경로에 대한 KVO 준수를 유지하는지를 보장해야 합니다. `start` 메소드를 재정의할 때, 당신이 가장 신경 써야 하는 키 경로는 `isExecuting`과 `isFinished`입니다. 이것들은 그 프로퍼티를 다시 구현하는 것으로부터 가장 흔하게 영향을 받는 키 경로들입니다.

다른 오퍼레이션 오브젝트들 이외의 것에 대한 의존성 지원을 구현하고 싶다면, `isReady` 프로퍼티를 재정의하고, 커스텀 의존성이 만족될 때까지 강제로 `false`를 반환하게 할 수 있습니다. (커스텀 의존성을 구현할 때, `NSOperation` 클래스가 제공하는 기본 의존성 관리 시스템을 지원한다면 `isReady` 프로퍼티 재정의에서 `super`를 호출해야 합니다.) 오퍼레이션 오브젝트의 준비 상태가 변화할 때, 그러한 변화를 보고하기 위해 `isReady` 키 경로에 대한 KVO 알림을 생성하십시오. `addDependency(_:)`나 `removeDependency(_:)` 메소드를 재정의하지 않는다면, `dependencies` 키 경로에 대한 KVO 알림에 대해 걱정할 필요는 없습니다.

`NSOperation`의 다른 키 경로에 대한 KVO 알림을 생성할 수 있을지라도, 그렇게 할 필요는 없습니다. 오퍼레이션을 취소할 필요가 있다면, 간단하게 이미 존재하는 `cancel` 메소드를 호출하기만 하면 됩니다. 비슷하게, 오퍼레이션 오브젝트에 대한 큐 우선순위 정보를 수정할 필요도 거의 없습니다. 마지막으로, 당신의 작업이 동시성 상태를 동적으로 변경하는 능력이 없다면, `isConcurrent` 키 경로에 대한 KVO 알림을 제공할 필요가 없습니다.

Key-Value Observing Programming Guide에서 키-값 옵저빙 및 커스텀 오브젝트에서의 지원에 대한 정보를 확인하십시오.

## 오퍼레이션 오브젝트의 실행 행동 커스터마이징하기

오퍼레이션 오브젝트의 구성은 당신이 그것들을 생성한 후에 일어나나 큐에 추가하기 전에 일어납니다. 이 섹션에서 기술하는 구성의 종류는 모든 오퍼레이션 오브젝트에 적용할 수 있으며, `NSOperation` 클래스를 서브클래싱하였거나, 이미 존재하는 서브클래스를 사용한 것과는 관계가 없습니다.

### 오퍼레이션 간 의존성 구성

의존성은 개별 오퍼레이션 오브젝트의 실행을 직려로하하는 방법입니다. 다른 오퍼레이션들에 의존하는 어떠한 오퍼레이션은 그것이 의존하는 모든 오퍼레이션들이 실행을 완료하기 전까지는 실행을 시작할 수 없습니다. 그러므로, 두 오퍼레이션 오브젝트 간 간단한 1대1 의존성을 생성하거나, 복잡한 오브젝트 의존성 그래프를 만들기 위해 의존성을 사용할 수 있습니다.

두 오퍼레이션 오브젝트 간에 의존성을 만들기 위해 `NSOpeation`의  `addDependency(_:)` 메소드를 사용합니다. 이 메소드는 현재 오퍼레이션에서, 매개 변수로 지정한 타겟 오퍼레이션으로 단방향 의존성을 생성합니다. 이 의존성은 현재 오브젝트가 타겟 오브젝트의 실행 완료까지 실행을 시작할 수 없다는 것을 의미합니다. 의존성들은 또한 같은 큐에 잇는 오퍼레이션에 대하여 제한이 없습니다. 오퍼레이션 오브젝트들은 그 자신의 의존성을 관리하며 오퍼레이션 간에 의존성을 만들고 그 모두를 다른 큐에 추가하는 것은 완벽하게 받아들여집니다. 그러나, 받아들여지지 않는 한 가지는 오퍼레이션 간 원형 의존성을 만드는 것입니다. 이렇게 하는 것은 영향을 받는 오퍼레이션이 실행되지 않도록 하는 프로그래머의 에러입니다.

모든 오퍼레이션의 의존성 자체가 실행을 완료하면, 오퍼레이션 오브젝트는 정상적으로 실행을 준비하게 됩니다. (`isReady` 프로퍼티의 행동을 커스터마이징한다면, 오퍼레이션의 준비 상태는 당신이 설정한 기준에 따라 결정됩니다.) 오퍼레이션 오브젝트가 큐 안에 있다면, 그 큐는 어느 때나 오퍼레이션의 실행을 시작할 수 있습니다. 수동으로 오퍼레이션을 실행할 계획이 있다면, 그것은 그 오퍼레이션의 `start` 메소드의 호출에 달려 있습니다.

**중요** 오퍼레이션들의 실행 또는 그것들을 오퍼레이션 큐에 추가히기 이전에 항상 의존성을 구성해야 합니다. 이후에 추가된 의존성은 주어진 오퍼레이션 오브젝트를 실행으로부터 방지하지 않습니다.

의존성은 오브젝트의 상태가변화할 때마다 적절한 KVO 알림을 보내는 각각의 오퍼레이션 오브젝트에 달려 있습니다. 오퍼레이션 오브젝트의 행동을 커스터마이징한다면, 의존성과 관련된 이슈를 피하기 위해 커스텀 코드에서 적절한 KVO 알림을 생성할 필요가 있습니다. Maintaning KVO Compliance에서 KVO 알림 및 오퍼레이션 오브젝트에 대한 정보를 확인하십시오. NSOperation Class Reference에서 의존성 구성에 대한 추가 정보를 확인하십시오.

### 오퍼레이션의 실행 우선순위 변경하기

큐에 추가된 오퍼레이션에 대하여, 실행 순서는 먼저 큐에 들어간 오퍼레이션의 준비 상태에 따라 결정되며, 그것들의 상대 우선순위에 따라 결정됩니다. 준비 상태는 다른 오퍼레이션에 대한 어떠한 오퍼레이션의 의존성에 의해 결정됩니다. 하지만 우선순위 단계는 오퍼레이션 오브젝트 그 자체의 특성입니다. 기본적으로, 모든 새로운 오퍼레이션 오브젝트들은 "일반*normal*" 의존성을 가지고 있습니다. 하지만 오브젝트의 `queuePriority` 프로퍼티를 사용하여 필요할 때 그 우선순위를 증가시키거나 감소시킬 수 있습니다.

우선순위 단계는 같은 오퍼레이션 큐 안에 있는 오퍼레이션들에 대해서만 적용됩니다.