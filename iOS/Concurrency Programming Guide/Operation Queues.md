# Operation Queues

코코아의 오퍼레이션은 비동기적으로 수행하기 원하는 작업을 캡슐화하는 객체 지향적 방법입니다. 오퍼레이션은 오퍼레이션 큐 또는 오퍼레이션 간 결합에서 사용되도록 설계되었습니다. Objective-C에 기반하기 때문에, 오퍼레이션은 macOS와 iOS에서 코코아 기반 애플리케이션에서 가장 흔하게 사용됩니다.

이 챕터는 오퍼레이션을 정의하고 사용하는 방법에 대해 보여줍니다.

## 오퍼레이션 오브젝트에 대하여

*오퍼레이션 오브젝트*는 Foundation 프레임워크에 있는 `NSOperation` 클래스의 인스턴스이며, 애플리케이션에서 수행하기 원하는 작업을 캡슐화할 때 사용합니다. `NSOperation` 클래스는 그 자체가 추상화된 기반 클래스이기 때문에 어떤 유용한 작업을 하기 위해서는 서브클래싱 되어야 합니다. 추상화되었다 할지라도, 이 클래스는 당신이 서브클래스에서 해야 하는 작업량을 최소화하기 위해 상당한 양의 인프라를 제공합니다. 게다가, Foundation 프레임워크는 두 개의 구체적인 서브클래스를 제공하며, 존재하는 코드에서 있는 그대로 사용할 수 있습니다.

| 클래스                | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| NSInvocationOperation | 애플리케이션에서 어떠한 오브젝트와 셀렉터에 기반하여 오퍼레이션 오브젝트를 있는 그대로 생성하기 위해 사용하는 클래스. 필요한 작업을 이미 수행하고 있는 존재하는 메소드를 가지고 있는 경우에 이 클래스를 사용할 수 있습니다. 서브클래싱을 요구하지 않기 때문에, 이 클래스를 사용하여 더욱 동적인 방식으로 오퍼레이션 오브젝트를 생성할 수도 있습니다.<br/>Creating an NSInvocationOperation Object에서 이 클래스를 사용하는 방법에 대한 정보를 확인할 수 있습니다. |
| NSBlockOperation      | 하나 또는 그 이상의 블록 오브젝트를 병렬적으로 실행하기 위해 있는 그대로 사용하는 클래스. 하나 이상의 블록을 실행할 수 있기 때문에, 블록 오퍼레이션 오브젝트는 그룹 의미론을 사용하여  동작합니다. 이는 모든 연관된 블록의 실행이 종료되어야 그 자체가 종료된 것으로 간주된다는 것을 의미합니다.<br/>Creating an NSBlockOperation Object에서 이 클래스를 사용하는 방법에 대한 정보를 확인할 수 있습니다. 블록에 대해서는 Blocks Programming Topics를 참고하십시오. |
| NSOperation           | 커스텀 오퍼레이션 오브젝트를 정의하기 위한 기반 클래스. `NSOperation`을 서브클래싱하여 당신 자신의 오퍼레이션 구현에 완전한 통제를 할 수 있으며, 당신의 오퍼레이션이 실행하고 그 상태를 보고하는 기본 방법을 바꾸는 능력을 포함합니다.<br/>Defining a Custom Operation Object에서 커스텀 오퍼레이션 오브젝트를 정의하는 방법에 대한 정보를 확인할 수 있습니다. |

모든 오퍼레이션 오브젝트는 다음의 주요 특징을 지원합니다.

- 오퍼레이션 오브젝트 간 그래프 기반 의존성 확립을 지원합니다. 이러한 의존성들은 의존하는 모든 작업의 실행이 완료될 때까지 주어진 작업이 실행되는 것을 방지합니다. Configuring Interoperation Dependencies를 참고하십시오.
- 선택적인 컴플리션 블록을 지원합니다. 이는 오퍼레이션의 주요 작업이 완료된 후 실행됩니다. Setting Up a Completion Block을 참고하십시오.
- KVO 알림을 사용하여 오퍼레이션의 실행 상태 변화를 모니터링하는 것을 지원합니다. Key-Value Observing Programming Guide를 참고하십시오.
- 오퍼레이션의 우선 순위 지정을 지원하며 상대적인 실행 순서에 영향을 줍니다. Changing an Operation's Execution Priority를 참고하십시오.
- 실행 중일 때 오퍼레이션을 중지하는 것을 허락하는, 의미적 취소를 지원합니다. Canceling Operations에서 오퍼레이션을 취소하는 방법, Responding to Cancellation Events에서 커스텀 오퍼레이션에서 취소를 지원하는 방법을 알아보십시오.

오퍼레이션은 애플리케이션에서 동시성의 수준을 향상시키는 것을 돕기 위해 설계되었습니다. 오퍼레이션은 또한 간단한 개별 묶음으로 애플리케이션의 행동을 조직하고 캡슐화하는 좋은 방법입니다. 애플리케이션의 메인 쓰레드에서 코드를 실행시키는 대신, 하나 또는 그 이상의 오퍼레이션 오브젝트를 큐에 제출할 수 있고, 이에 상응하는 작업이 하나 또는 그 이상의 개별 쓰레드에서 비동기적으로 수행되게 할 수 있습니다.

## 동시 vs. 비(非)동시 오퍼레이션

일반적으로 오퍼레이션 큐에 오퍼레이션을 추가하여 그것을 실행한다 할지라도, 필수적으로 그렇게 해야 하는 것은 아닙니다. 오퍼레이션의 `start` 메소드를 호출하여 오퍼레이션 오브젝트를 수동으로 실행하는 것도 가능하나, 이렇게 하는 것은 나머지 코드와 함께 그 오퍼레이션이 동시적으로 동작할 것이라는 것을 보장하지 않습니다. `NSOperation` 클래스의 `isAsynchronous` 프로퍼티는 `start` 메소드를 호출한 쓰레드의 관점에서 어떠한 오퍼레이션이 동기적인지 비동기적인지에 대해 알려줍니다. 기본적으로, 이 메소드는 `false`를 반환하며, 이는 호출 쓰레드에서 동기적으로 해당 오퍼레이션이 동작하고 있다는 것을 의미합니다.

*동시 작업*을 구현하기 원한다면, 즉, 호출 쓰레드의 관점에서 비동기적으로 오퍼레이션이 동작하기 원한다면, 오퍼레이션을 비동기적으로 시작하게 하기 위해 추가 코드를 작성해야 합니다. 예를 들어, 별도의 쓰레드를 생성하거나, 비동기적인 시스템 함수를 호출하거나, `start` 메소드가 작업을 시작하고 작업이 완료되기 전에 즉시 반환하게 할 수 있습니다.

대부분의 개발자들은 동시적인 오퍼레이션 오브젝트를 구현할 필요가 없습니다. 항상 오퍼레이션 큐에 당신의 오퍼레이션을 추가한다면, 동시 오퍼레이션을 구현할 필요가 없습니다. 동시적이지 않은 오퍼레이션을 오퍼레이션 큐에 제출할 때, 큐 자체적으로 그 오퍼레이션이 동작할 쓰레드를 생성합니다. 그러므로, 동시적이지 않은 오퍼레이션을 오퍼레이션 큐에 추가하는 것은 여전히 당신의 오퍼레이션 오브젝트 코드의 비동기적 실행의 결과를 가져옵니다. 동시 오퍼레이션을 정의하는 능력은 오퍼레이션 큐에 작업을 추가하지 않고 그것을 비동기적으로 실행할 필요가 있는 경우에만 필수적입니다.

동시 오퍼레이션을 생성하는 방법을 Configuring Operations for Concurrent Execution 및 NSOperation Class Reference에서 확인하십시오.

## NSInvocationOperation 오브젝트 생성하기

> NSInvocationOperation은 Swift에서 지원하지 않는다.
>
> 그래서 Swift로 예제 코드를 다시 작성할 수 없겠다...

`NSInvocationOperation` 클래스는 `NSOperation` 클래스의 구체적인 서브클래스이며, 실행될 때 당신이 지정한 오브젝트에 지정한 셀렉터를 호출합니다. 이 클래스를 사용하여 애플리케이션에서 각각의 작업에 대한 수많은 커스텀 오퍼레이션 오브젝트를 정의하지 않게 하십시오. 특히 이미 존재하는 애플리케이션을 수정하고 있으며, 필수 작업을 수행하기 위해 필요한 오브젝트와 메소드를 이미 가지고 있을 때 그렇게 하십시오. 또한 당신이 호출하기 원하는 메소드가 상황에 따라 변화할 수 있다면 이것을 사용할 수 있습니다. 예를 들어, 사용자 입력에 기반하여 동적으로 선택되는 셀렉터를 수행하기 위해 호출 오퍼레이션invocation operation을 사용할 수 있습니다.

호출 오퍼레이션을 생성하기 위한 프로세스는 직관적입니다. 초기화 메소드를 실행하기 위한 원하는 오브젝트와 셀럭터를 넘겨주어, 클래스의 새로운 인스턴스를 생성하고 초기화할 수 있습니다. 다음의 코드는 생성 프로세스를 보여주기 위해 커스텀 클래스로부터의 두 개의 메소드를 보여줍니다. `taskWithData(_:)` 메소드는 새로운 호출 오브젝트를 생성하고, 작업 구현을 포함하는 또다른 메소드의 이름과 함께 그것을 공급합니다.

## NSBlockOperation 오브젝트 생성하기

`NSBlockOperation` 클래스는 `NSOperation`의 구체적인 서브클래스이며 하나 또는 그 이상이 블록 오브젝트를 위한 래퍼로서 동작합니다. 이 클래스는 이미 오퍼레이션 큐를 사용하고 있으며, 디스패치 큐를 생성하기 싶지 않은 애플리케이션에 객제 지향적 래퍼를 제공합니다. 또한 디스패치 큐에서 이용 가능하지 않은 오퍼레이션 의존성, KVO 알림, 그리고 다른 기능들의 이점을 취하기 위해 블록 오퍼레이션을 사용할 수 있습니다.

블록 오퍼레이션을 생성할 때, 전형적으로 초기화 시점에 적어도 하나의 블록을 추가합니다. 필요할 때 나중에 더 많은 블록을 추가할 수 있습니다. `NSBlockOperation` 오브젝트를 실행할 시간이 올 때, 그 오브젝트는 기본 우선순위, 동시적 디스패치 큐에 그 모든 블록을 제출합니다. 그리고 나서 모든 블록의 실행이 종료될 때까지 기다립니다. 마지막 블록의 실행이 종료될 때, 오퍼레이션 오브젝트는 스스로 종료되었다는 표시를 합니다. 그러므로, 실행 중인 블록 그룹을 추적하기 위해 블록 오퍼레이션을 사용할 수 있으며, 이는 여러 쓰레드의 결과를 병합하기 위해 쓰레드 조인을 사용하는 것과 마찬가지입니다. 블록 오퍼레이션은 스스로 분리된 쓰레드에서 동작하기 때문에, 애플리케이션의 다른 쓰레드는 블록 오퍼레이션이 완료되는 것을 기다리는 동안 작업을 지속할 수 있다는 것이 차이점입니다.

```swift
let operation: BlockOperation = BlockOperation {
  print("Beginning operation.")
  print(1 + 2)
}
```

블록 오퍼레이션 오브젝트를 생성한 후, `addExecutionBlock` 메소드를 사용하여 더 많은 블록을 추가할 수 있습니다. 직렬적으로 블록들을 실행할 필요가 있다면, 바람직한 디스패치 큐에 그것들을 직접 제출해야 합니다.

```swift
operation.addExecutionBlock {
  print(2 + 3)
}
```

## 커스텀 오퍼레이션 오브젝트 정의하기

블록 오퍼레이션 및 호출 오퍼레이션*invocation operation* 오브젝트가 애플리케이션의 니즈를 잘 충족시키지 않는다면, 직접 `NSOperation` 클래스를 서브클래싱하여 당신이 필요로 하는 행동이 어떤 것이든지 추가할 수 있습니다. `NSOperation` 클래스는 모든 오퍼레이션 오브젝트들에 대하여 일반적인 서브클래싱 지점을 제공합니다. 또한 의존성 및 KVO 알림을 위해 필요한 대부분의 작업을 처리하기 위한 상당한 양의 인프라를 제공합니다. 그러나, 당신의 오퍼레이션들이 올바르게 동작하는 것을 보장하기 위해 존재하는 인프라를 보충해야 할 필요가 있을 때도 있을 것입니다. 당신이 해야 하는 여분의 작업량은 동시적 오퍼레이션을 구현하는 것인지 아닌지에 달려 있습니다.

동시적이지 않은 오퍼레이션을 정의하는 것은 동시적인 오퍼레이션을 정의하는 것보다 훨씬 간단합니다. 동시적이지 않은 오퍼레이션에 대하여, 당신이 해야 하는 모든 것은 주요 작업을 수행하고 취소 이벤트에 적절하게 응답하는 것뿐입니다. 이미 존재하는 클래스 인프라가 다른 작업들을 모두 해줍니다. 동기적인 오퍼레이션에 대하여, 당신은 커스텀 코드를 작성하여 존재하는 인프라 중 몇몇을 교체해야 합니다. 다음의 섹션은 두 가지 타입의 오브젝트를 구현하는 방법을 보여줍니다.

### 주요 작업 수행하기

최소한, 모든 오퍼레이션은 적어도 다음의 메소드들은 구현해야 합니다.

- 커스텀 초기화 메소드
- `main`

오퍼레이션 오브젝트를 알려진 상태에 넣기 위해 커스텀 초기화 메소드가 필요하고, 작업을 수행하기 위해 커스텀 `main` 메소드가 필요합니다. 물론 필요하다면 다음과 같은 추가 메소드를 구현할 수 있습니다.

- `main` 메소드의 구현으로부터 호출하기 위한 계획을 정의한 커스텀 메소드
- 데이터 값을 설정하고 오퍼레이션의 결과에 접근하기 위한 접근자 메소드
- 오퍼레이션 오브젝트를 아카이빙하고 언아카이빙하게 하는 `NSCoding` 프로토콜의 메소드

다음의 코드는 커스텀 `NSOperation` 서브클래스를 위한 시작 템플릿을 보여줍니다. 취소를 처리하는 방법은 보여주지 않으나, 전형적으로 사용하는 메소드에 대해서는 보여줍니다. Responding to Cancellation Events에서 취소를 처리하는 것에 대한 정보를 참고하십시오. 이 클래스의 초기화 메소드는 데이터 매개변수로 하나의 오브젝트를 취하며, 오퍼레이션 오브젝트 내에 그 참조를 저장합니다. `main` 메소드는 표면상으로는 결과를 애플리케이션에 반환하기 전에 데이터 오브젝트를 가지고 작업할 것입니다.

```swift
class NonConcurrentOperation: Operation {
  
  let myData: Data?
  
  init(data: Data?) {
    myData = data
    super.init()
  }
  
  override func main() {
    print(1)
  }
}
```

### 취소 이벤트에 응답하기

오퍼레이션이 실행을 시작한 후, 그것이 끝나거나 코드가 명시적으로 오퍼레이션을 취소할 때까지 작업 수행을 지속합니다. 취소는 어느 때나 일어날 수 있으며, 심지어 오퍼레이션이 실행을 시작하기 전에도 일어날 수 있습니다. `NSOperation` 클래스가 클라이언트들에게 오퍼레이션을 취소할 수 있는 방법을 제공한다 할지라도, 취소 이벤트를 인식하는 것은 필요에 따라 자발적입니다. 오퍼레이션이 분명하게 종료되었다면, 할당된 리소스를 되찾을 방법은 없을 수도 있습니다. 결과적으로, 오퍼레이션 오브젝트는 취소 이벤트를 확인하는 것을 기대하며, 오퍼레이션 도중에 취소 이벤트가 일어날 때 우아하게 종료됩니다.

오퍼레이션 오브젝트에 취소를 지원하기 위해, 그 오브젝트의 `isCancelled` 프로퍼티를 커스텀 코드에서 주기적으로 호출하고, 그것이 `true`를 반환한 직후 반환하기만 하면 됩니다. 취소를 지원하는 것은 오퍼레이션의 지속 시간이나, `NSOperation` 클래스를 직접 서브클래싱하였거나, 그 구체적인 서브클래스 중 하나를 사용한 것과 관계 없이 중요합니다. `isCancelled` 프로퍼티는 그 자체로 매우 가벼우며 어떠한 의미 있는 퍼포먼스 패널티 없이 주기적으로 호출될 수 있습니다. 당신의 오퍼레이션 오브젝트를 설계할 때, 코드에서 다음의 위치에 `isCancelled` 프로퍼티를 호출하는 것을 고려할 필요가 있습니다.

- 어떠한 실제 작업을 수행하기 직전
- 어떠한 루프의 각 반복 동안 적어도 한 번, 또는 각 반복이 상대적으로 오래 걸린다면 더욱 주기적으로
- 상대적으로 오퍼레이션을 중단하기 쉬운 코드 지점 어디든지

다음의 코드는 오퍼레이션 오브젝트의 `main` 메소드에서 취소 이벤트에 응답하는 매우 간단한 예제를 보여줍니다. 이 경우, `isCancelled` 프로퍼티는 while 루프의 각각의 반복에서 호출되며, 작업이 시작하기 전 빠른 종료를 허용합니다.

```swift
override func main() {
  var isDone = false
  while !isCancelled && !isDone {
    print(1)
  }
}
```

이전의 예제가 클린업 코드를 포함하고 있지 않을지라도, 커스텀 코드에 의해 할당되는 어떠한 리소스를 할당 해제하도록 해야 합니다.

### 동시적 실행을 위한 오퍼레이션 구성하기

오퍼레이션 오브젝트들은 기본적으로 동기 방식으로 실행됩니다. 즉, 그들의 `start` 메소드를 호출한 쓰레드에서 그들의 작업을 수행합니다. 그럼에도 불구하고, 오퍼레이션 큐들은 동시적이지 않은 오퍼레이션을 위한 쓰레드를 제공하기 때문에, 대부분의 오퍼레이션들은 여전히 비동기적으로 동작합니다. 그러나, 오퍼레이션들을 수동으로 실행할 계획을 갖고 있고 비동기적으로 동작하기를 원한다면, 그것들이 그렇게 하도록 적절한 액션을 취해야 합니다. 오퍼레이션 오브젝트를 동시 오퍼레이션으로 정의하여 이렇게 할 수 있습니다.

다음의 테이블은 동시 오퍼레이션을 구현하기 위해 일반적으로 재정의해야 하는 메소드 및 프로퍼티를 보여줍니다.

| 메소드 / 프로퍼티        | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| start                    | (필수) 모든 동시적 오퍼레이션은 이 메소드를 재정의하고 커스텀 구현으로 기본 행동을 교체해야 합니다. 수동으로 오퍼레이션을 실행하기 위해 `start` 메소드를 호출합니다. 그러므로, 이 메소드에 대한 구현은 오퍼레이션의 시작 지점이며, 쓰레드를 설정하는 곳이며, 다른 실행 환경을 설정하는 곳입니다. 어떠한 경우에도 `super`를 호출해서는 안됩니다. |
| main                     | (선택) 이 메소드는 일반적으로 오퍼레이션 오브젝트와 관련된 작업을 구현하기 위해 사용됩니다. `start` 메소드에서 작업을 수행할 수 있을지라도, 이 메소드를 사용하여 작업을 구현하는 것은 당신의 설정 및 작업 코드에서 더 깔끔한 분리의 결과를 가져올 수 있습니다. |
| isExecuting / isFinished | (필수) 동시 오퍼레이션은 그들의 실행 환경을 설정하고 클라이언트 바깥에 그 환경 상태를 보고할 책임이 있습니다. 그러므로, 동시 오퍼레이션은 그것이 작업을 실행하고 있는 때, 작업에 완료된 때를 알기 위한 몇몇 상태 정보를 가지고 있어야 합니다. 그리고 나서 이러한 프로퍼티를 사용하여 상태를 보고해야 합니다.<br/>이 프로퍼티의 구현은 다른 쓰레드로부터의 동시 호출에 안전해야 합니다. 또한 이 프로퍼티에 의해 보고되는 값들이 변화할 때 기대되는 키 경로를 위한 적절한 KVO 알림을 생성해야 합니다. |
| isAsynchronous           | (필수) 오퍼레이션을 동시 오퍼레이션으로서 식별하기 위해, 이 프로퍼티를 재정의하고 `true`를 반환하십시오. |

이 섹션의 나머지 부분은 `MyOperation` 클래스의 간단한 구현을 보여줍니다. 이는 동시 오퍼레이션을 구현하기 위해 필요한 기본 코드를 보여줍니다. `MyOperation` 클래스는 간단하게 그 자신의 `main` 메소드를 그것을 생성한 것과는 별개의 쓰레드에서 실행합니다. `main` 메소드가 수행하는 실제 작업은 관계가 없습니다. 샘플의 요점은 동시 오퍼레이션을 정의할 때 제공할 필요가 있는 인프라를 보여주는 것입니다.

다음의 코드는 `MyOperation` 클래스의 구현부를 보여줍니다. `isAsynchronous`, `isExecuting`, `isFinished` 프로퍼티의 구현은 상대적으로 직관적입니다. `isAsynchronous` 프로퍼티는 단순하게 `true`를 반환하여 이것이 동시 오퍼레이션이라는 것을 가리킵니다. `isExecuting`과 `isFinished` 프로퍼티는 단순하게 프로퍼티에 저장된 값을 반환합니다.

```swift
class MyOperation: Operation {
  
  var executing: Bool
  var finished: Bool
  
  override init() {
    super.init()
    executing = false
    finished = false
  }
  
  override var isAsynchronous: Bool { return true }
  
  override var isExecuting: Bool { return executing }
  
  override var isFinished: Bool { return finished }
}
```

다음의 코드는 `MyOperation` 의 `start` 메소드를 보여줍니다. 이 메소드의 구현은 필수적으로 수행해야 하는 작업을 보여지기 위해 최소한의 것만을 구현합니다. 이 경우, 메소드는 간단하게 새로운 쓰레드로 시작하고 `main` 메소드를 호출하여 그것을 구성합니다. 또한 `executing` 프로퍼티를 갱신하고 그 값의 변화를 반영하기 위해 `isExecuting` 키 경로를 위한 KVO 알림을 생성합니다. 그 작업이 완료되면, 이 메소드는 단순하게 반환되어, 실제 작업을 수행하기 위해 새롭게 분리된 쓰레드를 떠납니다.

```swift
override func start() {
  if isCancelled {
    willChangeValue(forKey: "isFinished")
    finished = true
    didChangeValue(forKey: "isFinished")
    return
  }
  willChangeValue(forKey: "isExecuting")
  Thread.detachNewThreadSelector(#selector(main), toTarget: self, with: nil)
  executing = true
  didChangeValue(forKey: "isExecuting")
}
```

다음의 코드는 `MyOperation` 클래스를 위한 나머지 구현을 보여줍니다. 위의 코드에서 확인할 수 있듯이, `main` 메소드는 새로운 쓰레드를 위한 진입점입니다. 그것은 오퍼레이션 오브젝트와 관련 있는 작업을 수행하고, 그 작업이 마침내 완료되었을 때 커스텀 `completeOperation` 메소드를 호출합니다. `completeOperation` 메소드는 오퍼레이션의 상태 변화를 반영하기 위해 `isExecuting` 및 `isFinished` 키 경로에 대한 필요한 KVO 알림을 생성합니다.

```swift
override func main() {
  complete()
}

func complete() {
  willChangeValue(forKey: "isFinished")
  willChangeValue(forKey: "isExecuting")
  executing = false
  finished = true
  didChangeValue(forKey: "isExecuting")
  didChangeValue(forKey: "isFinished")
}
```

어떠한 오퍼레이션이 취소되었을지라도, 당신은 KVO 옵저버에게 당신의 오퍼레이션이 그 작업과 함께 종료되었는지에 대해 통지해야 합니다. 오퍼레이션 오브젝트가 다른 오퍼레이션 오브젝트의 완료에 의존적일 때, 그러한 오브젝트의 `isFinished` 키 경로를 모니터링합니다. 모든 오브젝트가 완료되었다고 보고된 경우에만 종속적인 오퍼레이션의 신호가 실행 준비가 되었음을 알립니다. 그러므로 완료 알림을 생성하는 데 실패한 것은 애플리케이션에서 다른 오퍼레이션의 실행을 방지합니다.

### KVO 준수 유지하기

`NSOperation` 클래스는 다음의 키 경로에 대하여 키-값 옵저빙(KVO)를 준수합니다.

- `isCancelled`
- `isConcurrent` (`isAsynchronous` 사용하기)
- `isExecuting`
- `isFinished`
- `isReady`
- `dependencies`
- `queuePriority`
- `completionBlock`

당신이 `start` 메소드를 재정의하거나 재정의하는 대신 `NSOperation` 오브젝트에 어떠한 의미 있는 커스터마이징을 한다면, 커스텀 오브젝트가 이러한 키 경로에 대한 KVO 준수를 유지하는지를 보장해야 합니다. `start` 메소드를 재정의할 때, 당신이 가장 신경 써야 하는 키 경로는 `isExecuting`과 `isFinished`입니다. 이것들은 그 프로퍼티를 다시 구현하는 것으로부터 가장 흔하게 영향을 받는 키 경로들입니다.

다른 오퍼레이션 오브젝트들 이외의 것에 대한 의존성 지원을 구현하고 싶다면, `isReady` 프로퍼티를 재정의하고, 커스텀 의존성이 만족될 때까지 강제로 `false`를 반환하게 할 수 있습니다. (커스텀 의존성을 구현할 때, `NSOperation` 클래스가 제공하는 기본 의존성 관리 시스템을 지원한다면 `isReady` 프로퍼티 재정의에서 `super`를 호출해야 합니다.) 오퍼레이션 오브젝트의 준비 상태가 변화할 때, 그러한 변화를 보고하기 위해 `isReady` 키 경로에 대한 KVO 알림을 생성하십시오. `addDependency(_:)`나 `removeDependency(_:)` 메소드를 재정의하지 않는다면, `dependencies` 키 경로에 대한 KVO 알림에 대해 걱정할 필요는 없습니다.

`NSOperation`의 다른 키 경로에 대한 KVO 알림을 생성할 수 있을지라도, 그렇게 할 필요는 없습니다. 오퍼레이션을 취소할 필요가 있다면, 간단하게 이미 존재하는 `cancel` 메소드를 호출하기만 하면 됩니다. 비슷하게, 오퍼레이션 오브젝트에 대한 큐 우선순위 정보를 수정할 필요도 거의 없습니다. 마지막으로, 당신의 작업이 동시성 상태를 동적으로 변경하는 능력이 없다면, `isConcurrent` 키 경로에 대한 KVO 알림을 제공할 필요가 없습니다.

Key-Value Observing Programming Guide에서 키-값 옵저빙 및 커스텀 오브젝트에서의 지원에 대한 정보를 확인하십시오.

## 오퍼레이션 오브젝트의 실행 행동 커스터마이징하기

오퍼레이션 오브젝트의 구성은 당신이 그것들을 생성한 후에 일어나나 큐에 추가하기 전에 일어납니다. 이 섹션에서 기술하는 구성의 종류는 모든 오퍼레이션 오브젝트에 적용할 수 있으며, `NSOperation` 클래스를 서브클래싱하였거나, 이미 존재하는 서브클래스를 사용한 것과는 관계가 없습니다.

### 오퍼레이션 간 의존성 구성

의존성은 개별 오퍼레이션 오브젝트의 실행을 직려로하하는 방법입니다. 다른 오퍼레이션들에 의존하는 어떠한 오퍼레이션은 그것이 의존하는 모든 오퍼레이션들이 실행을 완료하기 전까지는 실행을 시작할 수 없습니다. 그러므로, 두 오퍼레이션 오브젝트 간 간단한 1대1 의존성을 생성하거나, 복잡한 오브젝트 의존성 그래프를 만들기 위해 의존성을 사용할 수 있습니다.

두 오퍼레이션 오브젝트 간에 의존성을 만들기 위해 `NSOpeation`의  `addDependency(_:)` 메소드를 사용합니다. 이 메소드는 현재 오퍼레이션에서, 매개 변수로 지정한 타겟 오퍼레이션으로 단방향 의존성을 생성합니다. 이 의존성은 현재 오브젝트가 타겟 오브젝트의 실행 완료까지 실행을 시작할 수 없다는 것을 의미합니다. 의존성들은 또한 같은 큐에 잇는 오퍼레이션에 대하여 제한이 없습니다. 오퍼레이션 오브젝트들은 그 자신의 의존성을 관리하며 오퍼레이션 간에 의존성을 만들고 그 모두를 다른 큐에 추가하는 것은 완벽하게 받아들여집니다. 그러나, 받아들여지지 않는 한 가지는 오퍼레이션 간 원형 의존성을 만드는 것입니다. 이렇게 하는 것은 영향을 받는 오퍼레이션이 실행되지 않도록 하는 프로그래머의 에러입니다.

모든 오퍼레이션의 의존성 자체가 실행을 완료하면, 오퍼레이션 오브젝트는 정상적으로 실행을 준비하게 됩니다. (`isReady` 프로퍼티의 행동을 커스터마이징한다면, 오퍼레이션의 준비 상태는 당신이 설정한 기준에 따라 결정됩니다.) 오퍼레이션 오브젝트가 큐 안에 있다면, 그 큐는 어느 때나 오퍼레이션의 실행을 시작할 수 있습니다. 수동으로 오퍼레이션을 실행할 계획이 있다면, 그것은 그 오퍼레이션의 `start` 메소드의 호출에 달려 있습니다.

**중요** 오퍼레이션들의 실행 또는 그것들을 오퍼레이션 큐에 추가히기 이전에 항상 의존성을 구성해야 합니다. 이후에 추가된 의존성은 주어진 오퍼레이션 오브젝트를 실행으로부터 방지하지 않습니다.

의존성은 오브젝트의 상태가변화할 때마다 적절한 KVO 알림을 보내는 각각의 오퍼레이션 오브젝트에 달려 있습니다. 오퍼레이션 오브젝트의 행동을 커스터마이징한다면, 의존성과 관련된 이슈를 피하기 위해 커스텀 코드에서 적절한 KVO 알림을 생성할 필요가 있습니다. Maintaning KVO Compliance에서 KVO 알림 및 오퍼레이션 오브젝트에 대한 정보를 확인하십시오. NSOperation Class Reference에서 의존성 구성에 대한 추가 정보를 확인하십시오.

### 오퍼레이션의 실행 우선순위 변경하기

큐에 추가된 오퍼레이션에 대하여, 실행 순서는 먼저 큐에 들어간 오퍼레이션의 준비 상태에 따라 결정되며, 그것들의 상대 우선순위에 따라 결정됩니다. 준비 상태는 다른 오퍼레이션에 대한 어떠한 오퍼레이션의 의존성에 의해 결정됩니다. 하지만 우선순위 단계는 오퍼레이션 오브젝트 그 자체의 특성입니다. 기본적으로, 모든 새로운 오퍼레이션 오브젝트들은 "일반*normal*" 의존성을 가지고 있습니다. 하지만 오브젝트의 `queuePriority` 프로퍼티를 사용하여 필요할 때 그 우선순위를 증가시키거나 감소시킬 수 있습니다.

우선순위 수준은 같은 오퍼레이션 큐 안에 있는 오퍼레이션들에 대해서만 적용됩니다. 애플리케이션이 여러 개의 오퍼레이션 큐를 가지고 있다면, 각각의 큐는 다른 큐와 독립적으로 소유한 오퍼레이션들의 우선 순위를 매깁니다. 그러므로, 다른 큐에 있는 우선 순위가 높은 오퍼레이션 이전에 우선 순위가 낮은 오퍼레이션을 실행하는 것이 여전히 가능합니다.

우선순위 수준은 의존성을 대체하지 않습니다. 우선순위는 오퍼레이션들이 현재 준비된 오퍼레이션 큐에 대해서 실행 시작의 순서를 결정합니다. 에를 들어, 큐가 우선 순위가 높은 오퍼레이션과 우선 순위가 낮은 오퍼레이션 모두를 포함하고 있고 그 모두가 준비되었을 때, 큐는 먼저 우선 순위가 높은 오퍼레이션을 실행합니다. 그러나, 우선 순위가 높은 오퍼레이션이 준비되지 않았으나 우선 순위가 낮은 오퍼레이션이 준비되었다면, 큐는 먼저 우선 순위가 낮은 오퍼레이션을 실행합니다. 또다른 오퍼레이션이 종료되기까지 어떠한 오퍼레이션이 시작하는 것을 막기를 원한다면, 의존성(오퍼레이션 간 의존성 구성에서 기술됨)을 사용해야 합니다.

### 기반 쓰레드 우선 순위 변경하기

오퍼레이션의 기반에 깔린 쓰레드의 실행 우선순위를 구성하는 것이 가능합니다. 시스템의 쓰레드 정책은 커널에 의해 관리되지만, 일반적으로 우선 순위가 높은 쓰레드는 우선 순위가 낮은 쓰레드보다 실행되기에 더 많은 기회가 주어집니다. 오퍼레이션 오브젝트에서, 당신은 0.0에서 1.0까지의 부동소수점 값으로 쓰레드 우선 순위를 지정합니다. 0.0은 가장 낮은 우선 순위이고, 1.0은 가장 높은 우선 순위입니다. 특정 쓰레드 우선 순위를 지정하지 않았다면, 오퍼레이션은 기본 쓰레드 우선 순위인 0.5로 동작합니다.

오퍼레이션의 쓰레드 우선 순위를 설정하기 위해, 큐에 추가하거나 수동으로 실행하기 전에 오퍼레이션 오브젝트에서 `threadPriority` 프로퍼티를 사용해야 합니다. 오퍼레이션을 실행할 때가 되면, 기본 `start` 메소드는 현재 쓰레드의 우선 순위를 수정하기 위해 당신이 지정한 값을 사용합니다. 이 새로운 우선 순위는 오퍼레이션의 `main` 메소드의 지속 기간 동안만 효과를 유지합니다. 오퍼레이션의 컴플리션 블록을 포함한 모든 다른 코드들은 기본 쓰레드 우선 순위에서 동작합니다. 동시 오퍼레이션을 생성한다면, 그래서 `start` 메소드를 재정의한다면, 당신은 쓰레드 우선 순위를 구성해야 합니다.

> `threadPriority`는 deprecated 되었으며, 대신 `qualityOfService` 프로퍼티를 사용한다.

### 컴플리션 블록 설정하기

오퍼레이션은 주요 작업의 실행을 완료했을 때 컴플리션 블록을 실행할 수 있습니다. 주요 작업의 부분에서 고려하지 않은 어떠한 작업을 수행하기 위해 컴플리션 블록을 사용할 수 있습니다. 예를 들어, 관심 있는 클라이언트에게 오퍼레이션이 완료되었음을 통지하기 위해 이 블록을 사용할 수 있습니다. 동시 오퍼레이션 오브젝트는 이 블록을 사용하여 마지막 KVO 알림을 생성할 수도 있습니다.

컴플리션 블록을 설정하기 위해 `completionBlock` 프로퍼티를 사용하십시오. 당신이 이 프로퍼티에 넘겨준 블록은 인자를 갖지 않으며 반환값도 없어야 합니다.

## 오퍼레이션 오브젝트를 구현하는 팁

오퍼레이션 오브젝트를 구현하기 꽤 쉽다고 할지라도, 당신이 코드를 작성하고 있을 때 인지해야 할 몇 가지 것들이 있습니다. 다음의 섹션은 당신의 오퍼레이션 오브젝트를 위한 코드를 작성하고 있을 때 고려해야 하는 요소들을 기술합니다.

### 오퍼레이션 오브젝트의 메모리 관리

다음의 섹션은 오퍼레이션 오브젝트의 좋은 메모리 관리를 위한 주요 요소를 기술합니다. Advanced Memory Management Programming Guide에서 Objective-C 프로그램의 메모리 관리에 대한 정보를 확인하십시오.

#### 쓰레드 당 저장소*per-thread storage* 피하기

대부분의 오퍼레이션이 쓰레드에서 실행된다 할지라도, 동시적이지 않은 오퍼레이션의 경우에 그 쓰레드는 보통 오퍼레이션 큐에 의해 제공됩니다. 오퍼레이션 큐가 당신을 위해 쓰레드를 제공한다면, 그 쓰레드는 큐가 소유하고 있으며 오퍼레이션에 의해 간섭받지 않을 것이라는 것을 고려해야 합니다. 특히, 당신 자신이 생성하거나 관리하지 않는 쓰레드와 어떠한 데이터도 연관시켜서는 안됩니다. 오퍼레이션 큐가 관리하는 쓰레드들은 시스템과 애플리케이션의 필요에 따라 오고 갑니다. 그러므로, 쓰레드 당 저장소를 사용하여 오퍼레이션 간에 데이터를 넘기는 것은 신뢰할 수 없으며 실패할 것입니다.

오퍼레이션 오브젝트의 경우에, 어떠한 경우에도 쓰레드 당 저장소를 사용해야 하는 이유가 없습니다. 당신이 오퍼레이션 오브젝트를 초기화할 때, 그 작업을 수행하기 위해 필요한 모든 것을 담은 오브젝트를 제공해야 합니다. 그러므로, 오퍼레이션 오브젝트 그 자체는 당신이 필요로 하는 문맥적 저장소를 제공합니다. 모든 들어오고 나가는 데이터는 애플리케이션에 통합되어 더이상 필요로 하지 않을 때까지 그 곳에 저장되어야 합니다.

#### 필요하다면 오퍼레이션 오브젝트에 참조를 유지하기

오퍼레이션 오브젝트는 비동기적으로 동작하기 때문에, 당신이 그것들을 생성하고 그에 대해 잊어버릴 수 있다는 것을 가정하지 마십시오. 그것들은 여전히 오브젝트이며 코드가 필요로 하는 그것들에 대한 참조를 관리하는 것은 당신에게 달려 있습니다. 이는 특히 어떠한 오퍼레이션이 완료된 후 결과 데이터를 돌려받을 필요가 있을 때 중요합니다.

당신이 오퍼레이션에 대한 참조를 항상 유지해야 하는 이유는, 나중에 큐에게 오브젝트를 요청할 기회를 얻지 못하기 때문입니다. 큐는 가능한 한 빠르게 오퍼레이션을 디스패치하고 실행하는 데 모든 노력을 기울입니다. 많은 경우에, 큐는 거의 오퍼레이션이 추가된 직후에 그 실행을 시작합니다. 당신의 코드가 오퍼레이션에 대한 참조를 얻기 위해 큐로 되돌아갈 때, 그 오퍼레이션은 이미 종료되어 큐로부터 제거되어 있을 수 있스빈다.

### 에러 및 예외 처리하기

오퍼레이션은 애플리케이션에서 근본적으로 구체적인 엔티티이기 때문에, 발생하는 어떠한 에러나 예외를 처리할 책임이 있습니다. `NSOperation` 클래스가 제공하는 기본 `start` 메소드는 예외를 캐치하지 않습니다. 당신의 코드는 항상 예외를 캐치하고 숨길 수 있습니다. 에러 코드를 확인하고 필요하다면 애플리케이션의 적절한 부분에 통지할 필요도 있습니다. `start` 메소드를 교체한다면, 기반 쓰레드의 스코프에서 떠나는 것을 막기 위해 커스텀 구현에서 비슷하게 어떠한 예외를 캐치하는 것을 구현해야 합니다.

당신이 처리하기 위해 준비해야 하는 에러 상황의 타입은 다음과 같습니다.

- UNIX의 `errno` 양식의 에러 코드를 확인하고 처리하기
- 메소드나 함수가 반환하는 명시적인 에러 코드 확인하기
- 당신의 코드나 시스템 프레임워크가 던지는 예외 확인하기
- `NSOperation` 클래스 자체가 던지는 예외를 확인하며, 다음의 상황에서 예외를 던집니다.
  - 오퍼레이션이 실행 준비가 되어 있지 않으나 그것의 `start` 메소드가 호출될 때
  - 오퍼레이션이 실행 중이거나 종료되었으며(취소되었기 때문에 가능성 있음), 그것의 `start` 메소드가 다시 호출될 때
  - 이미 실행중이거나 중료된 오퍼레이션에 컴플리션 블록을 추가하려 할 때
  - 취소된 `NSInvocationOperation` 오브젝트로부터 결과를 받으려 할 때

커스텀 코드가 예외나 에러를 마주칠 때, 당신은 애플리케이션의 나머지 부분에 에러를 전파하기 위해 필요한 모든 조치를 취해야 합니다. `NSOperation` 클래스는 에러 결과 코드나 예외를 애플리케이션의 다른 부분에 넘기기 위한 명백한 메소드를 제공하지 않습니다. 그러므로, 그러한 정보가 애플리케이션에서 중요하다면, 필수적인 코드를 제공해야 합니다.

## 오퍼레이션 오브젝트의 적절한 스코프 결정하기

임의로 많은 수의 오퍼레이션을 오퍼레이션 큐에 추가할 수 있을지라도, 그렇게 하는 것은 실용적이지 않습니다. 여느 오브젝트처럼, `NSOperation` 클래스의 인스턴스는 메모리를 소비하며 그 실행과 관련된 실제적인 비용을 가지고 있습니다. 각각의 오퍼레이션 오브젝트들이 오직 작은 양의 작업을 한다면, 그리고 그러한 수만 개의 오퍼레이션 오브젝트를 생성한다면, 실제로 작업을 하는 것보다 디스패칭하는 데 더 많은 시간을 사용하고 있음을 발견할 것입니다. 그리고 애플리케이션이 이미 메모리에 제약적이라면, 메모리에 있는 수만 개의 오퍼레이션 블록이 퍼포먼스의 수준을 낮춘다는 것을 발견할 것입니다.

오퍼레이션을 능률적으로 사용하기 위한 실마리는, 당신이 수행할 필요가 있는 작업량과 컴퓨터를 분주하게 하는 것 사이에서 적절한 균형을 맞추어야 하는 것입니다. 오퍼레이션이 이성적인 작업량을 수행하도록 하십시오. 예를 들어, 애플리케이션이 100개의 다른 값에 대해서 같은 작업을 수행하기 위해 100개의 오퍼레이션 오브젝트를 생성한다면, 대신 각각 10개의 값을 처리하기 위한 10개의 오퍼레이션 블록을 생성하는 것을 고려하십시오.

또한 한번에 큐에 많은 양의 오퍼레이션을 추가하지 않아야 합니다. 오퍼레이션 오브젝트가 처리될 수 있는 거솝다 빠르게 그것들을 큐에 연속적으로 추가하지 않아야 합니다. 큐에서 오퍼레이션 오브젝트가 넘치게 하는 대신, 일괄적으로*in batches* 그러한 오브젝트를 생성하십시오. 하나의 배치가 실행을 완료했을 때, 컴플리션 블록을 사용하여 애플리케이션이 새로운 배치를 생성하라고 하십시오. 해야 하는 많은 작업들이 있을 때, 큐를 충분한 오퍼레이션들도 채워서 컴퓨터의 분주한 상태를 유지하기를 원할 것입니다. 하지만 애플리케이션이 한번에 많은 오퍼레이션을 생성하여 애플리케이션이 메모리를 과도하게 사용하는 것을 원하지 않습니다.

물론, 당신이 생성하는 오퍼레이션 오브젝트의 수, 각각 수행하는 작업량은 변동하기 쉬우며 전적으로 애플리케이션에 의존합니다. Instruments와 같은 도구를 항상 사용하여 능률과 속도 사이의 적절한 균형을 찾을 수 있습니다. Performance Overview에서 코드에 대한 수치를 얻기 이ㅜ한 Instruments 및 다른 퍼포먼스 툴에 대해 확인하십시오.

## 오퍼레이션 실행하기

궁극적으로, 애플리케이션은 관련 작업을 하기 위해 오퍼레이션을 실행하는 것을 필요로 합니다. 이 섹션에서, 당신은 오퍼레이션을 실행하는 것뿐만 아니라 런타임에서 오퍼레이션의 실행을 다룰 수 있는 방법을 배웁니다.

### 오퍼레이션 큐에 오퍼레이션 추가하기

지금까지, 오퍼레이션을 실행하는 가장 쉬운 방법은 오퍼레이션 큐를 사용하는 것이었습니다. 이는 `NSOperation` 클래스의 인스턴스였습니다. 애플리케이션은 사용하려는 오퍼레이션 큐를 생성하고 유지 관리할 책임이 있습니다. 애플리케이션은 어떠한 큐의 개수라도 가질 수 있으나, 주어진 시점에 얼마나 많은 오퍼레이션을 실행할 수 있는지에 대한 실용적인 한계가 있습니다. 오퍼레이션 큐는 시스템과 함께 동작하여 사용 가능한 코어와 시스템 부하에 따라 적절한 동시 오퍼레이션의 개수를 제한합니다. 그러므로, 추가적인 큐를 생성하는 것은 추가적인 오퍼레이션을 실행할 수 있다는 것을 의미하지 않습니다.

큐를 생성하기 위해, 여느 오브젝트처럼 애플리케이션에서 그것을 할당하십시오.

```swift
let queue: OperationQueue = OperationQueue()
```

큐에 오퍼레이션을 추가하기 위해 `addOperation(_:)` 메소드를 사용합니다. `addOperations(_:waitUntilFinished:)` 메소드를 사용하여 오퍼레이션 그룹을 추가할 수도 있으며, `addOperation` 메소드를 사용하여 (상응하는 오퍼레이션 오브젝트 없이) 큐에 직접 블록 오브젝트를 추가할 수 있습니다. 이러한 메소드들은 오퍼레이션 또는 오퍼레이션들을 큐에 추가하고, 큐가 그것들을 처리하기 시작해야 한다고 통지합니다. 대부분의 경우, 오퍼레이션은 큐에 추가된 직후 실행됩니다. 하지만 오퍼레이션 큐는 몇 가지 이유로 인해 큐에 추가된 오퍼레이션의 실행을 지연시킬 수 있습니다. 특히, 큐에 추가된 오퍼레이션들이 아직 완료되지 않은 다른 오퍼레이션들에 의존적일 때 실행이 지연될 수 있습니다. 오퍼레이션 큐 그 자체가 중단되었거나 이미 동시 오퍼레이션의 최대 개수를 실행하고 있을 때 실행이 지연될 수 있습니다.

```swift
// 인자로 오퍼레이션 추가
queue.addOperation(closure)

// 블록 오브젝트로 오퍼레이션 추가
queue.addOperation {
  print(1)
}

// 여러 개의 오퍼레이션 추가. operation의 타입은 `Operation`.
queue.addOperations([operation], waitUntilFinished: true)
```

오퍼레이션 오브젝트를 큐에 추가하기 전, 모든 필수적인 구성 및 수정을 해야 합니다. 일단 추가되면, 오퍼레이션은 어느때나 실행될 수 있기 때문인데, 의도한 효과를 내기 위해 변화시키는 것이 너무 늦을 수 있기 때문입니다.

`NSOperationQueue` 클래스가 오퍼레이션의 동시 실행을 위해 설계되었다 할지라도, 하나의 큐가 한 번에 오직 하나의 오퍼레이션을 실행하도록 강제할 수 있습니다. `maxConcurrentOperationCount` 프로퍼티는 오퍼레이션 큐 오브젝트에 대한 동시 오퍼레이션의 최대 개수를 구성하게 합니다. 1을 이 프로퍼티에 설정하여 큐가 한번에 오직 하나의 오퍼레이션만 실행하게 할 수 있습니다. 한번에 오직 하나의 오퍼레이션만 실행될지라도, 실행 순서는 여전히 각 오퍼레이션의 준비 상태, 할당된 우선 순위 등 다른 요소들에 기반합니다. 그러므로, 직렬화된 오퍼레이션 큐는 Grand Central Dispatch의 직렬 디스패치 큐와 같은 행동을 제공한다고 할 수 없습니다. 오퍼레이션 오브젝트의 실행 순서가 중요한 것이라면, 큐에 오퍼레이션을 추가힉 전에 순서를 설정하기 위해 의존성을 사용해야 합니다. Configuring Interoperation Dependencies에서 의존성 구성에 대한 정보를 확인하십시오.

NSOperationQueue Class Reference에서 오퍼레이션 큐 사용에 대한 정보를 확인하십시오. Creating Serial Dispatch Queues에서 직렬 디스패치 큐에 대한 정보를 확인하십시오.

### 수동으로 오퍼레이션 실행하기

오퍼레이션 큐가 오퍼레이션 오브젝트를 실행하는데 가장 편리한 방법일지라도, 큐 없이 오퍼레이션을 실행하는 것도 가능합니다. 그러나, 오퍼레이션을 수동으로 실행하기 위해 선택한다면, 코드에서 취해야 할 몇 가지 대응책이 있습니다. 특히, 오퍼레이션을 실행될 준비가 되어 있어야 하고, 항상 `start` 메소드를 사용하여 시작해야 합니다.

어떠한 오퍼레이션은 `isReady` 프로퍼티가 `true`를 반환할 때까지 동작될 수 없다고 간주됩니다. `isReady` 프로퍼티는 `NSOperation` 클래스의 의존성 관리 시스템에 통합되어 오퍼레이션의 의존성에 대한 상태를 제공합니다. 오직 오퍼레이션이 실행을 시작하기에 자유로울 때에만 그 의존성이 명확합니다.

수동으로 오퍼레이션을 실행할 때, 실행을 시작하기 위해 항상 `start` 메소드를 사용해야 합니다. 당신은 `main` 또는 다른 메소드 대신에 이 메소드를 사용합니다. `start` 메소드는 당신의 커스텀 코드가 실제로 동작하기 전에 몇 가지 안전 확인을 수행하기 때문입니다. 특히, 기본 `start` 메소드는 오퍼레이션이 그 의존성들을 올바르게 처리할 필요가 있다는 KVO 알림을 생성합니다. 또한 그것이 이미 취소되었거나, 오퍼레이션이 실제로 동작할 준비가 되어 있지 않아 예외를 던질 때 오퍼레이션의 실행을 올바르게 방지합니다.

애플리케이션이 동시 오퍼레이션 오브젝트를 정의한다면, 그것들을 실행하기 전에 오퍼레이션의 `isAsynchronous` 프로퍼티를 호출하는 것도 고려해야 합니다. 이 프로퍼티가 `false`를 반환하는 경우, 당신의 로컬 코드는 현재 쓰레드에서 동기적으로 오퍼레이션을 실행해야 하는지, 먼저 개별 쓰레드를 생성해야 하는지 결정할 수 있습니다. 그러나, 이러한 확인 절차를 구현하는 것은 전적으로 당신에게 달려 있습니다.

다음의 코드는 수동으로 오퍼레이션을 실행하기 전에 수행해야 하는 확인 작업을 보여줍니다. 그 프로퍼티가 `false`를 반환한다면, 타이머를 등록하고 나중에 그 메소드를 다시 호출할 수 있습니다. 그리고 나서 그 프로퍼티가 `true`를 반환할 때까지 타이머를 다시 스케줄링하게 할 수 있습니다. 이는 오퍼레이션이 취소될 수 있기 때문에 발생할 수 있습니다.

```swift
func performOperation(_ operation: Operation) -> Bool {
  var ranIt = false
  if operation.isReady && !operation.isCancelled {
    if !operation.isAsynchronous {
      operation.start()
    } else {
      Thread.detachNewThreadSelector(#selector(start), toTarget: operation, with: nil)
      ranIt = true
    }
  } else if operation.isCancelled {
    willChangeValue(forKey: "isFinished")
    willChangeValue(forKey: "isExecuting")
    executing = false
    finished = true
    didChangeValue(forKey: "isExecuting")
    didChangeValue(forKey: "isFinished")
    ranIt = true
  }
  return ranIt
}
```

### 오퍼레이션 취소하기

일단 오퍼레이션 큐에 오퍼레이션 오브젝트가 추가되었다면, 그것은 큐에 의해 효과적으로 소유되며 제거될 수 없습니다. 오퍼레이션을 큐에서 빼내는 유일한 방법은 그것을 취소하는 것입니다. 오브젝트의 `cancel` 메소드를 호출하여 단일 개별 오퍼레이션 오브젝트를 취소할 수 있고, 큐 오브젝트의 `cancelAllOperations` 메소드를 호출하여 큐에 잇는 모든 오퍼레이션 오브젝트를 취소할 수 있습니다.

더이상 오퍼레이션들이 필요가 없다는 것을 확신할 때에만 그것을 취소해야 합니다. 취소 명령을 발행하는 것은 오퍼레이션 오브젝트를 "취소" 상태로 만들며, 그것이 실행되는 것을 방지합니다. 취소된 오퍼레이션은 여전히 "완료"된 것으로 간주되기 때문에, 그것에 의존하는 오브젝트들은 그 의존성을 지우기 위한 적절한 KVO 알림을 받습니다. 그러므로, 선택적으로 오퍼레이션을 취소하기보다는, 애플리케이션이 중지되거나 사용자가 특히 취소를 요청하는 것과 같은 몇몇 중요한 이벤트에 대한 응답으로 큐에 들어간 모든 오퍼레이션을 취소하는 것이 더 일반적입니다.

### 오퍼레이션이 완료되기 기다리기

최상의 퍼포먼스를 위해, 오퍼레이션이 가능한 한 비동기적이게 되게 오퍼레이션을 설계해야 하며, 이는 오퍼레이션이 실행 중인 동안 추가적인 작업을 하는 것에 자유롭도록 합니다. 오퍼레이션을 생성하는 코드가 그 오퍼레이션에 대한 결과도 처리한다면, 오퍼레이션이 완료되기까지 그 코드를 가로막기 위해 `NSOperation`의 `waitUntilFinished` 메소드를 사용할 수 있습니다. 그렇지만, 일반적으로 할 수 있다면 이 메소드를 호출하지 않는 것이 가장 좋습니다. 현재 쓰레드를 가로막는 것이 편리한 솔루션이지만, 그것은 코드에서 더 많은 직렬화를 도입하며 동시성의 전체 양을 제한합니다.

**중요** 애플리케이션의 메인 쓰레드에서의 오퍼레이션을 기다려서는 안됩니다. 부차적인 쓰레드나 또다른 오퍼레이션에서만 그러한 작업을 수행해야 합니다. 메인 쓰레드를 가로막는 것은 애플리케이션이 사용자 이벤트에 응답하는 것을 못하게 하여 애플리케이션이 응답을 하지 않게 할 수 있습니다.

하나의 오퍼레이션이 종료되는 것을 기다리는 것뿐만 아니라, `NSOperationQueue`의 `waitUntilAllOperationsAreFinished` 메소드를 호출하여 큐에 있는 모든 오퍼레이션을 기다리게 할 수 있습니다. 전체 큐가 완료되기를 기다릴 때, 애플리케이션의 다른 쓰레드가 여전히 큐에 오퍼레이션을 추가할 수 있으며, 기다림을 연장할 수 있다는 것을 인지하십시오.

### 큐 일시정지 및 재개

오퍼레이션의 실행에 일시적인 중지를 발행하기 원한다면, `isSuspended` 프로퍼티를 사용하여 상응하는 오퍼레이션 큐를 일시정지할 수 있습니다. 큐를 일시정지하는 것은 이미 실행 중인 오퍼레이션이 작업 도중에 중지되는 것을 유발하지 않습니다. 새로운 오퍼레이션이 실행을 위해 스케줄링되는 것을 방지하는 것뿐입니다. 어떠한 진행 중인 작업을 중단하라는 사용자 요청의 대한 응답으로 큐를 중단할 수 있으며, 결국에 사용자는 그 작업이 재개되기를 원하는 것을 기대하기 때문입니다.