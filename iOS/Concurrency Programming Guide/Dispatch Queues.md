# Dispatch Queues

> Objective-C쪽 설명이 많기 때문에 일부분을 임의로 들어내고 Swift식 설명으로 대체하였습니다.

Grand Central Dispatch(GCD) 디스패치 큐는 작업을 수행하기 위한 강력한 도구입니다. 디스패치 큐는 임의의 코드 블록을 호출자의 관점에서 비동기 또는 동기적으로 실행할 수 있게 합니다. 개별 쓰레드에서 수행하려고 하는 거의 모든 작업을 디스패치 큐를 사용하여 수행할 수 있습니다. 디스패치 큐의 이점은 이에 상응하는 쓰레드 코드보다 훨씬 더 능률적이고 사용하기 단순하게 이러한 작업을 실행할 수 있다는 것입니다.

이 챕터는 디스패치 큐에 대해 소개하며, 애플리케이션에서 일반적은 작업을 실행하기 위해 디스패치 큐를 사용하는 방법을 소개합니다. 디스패치 큐로 존재하는 쓰레드 관련 코드를 교체하기 원한다면, Migrating Away from Threads에서 그 방법에 대한 추가 팁을 찾을 수 있습니다.

## 디스패치 큐에 관하여

디스패치 큐는 애플리케이션에서 비동기 혹은 동기적으로 작업을 수행하기 위한 쉬운 방법입니다. *작업*은 애플리케이션이 수행할 필요가 있는 어떠한 작업을 말합니다. 예를 들어, 어떠한 계산, 자료구조의 생성 또는 수정, 파일로부터 데이터를 읽는 것을 처리하는 것과 같은 작업을 정의할 수 있습니다. 이에 상응하는 코드를 함수 또는 블록 오브젝트 내에 위치시키고 이를 디스패치 큐에 추가하여 작업을 정의합니다.

디스패치 큐는 당신이 그것에 제출한 작업을 관리하는 오브젝트와 같은 구조입니다. 모든 디스피채 큐는 선입선출의 자료구조입니다. 그러므로, 당신이 큐에 추가한 작업은 항상 추가된 순서와 같은 순서로 시작됩니다. GCD는 당신을 위해 자동으로 몇몇 디스패치 큐를 제공하지만, 특정 목적을 위한 것을 생성할 수 있습니다. 다음의 테이블은 애플리케이션에서 사용 가능한 디스패치 큐의 종류 및 그것들을 사용하는 방법에 대해 소개합니다.

| 종류             | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| 직렬             | 직렬 큐 (private dispatch queue) 는 큐에 추가된 순서대로 한번에 하나의 작업을 실행합니다. 현재 실행 중인 작업은 그 디스패치 큐에 의해 관리되는 개별 쓰레드에서 동작합니다. 이는 작업별로 다양할 수 있습니다. 직렬 큐는 지정된 리소스에 동기적으로 접근하기 위해 종종 사용됩니다.<br />당신은 필요한 만큼 많은 직렬 큐를 생성할 수 있으며, 각각의 큐는 모든 다른 큐의 관점에서 동시적으로 작동합니다. 즉, 당신이 네 개의 직렬 큐를 생성한다면, 각각의 큐는 한번에 오직 하나의 작업을 실행하나, 최대 네 개의 작업은 각각의 큐에서 하나씩, 여전히 동시적으로 실행될 수 있다는 것입니다. Creating Serial Dispatch Queues에서 직렬 큐를 생성하는 방법에 대해 알아보십시오. |
| 병렬             | 병렬 큐 (global dispatch queue의 타입) 는 동시적으로 하나 또는 그 이상의 작업을 실행하지만, 작업들은 여전히 큐에 추가된 순서대로 시작됩니다. 현재 실행 중인 작업은 디스패치 큐가 관리하는 개별 쓰레드에서 동작합니다. 주어진 지점에서 실행되는 작업의 정확한 개수는 쉽게 변화하며 시스템 상태에 의존합니다.<br />`DISPATCH_QUEUE_CONCURRENT`를 큐 타입으로 지정하여 동시 디스패치 큐를 생성할 수 있습니다. 게다가 애플리케이션이 사용할 수 있는 사전 정의된 네 개의 글로벌 동시 큐가 있습니다. Getting the Global Concurrent Dispatch Queues에서 글로벌 동시 큐를 얻기 위한 방법을 확인하십시오. |
| 메인 디스패치 큐 | 메인 디스패치 큐는 전역적으로 이용 가능한 직렬 큐이며, 애플리케이션의 메인 쓰레드에서 작업을 실행합니다. 이 큐는 애플리케이션의 (런루프가 존재하는 경우) 런루프와 함께 동작하여, 큐에 추가된 작업의 실행을 런루프에 연결된 다른 이벤트 소스의 실행과 연동시킵니다. 애플리케이션의 메인 쓰레드에서 동작하기 때문에, 메인 큐는 애플리케이션의 주요한 동기화 지점으로 사용됩니다.<br />메인 디스패치 큐를 생성할 필요가 없을지라도, 애플리케이션이 그것을 적절하게 비울 수 있도록 할 필요가 있습니다. Performing Tasks on Main Thread에서 이 큐를 관리하는 방법을 알아보십시오. |

애플리케이션에 동시성을 추가하는 것과 관련하여, 디스패치 큐는 쓰레드를 넘어서는 몇 가지 이점을 제공합니다. 가장 직접적인 이점은 작업 큐 프로그래밍 모델의 단순함입니다. 쓰레드로는 수행하기 원하는 작업과 쓰레드 자체의 생성 및 관리를 위한 코드 모두를 작성해야 합니다. 디스패치 큐는 쓰레드 생성 및 관리를 걱정하지 않고 실제로 수행하기 원하는 작업에 초점을 맞추게 합니다. 대신, 시스템이 당신을 위해 모든 쓰레드 생성 및 관리 작업을 처리합니다. 시스템은 단일 애플리케이션이 할 수 있는 것보다 훨씬 더 능률적으로 쓰레드를 관리할 수 있다는 것이 이점입니다. 시스템은 사용 가능한 리소스와 현재 시스템 상태에 따라 동적으로 쓰레드 숫자를 변동시킬 수 있습니다. 게다가, 시스템은 당신이 스스로 쓰레드를 생성했을 때 할 수 있는 것보다 더 빠르게 작업 실행을 시작할 수 있습니다.

디스패치 큐를 위해 코드를 다시 작성하는 것이 어려울 수 있으나, 쓰레드 코드를 작성하는 것보다 디스패치 큐를 위한 코드를 작성하는 것이 더 쉽습니다. 코드를 작성하기 위한 실마리는 작업이 그 자체를 포함하고 비동기적으로 실행될 수 있게 설계하는 것입니다. (이는 실제로 쓰레드 및 디스패치 큐 모두에서 이루어져야 합니다.) 그러나, 디스패치 큐가 이점을 가지고 있는 곳은 그 예측성에 있습니다. 같은 공유 리소스에 접근하는 두 개의 작업을 가지고 있으나 다른 쓰레드에서 동작한다면, 각각의 쓰레드는 먼저 리소스를 수정할 수 있으며, 두 작업이 동시에 해당 리소스를 수정하지 않도록 락*lock*을 사용할 필요가 있을 것입니다. 디스패치 큐를 사용하여, 두 개의 작업 모두를 직렬 디스패치 큐에 추가하여 오직 하나의 작업만이 어떤 주어진 시간에 그 리소스를 수정하는 것을 보장하도록 할 수 있습니다. 이 종류의 큐 기반 동기화는 락보다 더 능률적입니다. 락은 항상 투쟁하는 경우 및 투쟁하지 않는 경우 모두에서 비용이 비싼 커널 트랩을 요구하기 때문입니다. 반면에 디스패치 큐는 주로 애플리케이션의 프로세스 공간에서 동작하며 정말로 필요할 때 커널 단의 호출을 실행합니다.

직렬 큐에서 동작하고 있는 두 개의 작업이 동시적으로 작동하지 않는다는 것을 지적하는 것이 옳을지라도, 두 개의 쓰레드가 동시에 락을 할 때, 쓰레드가 제공하는 어떠한 동시성은 버려지거나 의미 있게 감소된다는 것을 기억해야 합니다. 더욱 중요한 것은, 쓰레드 모델은 두 개의 쓰레드 생성을 요구하며, 커널 및 유저 공간 메모리 모두를 점유한다는 것입니다. 디스패치 큐는 그 쓰레드들에 대하여 같은 메모리 패널티를 지불하지 않으며, 그들이 사용하는 쓰레드들은 분주한 상태를 유지하며 블록되지 않습니다.

다음은 디스패치 큐에 관하여 기억해야 할 몇 가지 다른 주요 포인트입니다.

- 디스패치 큐는 다른 디스패치 큐의 관점에서 작업을 동시적으로 실행합니다. 작업의 직렬화는 단일 디스패치 큐에 있는 작업들에 제한됩니다.
- 시스템은 어떤 한 시점에 실행 중인 총 작업 개수를 결정합니다. 그러므로, 100개의 다른 큐에 있는 100개의 작업을 가진 애플리케이션은 (100개 또는 그 이상의 효과적인 코어를 가진 것이 아니라면) 모든 작업을 동시적으로 실행하지 않을 수 있습니다.
- 시스템은 시작할 새로운 작업을 선택할 때 큐 우선순위 수준을 고려합니다. Providing a Clean Up Function for a Queue에서 직렬 큐의 우선순위를 설정하는 방법에 대해 알아보십시오.
- 큐에 있는 작업들은 그것들이 큐에 추가된 시점에서 실행될 준비가 되어야 합니다. (코코아의 오퍼레이션 오브젝트를 이전에 사용해 보았다면, 이 행동은 오퍼레이션이 사용하는 모델과 다르다는 것을 알아두십시오.)
- private dispatch queue는 참조가 카운팅되는 오브젝트입니다. 당신의 코드에서 큐를 유지하는 것뿐만 아니라, 디스패치 소스도 큐에 부착될 수 있으며 또한 그 리테인 카운트를 증가시킨다는 것을 인지하십시오. 그러므로, 모든 디스패치 소스가 취소되고 모든 리테인 호출들이 적절한 릴리즈 호출과 균형을 이루는 것을 보장해야 합니다. Memory Management for Dispatch Queues에서 큐를 리테인하고 릴리즈하는 것에 대한 정보를 확인하십시오. About Dispatch Sources에서 디스패치 소스에 대해 알아보십시오.

Grand Central Dispatch(GCD) Reference에서 디스패치 큐를 다루기 위해 사용하는 인터페이스에 대해 알아보십시오.

## 큐와 관련된 기술

디스패치 큐뿐만 아니라, Grand Central Dispatch는 코드를 관리하는 것을 돕기 위해 큐를 사용하는 몇 가지 기술을 제공합니다.

| 기술                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| Dispatch groups     | 디스패치 그룹은 완료를 위해 블록 오브젝트의 집합을 모니터링하는 방법입니다. (당신의 필요에 따라 블록들을 동기 혹은 비동기적으로 모니터링할 수 있습니다.) 그룹들은 다른 작업의 완료에 따라 유용한 동기화 메커니즘을 제공합니다. Waiting on Groups of Queued Tasks에서 그룹을 사용하는 것에 대해 알아보십시오. |
| Dispatch semaphores | 디스패치 세마포어는 전통적인 세마포어와 비슷하나 일반적으로 더 능률적입니다. 디스패치 세마포어는 세마포어를 사용할 수 없기 때문에 호출 쓰레드가 차단되어야할 필요가 있을 때만 커널로 호출됩니다. 세마포어가 사용 가능하다면, 어떠한 커널 호출도 이루어지지 않습니다. Using Dispatch Semaphores to Regulate the Use of Finite Resources에서 디스패치 세마포어를 사용하는 방법에 대한 예를 확인하십시오. |
| Dispatch sources    | 디스패치 소스는 특정 타입의 시스템 이벤트의 응답으로 알림을 생성합니다. 프로세스 알림, 시그널, 디스크립터 이벤트와 같은 이벤트를 모니터링하기 위해 디스패치 소스를 사용할 수 있습니다. 이벤트가 발생할 때, 디스패치 소스는 처리를 위한 특정 디스패치 큐에 작업 코드를 비동기적으로 제출합니다. Dispatch Sources에서 디스패치 소스를 생성하고 사용하는 것에 대한 정보를 확인하십시오. |

## 블록을 사용하여 작업 구현하기

블록 오브젝트는 C 기반 기능이며 C, Objective-C, C++ 코드에서 사용 가능합니다. 블록은 자립된 작업 단위를 정의하는 것을 쉽게 합니다. 그것들은 함수 포인터와 비슷해 보일지라도, 블록은 실제로는 오브젝트를 닮은 기반 자료구조에 기반하여 나타내어지며, 컴파일러에 의해 관리됩니다. 컴파일러는 (관련 데이터와 함께) 사용자가 제공하는 코드를 패키징하고, 힙에 저장하여 애플리케이션 주위로 전달할 수 있는 형태로 캡슐화합니다.

블록의 주요 이점 중 하나는 그들의 어휘적 스코프 바깥에 있는 변수를 사용할 수 있는 능력입니다. 블록을 함수나 메소드 안에 정의할 때, 블록은 어떤 면에서는 전통적인 코드 블록처럼 작용합니다. 예를 들어, 블록은 부모 스코퍼에 정의된 변수의 값을 읽을 수 있습니다. 블록에 의해 접근된 변수는 힙에 있는 블록 자료구조에 복사되어 블록이 나중에 접근할 수 있게 합니다. 블록이 디스패치 큐에 추가될 때, 이 값들은 전형적으로 읽기 전용 포맷으로 남게 됩니다. 그러나, 동기적으로 실행되는 블록은 `__block` 키워드가 선불된 변수를 사용하여 데이터를 상위 호출 스코프로 되돌릴 수 있습니다.

당신은 함수 포인터에서 사용하는 구문과 비슷한 구문을 사용하여 코드 내에 블록을 선언합니다. 블록과 함수 포인터의 주요 차이는 블록의 이름은 애스터리스크 대신 `^`가 앞에 붙는다는 것입니다. 함수 포인터처럼, 블록에 인자를 넘겨줄 수있고 그것으로부터 값을 반환받을 수 있습니다. 다음의 코드는 코드에서 블록을 선언하고 동기적으로 실행하는 방법을 보여줍니다.

> 위의 이야기는 Objective-C 단의 이야기로, Swift에서는 클로저 문법을 사용하면 되겠다.

```swift
let x = 123
let y = 456
let block: (Int) -> Void = { value in print(x, y, value) }
block(789)
```

다음은 블록을 설계할 때 고려해야 하는 주요 가이드라인 중 몇몇에 대한 요약입니다.

- 디스패치 큐를 사용하여 비동기적으로 수행할 계획을 가진 블록에 대하여, 부모 함수 또는 메소드로부터 스칼라 변수를 획득하고 블록 내에서 사용하는 것은 안전합니다. 하지만 호출 컨텍스트에 의해 할당되고 삭제되는 큰 구조체 또는 다른 포인터 기반 변수를 획득하려 하지 않아야 합니다. 블록이 실행되는 때에, 해당 포인터가 참조한 메모리가 사라질 수 있습니다. 물론 메모리 (또는 오브젝트)를 스스로 할당하고 해당 메모리의 소유권을 블록에 명시적으로 양도하는 것은 안전합니다.
- 디스패치 큐는 그것에 추가되는 블록을 복사하며, 실행을 끝낼 때 블록을 릴리즈합니다. 즉, 큐에 블록을 추가히기 전에 명시적으로 블록을 복사할 필요가 없습니다.
- 큐가 작은 작업을 실행하는데 날*raw* 쓰레드보다 더 능률적일지라도, 블록을 생성하고 그것들을 큐에서 실행하는 것에는 여전히 오버헤드가 존재합니다. 블록이 너무 작은 작업을 한다면, 그것을 큐에 디스패치하는 것보다는 인라인에서 실행하는 것이 비용이 더 값쌀 수 있습니다. 블록이 너무 작은 작업을 한다고 말하는 방법은 각각의 경로에 디하여 퍼포먼스 도구를 사용하여 수치를 얻고 그것을 비교하는 것입니다.
- 기반 쓰레드에 관하여 데이터를 캐시하지 마십시오. 데이터는 다른 블록에서 접근 가능하다고 기대하십시오. 같은 큐에 있는 작업들이 데이터를 공유할 필요가 있다면, 데이터를 저장하기 위해 디스패치 큐의 문맥 포인터를 사용하십시오. Storing Custom Context Information with a Queue에서 디스패치 큐의 문맥 데이터에 접근하는 방법에 대한 정보를 확인하십시오.
- 블록이 Objective-C 오브젝트 이상으로 생성한다면, 블록의 코드 일부분을 @autorelease 블록이 감싸게 하여 그러한 오브젝트를 위한 메모리 관리를 처리하는 것을 원할 수 있습니다. GCD의 디스패치 큐가 그 자신이 오토릴리즈 풀을 가지고 있을지라도, 그러한 풀들이 비워지는 것을 보장할 수 없습니다. 애플리케이션이 메모리에 제약적이라면, 당신 자신의 오토릴리즈 풀을 만들어 더욱 주기적인 간격으로 오토릴리즈된 오브젝트에 대하여 메모리에서 해제되도록 하십시오.

Blocks Programming Topics에서 블록, 그것을 선언하고 사용하는 방법에 대하여 알아보십시오. Adding Tasks to a Queue에서 블록을 디스패치 큐에 추가하는 방법에 대하여 알아보십시오.

## 디스패치 큐 생성 및 관리

큐에 작업을 추가하기 전, 어떤 타입의 큐를 사용할 것이며 어떤 의도로 사용할 것인지 결정해야 합니다. 디스패치 큐는 직렬 또는 병렬로 작업을 수행할 수 있습니다. 게다가, 마음에 두고 있는 특정한 사용법을 생각하고 있다면, 그에 따라서 큐의 특성을 구성할 수 있습니다. 다음의 섹션은 디스패치 큐를 생성하고 사용하기 위해 구성하는 방법에 대해 보여줍니다.

### 글로벌 동시 디스패치 큐 얻기

동시 디스패치 큐*concurrent dispatch queue*는 병렬적으로 동작할 수 있는 여러 개의 작업을 가지고 있을 때 유용합니다. 동시 큐는 여전히 선입선출의 구조로 작업을 관리하는 큐입니다. 그러나, 동시 큐는 어떠한 이전 작업이 완료되기 전 추가 작업을 큐에서 빼낼 수도 있습니다. 주어진 순간에 동시 큐에 의해 실행되는 작업의 실제 개수는 변동 가능하며 애플리케이션이 변화하는 상태에 따라 동적으로 변화할 수 있습니다. 많은 요소들이 동시 큐에 의해 실행되는 작업의 개수에 영향을 주며, 사용 가능한 코어의 개수, 다른 프로세스에 의해 행해지는 작업량, 다른 직렬 디스패치 큐에 있는 작업의 개수 및 우선순위 등을 포함합니다.

시스템은 각각의 애플리케이션에 네 개의 동시 디스패치 큐를 제공합니다. 이 큐들은 애플리케이션에서 전역적*global*이며 그 우선순위 수준에 의해 유일하게 구별됩니다. 그것들은 전역적이기 때문에 명시적으로 생성할 수 없습니다. 대신, `dispatch_get_global_queue` 함수를 사용하여 큐들 중 하나를 요청할 수 있습니다.

> Objective-C쪽 이야기. Swift에서는 `DispatchQueue.global(qos:)` 를 통하여 글로벌 큐를 가져올 수 있다. `DispatchQoS` 구조체에는 6개의 사전 정의된 quality of service가 있다.

```swift
let queue: DispatchQueue = DispatchQueue.global(qos: .default)
```

기본 동시 큐를 얻는 것에 더하여, qos를 달리하여 각 우선순위에 대한 큐를 얻을 수 있다. 예상하다시피, 높은 우선 순위를 가진 큐에 있는 작업들은 기본 및 낮은 우선 순위를 가진 큐에 있는 작업들 이전에 실행됩니다. 비슷하게, 기본 큐에 있는 작업들은 낮은 우선 순위를 가진 큐에 있는 작업들 이전에 실행됩니다.

디스패치 큐가 참조 카운팅이 되는 오브젝트라 할지라도, 글로벌 동시 큐를 리테인하고 릴리즈할 필요는 없습니다. 그것들은 애플리케이션에서 전역적이기 때문에, 리테인 및 릴리즈 호출은 무시됩니다. 그러므로, 이 큐들에 참조를 저장할 필요가 없습니다. 참조가 필요하면 `DispatchQueue.global`를 사용하기만 하면 됩니다.

### 직렬 디스패치 큐 생성하기

직렬 큐는 특정 순서로 작업들을 실행하기 원할 때 유용합니다. 직렬 큐는 한번에 오직 하나의 작업을 실행하며 항상 작업들을 큐의 머리 부분으로 밀어냅니다. 공유 리소스나 변하는 자료구조를 지키기 위해 락 대신 직렬 뷰를 사용할 것입니다. 락과는 다르게, 직렬 큐는 작업들이 예측 가능한 순서로 실행될 것임을 보장합니다. 그리고 당신이 비동기적으로 직렬 큐에 작업을 제출하는 한, 큐는 절대 데드락 상태가 되지 않습니다.

동시 큐와는 다르게, 당신이 사용하고 싶은 직렬 큐들은 당신이 명시적으로 생성하고 관리해야 합니다. 애플리케이션에서 직렬 큐를 몇 개라도 생성할 수있으나, 당신이 할 수 있는 가능한 한 많은 작업을 동시에 실행하려는 수단으로 많은 수의 직렬 큐를 단독으로 생성하지 않아야 합니다. 동시적으로 많은 수의 작업을 실행하기 원한다면, 글로벌 동시 큐 중 하나에 작업들을 제출하십시오. 직렬 큐를 생성할 때, 각각의 큐의 목적을 식별하려고 하십시오. 리소스를 보호하거나, 애플리케이션의 어떠한 주요 행동을 동기화하는 것이 그 예가 될 수 있을 것입니다.

다음의 코드는 커스텀 직렬 큐를 생성하기 위한 단계를 보여줍니다. `DispatchQueue`의 이니셜라이저를 사용하며, 큐의 이름, 큐의 특성 집합을 매개변수로 요구합니다. 디버거 및 퍼포먼스 툴은 당신의 작업이 실행되고 있는 방법을 트래킹하는 것을 돕기 위해 큐의 이름을 보여줍니다. 큐의 특성은 미래에 사용할 수 있도록 예약되어 있으며 `nil`이어야 합니다.

```swift
// 직렬 큐 생성
let queue: DispatchQueue = DispatchQueue(label: "com.example.MyQueue")
// 
```

> DispatchQueue 클래스는 `init(label:qos:attributes:autoreleaseFrequency:target)` 의 형태의 이니셜라이저를 가지며, `label`을 제외한 부분은 매개변수 기본값을 갖는다.
>
> 기본적으로 직렬 큐를 만들어내며, `attributes`에 `.concurrent`를 명시해야 동시 큐를 만들 수 있다.
>
> 문서에 자세한 내용이 나와있지 않다..

당신이 생성하는 어떠한 커스텀 큐에 더하여, 시스템은 자동으로 직렬 큐를 생성하고 애플리케이션의 메인 쓰레드에 그것을 바인딩합니다. Getting Common Queues at Runtime에서 메인 쓰레드를 위한 큐를 얻는 방법을 알아보십시오.

### 런타임에서 공통 큐 가져오기

Grand Central Dispatch는 애플리케이션에서 몇 가지 공통 디스패치 큐에 접근하게 하는 함수를 제공합니다.

- `dispatch_get_current_queue`는 deprecated되었으므로 해석하지 않는다.
- `DispatchQueue.main`을 사용하여 애플리케이션의 메인 쓰레드와 연관된 직렬 디스패치 큐를 가져옵니다. 이 큐는 코코아 애플리케이션에 의해 자동으로 생성되며, 애플리케이션을을 위해 `dispatchMain` 함수를 호출하거나, 메인 쓰레드에서 (`CFRunLoopRef` 타입 또는 `NSRunLoop` 오브젝트를 사용하여) 런루프를 구성하는 작업을 합니다.
- `DispatchQueue.global`을 사용하여 공유된 동시 큐 중 어떠한 것을 가져옵니다. Getting Global Concurrent Dispatch Queues에서 더 많은 정보를 확인하십시오.

### 디스패치 큐의 메모리 관리

> 너무 옛날 문서라서.. 더는 못읽겠습니다

---

## 예제

```swift
let queue = DispatchQueue(label: "com.example.Queue1")
queue.async { (1...10).forEach { print($0) } }
queue.async { (11...20).forEach { print($0) } }

// 1부터 10까지 출력된 후 11부터 20까지 출력됨
// 기본적으로 DispatchQueue가 serial queue이기 때문
```

```swift
let queue1 = DispatchQueue(label: "com.example.Queue1")
let queue2 = DispatchQueue(label: "com.example.Queue2")
queue1.async {
  (1...10).forEach { print($0) }
}
queue2.async {
  (11...20).forEach { print($0) }
}

// 매번 출력 결과가 다르게 나옴
// 두 개의 직렬 큐를 만들었고, 각각에 블록을 설정해 두었기 때문.
// 지양해야 하는 방법이다.
```

```swift
let queue = DispatchQueue(label: "com.example.Queue1", attributes: .concurrent)
queue.async {
  (1...10).forEach { print($0) }
}
queue.async {
  (11...20).forEach { print($0) }
}

// 매번 출력 결과가 다르게 나옴
// 작업들을 동시적으로 실행하기 원한다면, 병렬 디스패치 큐를 만드는 방법을 사용하는 것이 좋음.
```

