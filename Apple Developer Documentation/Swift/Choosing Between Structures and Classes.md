# Choosing Between Structures and Classes

데이터를 저장하고 행동을 모델링하는 방법을 결정하기

---

## 개요

구조체 및 클래스는 애플리케이션에서 데이터를 저장하고 행동을 모델링하기 위한 좋은 선택이지만, 그들의 비슷함은 어떠한 하나를 선택하는 것을 어렵게 만들 수 있다.

다음의 권고 사항을 고려하여 애플리케이션에 새로운 데이터 타입을 추가할 때 어떠한 선택지가 더 말이 되는 것인지 선택하라.

- 기본적으로 구조체를 사용하라.
- Objective-C와의 호환이 필요하다면 클래스를 사용하라.
- 당신이 모델링한 데이터의 동일함을 제어할 필요가 있다면 클래스를 사용하라.
- 구현을 공유하는 것으로 행동을 채택하기 위해 프로토콜과 함께 구조체를 사용하라.

## 기본적으로 구조체를 사용하라.

일반적인 종류의 데이터를 나타내기 위해 구조체를 사용하라. Swift에서 구조체는 다른 언어에서는 클래스에 제한된 많은 기능을 포함한다. 저장 프로퍼티, 연산 프로퍼티, 그리고 메소드를 포함할 수 있다. 게다가, Swift의 구조체는 기본 구현을 통해 행동을 획득하기 위해 프로토콜을 채택할 수 있다. Swift 스탠더드 라이브러리 및 Foundation은 숫자, 문자열, 어레이, 그리고 딕셔너리와 같은 당신이 자주 사용하는 타입에 대하여 구조체를 사용한다.

구조체를 사용하는 것은 애플리케이션의 전체 상태에 대해 고려할 필요 없이 코드의 일부분에 대해 쉽게 추리할 수 있다. 구조체는 클래스와 다르게 값 타입이기 때문에, 구조체에 대한 지역적 변화는 애플리케이션의 흐름 부분에서 그러한 변화에 의도적으로 상호작용하지 않는다면, 애플리케이션의 나머지 부분에서 보이지 않는다. 결과적으로, 코드의 섹션을 볼 수 있고, 그 섹션에서의 인스턴스 변화가 접선적으로 관련된 함수 호출에서 보이지 않게 되기보다는, 명시적으로 일어났음을 확신할 수 있다.

## Objective-C와의 호환이 필요하다면 클래스를 사용하라.

데이터를 처리하기 위해 필요한 Objective-C API를 사용한다면, 또는 Objective-C 프레임워크에서 정의된 이미 존재하는 클래스 계층 구조와 당신의 데이터 모델을 맞출 필요가 있다면, 데이터를 모델링하기 위해 클래스 및 클래스 상속을 사용할 필요가 있을 것이다. 예를 들어, 많은 Objective-C 프레임워크들은 당신이 서브클래싱할 것으로 기대되는 클래스들을 노출한다.

## 동등함을 제어할 필요가 있다면 클래스를 사용하라.

Swift의 클래스는 참조 타입이기 때문에 동등함이라는 내장 개념으로부터 온다. 이는 두 개의 다른 클래스 인스턴스가 각각의 저장 프로퍼티에 대하여 같은 값을 가지고 있을 때, 동등 연산자(`===`)에 의해 여전히 다른 것으로 간주되는 것을 의미한다. 또한 어떠한 클래스 인스턴스를 애플리케이션을 가로질러 공유할 때, 그 인스턴스에 행한 변화는 그 인스턴스에 대한 참조를 가지고 있는 코드 전체에서 보인다는 것을 의미한다. 이러한 종류의 동등함을 갖는 것을 당신의 인스턴스가 요구할 때 클래스를 사용하라. 일반적인 사용 케이스로는 파일 처리, 네트워크 연결, `CBCentralManager`와 같은 공유 하드웨어 중계자가 있다.

예를 들어, 로컬 데이터베이스 연결을 나타내는 타입을 가지고 있다면, 데이터베이스에 대한 연결을 관리하는 코드는 애플리케이션에서 보는 데이터베이스의 상태를 완전하게 제어해야 할 필요가 있다. 이러한 경우에 클래스를 사용하는 것이 적절하지만, 애플리케이션의 어느 지점에서 공유 데이터베이스 오브젝트에 접근할 것인지를 제한해야 한다.

> **중요** 동등함을 조심스럽게 다루어라. 애플리케이션 도처에서 클래스 인스턴스를 만연하게 공유하는 것은 논리 오류를 만들기 쉽다. 많이 공유된 인스턴스를 변경하면 어떠한 결과가 발생할지 예상하지 못할 수 있으므로, 이러한 코드를 정확하게 작성하는 것이 더 효과적이다.

## 동등함을 제어할 필요가 없다면 구조체를 사용하라.

동등함을 제어할 필요가 없는 엔티티에 대한 정보를 포함하는 데이터를 모델링할 때 구조체를 사용하라.

예를 들어, 원격 데이터베이를 참고하는 애플리케이션에서, 인스턴스의 동등함은 외부 엔티티에 의해 완전히 소유되며 식별자에 의해 소통된다. 애플리케이션 모델의 일관성이 서버에 저장된다면, 식별자를 가진 구조체로 레코드를 모델링할 수 있다. 아래의 예제에서, `jsonResponse`는 서버로부터 온 `PenPalRecord` 인스턴스를 인코딩한 결과를 포함한다.

```swift
struct PenPalRecord {
  let myID: Int
  var myNickname: String
  var recommendedPenPalID: Int
}
var myRecord = try JSONDecoder().decode(PenPalRecord.self, from: jsonResponse)
```

`PenPalRecord`와 같은 모델 타입에 대한 로컬 변화는 유용하다. 예를 들어, 애플리케이션은 사용자 피드백에 대한 응답으로 여러 개의 다른 펜팔을 추천할 수 있을 것이다. `PenPalRecord` 구조체는 데이터베이스 레코드에 기반한 동등함을 제어하지 않기 때문에, 로컬 `PenPalRecord` 인스턴스의 변경으로 데이터베이스에서 값이 실수로 변경될 위험은 없다.

애플리케이션의 또다른 부분이 `myNickname`을 변경하고 변화 요청을 서버에 제출한다면, 가장 최근에 거부된 펜팔 추천은 그 변화에 의해 실수로 선택되지 않을 것이다. `myID` 프로퍼티는 상수로 선언되었기 때문에, 로컬에서 변화될 수 없다. 결과적으로, 데이터베이스에 대한 요청은 잘못된 레코드로 실수로 변화하지 않는다.

## 모델을 상속하고 행동을 공유하기 위해 구조체 및 프로토콜을 사용하라.

구조체 및 클래스는 모두 상속의 형태를 지원한다. 구조체 및 프로토콜은 오직 프로토콜만을 채택할 수 있으며, 클래스로부터 상속될 수 없다. 그러나, 당신이 클래스 상속에서 만들 수 있는 상속 계층 구조의 종류는 또한 프로토콜 상속 및 구조체를 사용하여 모델링될 수 있다.

처음부터 상속 관계를 구축하는 경우, 프로토콜 상속 방식을 선호하라. 프로토콜은 상속에서 클래스, 구조체 및 열거형을 허용하는 반면, 클래스 상속은 오직 다른 클래스와 호환된다. 데이터를 모델링하는 방법을 선택할 때, 처음에는 프로토콜 상속을 사용한 데이터 타입의 계층 구조를 구축하려 노력하고, 그리고 나서 그러한 프로토콜을 구조체가 채택하게 하라.