# Collection View Programming Guide for iOS

## About iOS Collection Views

컬렉션 뷰는 유연하고 변경 가능한 레이아웃을 사용하여 순서 있는 데이터 아이템들의 집합을 나타내는 방법이다. 컬렉션 뷰를 사용하는 가장 흔한 경우는 격자 모양의 정렬에서 아이템을 나타내기 위한 것이지만, iOS에서 컬렉션 뷰는 단지 행과 열의 이상의 능력을 가지고 있다. 컬렉션 뷰를 사용하여 시각적 요소의 정확한 레이아웃은 서브클래싱을 통하여 정의 가능하고 동적으로 변화할 수 있으므로, 격자, 스택, 원형 레이아웃, 동적으로 변화하는 레이아웃, 또는 상상할 수 있는 어떠한 형태의 정렬이라도 구현할 수 있다.

컬렉션 뷰는 나타나질 데이터와 그 데이터를 나타내기 위해 사용되는 시각적 요소를 명확하게 구분한다. 대부분의 경우에 앱은 데이터를 관리할 책임이 있다. 또한 그 데이터를 나타내기 위해 사용되는 뷰 객체를 제공한다. 이후에 컬렉션 뷰는 뷰들을 가지고 화면에 배치하는 모든 작업을 한다. 그것은 레이아웃 객체와 결합하여 이 작업을 하며, 레이아웃 객체는 뷰의 배치와 시각적 특성들을 지정하고 앱의 정확한 니즈를 충족시키기 위해 서브클래싱될 수 있다. 그러므로 당신은 데이터를 제공하고, 레이아웃 객체는 배치 정보를 제공하고, 컬렉션 뷰는 두 조각을 결합하여 최종의 모습을 만들어낸다.

### At a Glance

기본 iOS 컬렉션 뷰 클래스들은 단순한 격자 모양을 구현하기 위해 필요로 하는 모든 동작을 제공한다. 또한 기본 클래스를 확장하여 커스텀 레이아웃을 만들고 그러한 레이아웃에 특정한 인터랙션을 구현할 수 있다.

#### A Collection View Manages the Visual Presentation of Data-Driven Views

컬렉션 뷰는 앱이 제공한 데이터에 따른 뷰를 쉽게 나타낸다. 컬렉션 뷰는 오직 뷰를 가지고 특정 방식으로 배치하는 것에만 관심이 있다. 컬렉션 뷰는 그 컨텐츠가 아닌, 뷰들의 표현과 정렬에 관한 것이다. 컬렉션 뷰, 그것의 데이터 소스, 레이아웃 객체, 그리고 커스텀 객체 간 인터랙션을 이해하는 것이 특히 영리하고 능률적인 방식으로 컬렉션 뷰를 사용하는 것에서 중요하다.

#### The Flow Layout Supports Grids and Other Line-Oriented Presentations

플로우 레이아웃 객체는 UIKit이 제공하는 구체적인 레이아웃 객체다. 일반적으로 플로우 레이아웃 객체를 사용하여 격자 모양, 즉 아이템의 행과 열을 구현한다. 하지만 플로우 레이아웃은 선형적인 흐름의 종류만을 지원한다. 단지 격자 모양만을 위한 것은 아니기 때문에 서브클래싱을 하든 하지 않든 컨텐츠를 흥미롭고 유연하게 정렬하기 위해 플로우 레이아웃을 만들어 사용할 수 있다. 플로우 레이아웃은 다른 크기, 아이템들의 다양한 간격, 커스텀 헤더 및 푸터, 커스텀 마진을 서브클래싱 없이도 제공한다. 플로우 레리아웃 클래스를 서브클래싱하여 그 동작을 더욱 비틀 수 있다.

#### Gesture Recognizers Can Be Used for Cell and Layout Manipulations

다른 모든 뷰들처럼, 컬렉션 뷰에 제스처 레코그나이저를 붙여 뷰의 컨텐츠를 조작할 수 있다. 컬렉션 뷰는 여러 개의 뷰가 함께 동작하기 때문에, 컬렉션 뷰의 제스처 레코그나이저를 통합하기 위한 기본 테크닉을 이해하는 것을 돕는다. 레이아웃 특성을 비틀거나 컬렉션 뷰에 있는 아이템을 조작하기 위해 제스처 레코그나이저를 사용할 수 있다..

#### Custom Layouts Let You Go Beyond Grids

커스텀 레이아웃을 구현하기 위해 기본 레이아웃 오브젝트를 서브클래싱할 수 있다. 커스텀 레이아웃을 설계하는 것은 일반적으로 많은 양의 코드를 요구하지는 않지만, 레이아웃이 어떻게 작동하는지 더 많이 안다면 더욱 능률적으로 레이아웃 오브젝트를 설계할 수 있을 것이다. 이 가이드의 마지막 챕터는 커스텀 레이아웃의 완전한 구현이 있는 예제 프로젝트에 집중한다.

### Prerequisites

이 문서를 읽기 전에 iOS 앱에서 뷰의 역할을 잘 이해하고 있어야 한다. iOS 프로그래밍을 처음 해보거나 iOS의 뷰 아키텍쳐에 익숙하지 않다면 이를 읽기 전 View Programming Guide for iOS를 먼저 읽어라.

### See Also

컬렉션 뷰는 테이블 뷰와 어느 정도 관계가 있다. 둘 모두 사용자에게 순서 있는 데이터를 나타낸다. 테이블 뷰의 구현은 (제공되는 플로우 레이아웃을 사용하는) 기본적인 컬렉션 뷰의 구현과 닮아 있다. 인덱스 패스, 셀, 뷰 재활용을 사용한다. 그러나 테이블 뷰의 시각적 표현은 단일 열 레이아웃에 알맞게 설계된 반면, 컬렉션 뷰는 많은 다른 레이아웃도 지원할 수 있다. Table View Programming Guide for iOSd에서 테이블 뷰에 대한 더 많은 정보를 확인하라.

## Collection View Basics

컨텐츠를 화면에 나타내기 위해 컬렉션 뷰는 많은 다른 객체들과 협력한다. 몇몇 객체는 커스터마이징되며 반드시 제공되어야 한다. 예를 들어 컬렉션 뷰가 얼마나 많은 아이템을 표시해야 하는지 알리기 위해 데이터 소스 객체를 제공해야 한다. 다른 객체들은 UIKit이 제공하며 기본적인 컬렉션 뷰 디자인의 일부분이 된다.

테이블처럼 컬렉션 뷰는 데이터 지향 객체이며, 그 구현은 앱의 객체와의 협력을 포함한다. 코드에서 무엇을 해야 하는지 이해하는 것은 컬렉션 뷰가 하는 것에 대한 약간의 배경 지식을 필요로 한다.

### A Collection View Is a Collaboration of Objects

컬렉션 뷰의 설계는 보여질 데이터를 그것이 화면에 정렬되고 나타나는 방법과 분리한다. 보여질 데이터를 관리할 책임이 있더라도 그 시각적 표현은 많은 다른 객체가 관리한다. 다음의 표는 UIKit에 있는 컬렉션 뷰 클래스들을 나타내고 컬렉션 뷰 인터페이스를 구현하는 것에서 그것들이 수행하는 역할에 따라 구분되었다. 대부분의 클래스들은 서브클래싱할 필요 없이 있는 그대로 사용되기 위해 설계되었다. 그러므로 보통 매우 적은 코드를 작성하여 컬렉션 뷰를 구현할 수 있다. 그리고 제공된 동작 이상의 것을 원한다면 서브클래싱하여 그 동작을 제공할 수 있다.

| 목적                | 클래스 및 프로토콜                                           | 설명                                                         |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 최상위 보관 및 관리 | UICollectionView<br />UICollectionViewController             | `UICollectionView` 객체는 컬렉션 뷰의 컨텐츠를 위한 보여질 수 있는 영역을 정의한다. 이 클래스는 `UIScrollView`의 자식이며 필요한 만큼 큰 스크롤 가능한 영역을 포함할 수 있다. 또한 레이아웃 객체에서 받은 레이아웃 정보에 기반한 데이터의 표현을 촉진한다.<br />`UICollectionViewController` 객체는 컬렉션 뷰에 대하여 뷰 컨트롤러 수준의 관리를 지원한다. 이것의 사용은 선택적이다. |
| 컨텐츠 관리         | UICollectionViewDataSource 프로토콜<br />UICollectionViewDelegate 프로토콜 | *데이터 소스 객체*는 컬렉션 뷰와 연관되는 가장 중요한 객체이며 반드시 제공해야 하는 것이다. 데이터 소스는 컬렉션 뷰의 컨텐츠를 관리하고 그 컨텐츠를 나타내기 위해 필요한 뷰를 만든다. 데이터 소스 객체를 구현하기 위해 `UICollectionViewDataSource` 프로토콜을 준수하는 객체를 반드시 만들어야 한다.<br />컬렉션 뷰의 델리게이트 객체는 컬렉션 뷰로부터 흥미 있는 메세지를 가로채고, 뷰의 동작을 커스터마이징할 수 있게 한다. 예를 들어 델리게이트 객체를 사용하여 컬렉션 뷰의 아이템의 선택과 하이라이팅을 추적할 수 있다. 데이터 소스 객체와는 다르게 델리게이트 객체는 선택적이다. Designing Your Data Source and Delegate에서 데이터 소스 객체와 델리게이트 객체를 구현하는 방법에 대한 정보를 확인하라. |
| 표현                | UICollectionViewReusableView<br />UICollectionViewCell       | 컬렉션 뷰에 표시되는 모든 뷰는 `UICollectionViewReusableView` 클래스의 인스턴스여야 한다. 이 클래스는 컬렉션 뷰가 사용하는 재활용 매커니즘을 재원한다. 새로운 뷰를 만드는 대신 재활용하는 것은 일반적으로 성능을 향상시키며 특히 스크롤하는 동안의 성능을 향상시킨다.<br />`UICollectionViewCell` 객체는 메인 데이터 아이템을 위해 사용하는 재사용 가능한 뷰의 특정 타입이다. |
| 레이아웃            | UICollectionViewLayout<br />UICollectionViewLayoutAttributes<br />UICollectionViewUpdateItem | `UICollectionViewLayout`의 서브클래스들은 *레이아웃 객체*로 언급되며 셀의 위치, 크기, 시각적 특성과 컬렉션 뷰 내의 재사용 가능한 뷰를 정의하는 책임을 갖는다.<br />레이아웃 프로세스가 진행되는 동안 레이아웃 객체는 레이아웃 특성 객체 (`UICollectionViewLayoutAttributes`의 인스턴스) 를 만든다. 이는 컬렉션 뷰에게 셀과 재사용 가능한 뷰가 어디에, 어떻게 표시되는지를 알린다.<br />레이아웃 객체는 데이터 아이템이 컬렉션 뷰 내에서 삽입, 삭제, 이동될 때마다 `UICollectionViewUpdateItem` 클래스의 인스턴스를 받는다. 이 클래스의 인스턴스를 직접 생성할 필요는 절대 없다.<br />The Layout Object Controls the Visual Presentation에서 레이아웃 객체에 대한 더 많은 정보를 확인하라. |
| 플로우 레이아웃     | UICollectionViewFlowLayout<br />UICollectionViewDelegateFlowLayout 프로토콜 | `UICollectionViewFlowLayout` 클래스는 격자 또는 다른 선 기반 레이아웃을 구현하기 위해 사용하는 구체적인 레이아웃 객체다. 이 클래스를 있는 그대로 사용하거나, 플로우 델리게이트 객체와 결합하여 사용할 수 있다. 이는 동적으로 레이아웃 정보를 커스터마이징할 수 있도록 해준다. |

컬렉션 뷰는 데이터 소스에서 표시할 셀에 대한 정보를 얻는다. 데이터 소스 객체와 델리게이트 객체는 앱이 제공하는 커스텀 객체이며, 셀의 선택 및 하이라이팅을 포함하여 컨텐츠를 관리하기 위해 사용된다. 레이아웃 객체는 그러한 셀들이 어디에 속하는지 결정하고 하나 또는 그 이상의 레이아웃 특성 객체의 형태로 컬렉션 뷰에게 그 정보를 전달할 책임이 있다. 컬렉션 뷰는 실제 셀과 다른 뷰의 레이아웃 정보를 결합하여 최종의 시각적 표현을 만들어낸다.

컬렉션 뷰 인터페이스를 만들 때 먼저 스토리보드나 xib 파일에 `UICollectionView` 객체를 추가하라. 컬렉션 뷰를 중앙 허브로 생각하여, 모든 다른 객체가 그것에서 나온다고 생각하라. 그 객체를 추가한 후, 데이터 소스나 델리게이트와 같은 관련 있는 객체를 구성하는 것을 시작할 수 있다. 모든 구성은 컬렉션 뷰 그 자체 주변에서 중앙화된다. 예를 들어 컬렉션 뷰 객체를 만들지 않고 레이아웃 객체를 만들 수 없다.

### Reusable Views Improve Performance

컬렉션 뷰는 효율을 향상시키기 윙해 뷰 재활용 프로그램을 사용한다. 뷰가 화면 밖으로 이동하면 뷰는 제거되고 삭제되는 대신 재사용 큐에 위치하게 된다. 새로운 컨텐츠가 화면에 스크롤되면 뷰는 큐에서 제거되고 새로운 컨텐츠와 함께 다시 적용된다. 이 재활용 및 재사용을 촉진하기 위해 컬렉션 뷰가 표시하는 모든 뷰는 반드시 `UICollectionReusableView` 클래스로부터 상속받아야 한다.

컬렉션 뷰는 세 개의 재사용 뷰의 개별 타입을 지원한다. 각각은 의도된 특정 사용 방법을 갖는다.

- *셀*은 컬렉션 뷰의 메인 컨텐츠를 나타낸다. 셀의 역할은 데이터 소스 객체로부터 단일 아이템을 위한 컨텐츠를 나타내는 것이다. 각각의 셀은 반드시 `UICollectionViewCell` 클래스의 인스턴스여야 하며, 필요하다면 컨텐츠를 나타내기 위해 서브클래싱할 수 있을 것이다. 셀 객체는 선택 및 하이라이팅 상태를 관리하기 위한 고유의 지원을 제공한다. 실제로 셀에 하이라이팅을 적용하려면 반드시 커스텀 코드를 작성해야 한다. Managing the Visual State for Selections and Highlights에서 셀 하이라이팅 및 선택 구현에 대한 정보를 확인하라.
- *서플멘터리 뷰*는 섹션에 관한 정보를 표시한다. 셀처럼 서플먼터리 뷰도 데이터 기반으로 동작한다. 셀과는 다르게 서플먼터리 뷰는 필수가 아니며, 그것의 사용과 배치는 사용되는 레이아웃 객체가 관리한다. 예를 들어 플로우 레이아웃은 선택적인 서플먼터리 뷰로 헤더와 푸터를 지원한다.
- *데코레이션 뷰*는 레이아웃 객체가 완전히 소유하는 시각적 장식이며 데이터 소스 객체의 어떠한 데이터에도 묶여 있지 않다. 예를 들어 레이아웃 객체는 커스터마이징한 배경의 모습을 구현하기 위해 데코레이션 뷰를 사용할 수 있을 것이다.

테이블 뷰와는 다르게, 컬렉션 뷰는 데이터 소스가 제공하는 셀과 서플먼터리 뷰에 대하여 어떠한 특정 스타일도 강요하지 않는다. 대신 기본 재사용 가능한 뷰 클래스들은 당신이 수정해야 하는 빈 캔버스다. 예를 들어 작은 뷰 계층 구조를 만들기 위해, 이미지를 표시하기 위해, 심지어 동적으로 컨텐츠를 그리기 위해 그것들을 사용할 수 있다.

데이터 소스 객체는 연관된 컬렉션 뷰가 사용하는 셀과 서플먼터리 뷰를 제공해야 하는 책임이 있다. 그러나 데이터 소스는 절대 뷰를 직접적으로 만들지 않는다. 뷰가 요청할 때 데이터 소스는 컬렉션 뷰의 메소드를 사용하여 바람직한 타입의 뷰를 큐에서 빼낸다. 큐에서 빼내는 프로세스는 항상 유효한 뷰를 반환하는데, 재사용 큐에서 되돌려받거나 새로운 뷰를 만들기 위해 제공한 클래스, xib 파일, 또는 스토리보드를 사용한다.

Configuring Cells and Supplementary Views에서 데이터 소스로부터 뷰를 만들고 구성하는 방법에 대한 정보를 확인하라.

### The Layout Object Controls the Visual Presentation

레이아웃 객체는 단독으로 컬렉션 뷰 내에서 아이템의 배치와 시각적 스타일링을 결정할 책임이 있다. 데이터 소스 객체가 뷰와 실제 컨텐츠를 제공할지라도, 레이아웃 객체는 그러한 뷰들의 크기, 위치, 겉모습과 관련된 다른 특성을 결정한다. 이러한 책임 분리는 앱이 관리하는 데이터 객체의 변화 없이 레이아웃을 동적으로 변경할 수 있게 한다.

컬렉션 뷰가 사용하는 레이아웃 프로세스는 앱의 나머지 뷰가 사용하는 레이아웃 프로세스와 관련 있지만 구분된다. 즉 레이아웃 객체가 부모 뷰 내에서 자식 뷰의 위치를 재설정하기 위해 사용되는 `layoutSubviews` 메소드가 하는 일을 혼동하지 마라. 레이아웃 객체는 그것이 관리하는 뷰를 절대 직접적으로 건드리지 않는다. 실제로 그러한 뷰들 중 어느 것도 소유하고 있지 않기 때문이다. 대신 컬렉션 뷰의 셀, 서플먼터리 뷰, 데코레이션 뷰의 위치, 크기, 시각적 겉모습을 묘사하는 특성을 생성한다. 그러한 특성들을 실제 뷰 객체에 적용하는 것은 컬렉션 뷰의 역할이다.

레이아웃 객체가 컬렉션 뷰에 있는 뷰들에 영향을 미칠 수 있는 방법에는 제한이 없다. 레이아웃 객체는 뷰를 이동시킬 수 있지만 다른 것들은 안된다. 오직 약간만 뷰를 이동시킬 수 있거나, 화면 주위에서 임의로 이동시킬 수 있다. 심지어 주위의 뷰에 상관 없이 뷰의 위치를 다시 설정할 수 있다. 예를 들어 레이아웃 객체는 원한다면 서로의 상단에 뷰를 쌓을 수 있다. 유일한 제한은 레이아웃 객체가 원하는 시각적 스타일에 어떻게 영향을 미치는지에 대한 것이다.

수직 방향으로 스크롤되는 플로우 레이아웃에서 컨텐츠 영역의 너비는 고정되고 높이는 컨텐츠에 적합해지기 위해 늘어난다. 영역을 계산하기 위해 레이아웃 객체는 뷰와 셀을 차례대로 배치하고 서로에게 가장 알맞는 위치를 선택한다. 플로우 레이아웃의 경우에 셀과 서플먼터리 뷰의 크기는 특성에 의해 지정되는데, 이는 레이아웃 객체나 델리게이트를 사용하여 지정된다. 레이아웃을 계산하는 것은 각각의 뷰를 배치하기 위해 그러한 특성들을 사용하는 것에 대한 문제다.

레이아웃 객체는 뷰들의 크기와 위치뿐만 아니라 그 이상의 것들을 제어한다. 레이아웃 객체는 투명도, 3차원 공간에서의 변형, 다른 뷰의 위 또는 아래에서의 가시성과 같은 뷰와 관련된 다른 특성들을 지정할 수 있다. 이러한 특성들은 더욱 흥미로운 레이아웃을 만들 수 있게 해준다. 예를 들어 뷰를 또 다른 뷰의 위에 배치하고 그들의 z축 순서를 변경하여 셀의 스택을 만들 수 있을 것이며, 어떠한 축으로의 회전을 통한 변형을 사용할 수 있을 것이다.

Creating Custom Layouts에서 레이아웃 객체가 컬렉션 뷰에서 그 책임을 어떻게 충족시키는지에 대한 더 자세한 정보를 확인하라.

### Collection Views Initiate Animations Automatically

컬렉션 뷰는 기초 수준에서 애니메이션을 지원한다. 아이템이나 섹션을 삽입하거나 삭제할 때 컬렉션 뷰는 자동으로 변화에 영향을 주는 뷰들에 애니메이션 효과를 준다. 예를 들어 아이템을 삽입할 때 삽입 포인트 이후의 아이템들은 보통 새로운 아이템을 위한 자리를 만들기 위해 이동된다. 컬렉션 뷰는 아이템들의 현재 위치를 감지하고 삽입이 일어난 후 그것들의 최종 위치를 계산할 수 있기 때문에 이러한 애니메이션을 만들 수 있다. 그러므로 각각의 아이템은 처음 위치에서 최종 위치로 애니메이션과 함께 이동될 수 있다.

삽입, 삭제, 이동 작업에서 애니메이션 효과를 주는 것뿐만 아니라, 언제든 레이아웃을 무효화할 수 있고 레이아웃 특성들을 다시 계산하도록 강제할 수 있다. 레이아웃을 무효화하는 것은 직접적으로 아이템들에 애니메이션 효과를 주지 않는다. 레이아웃을 무효화할 때 컬렉션 뷰는 애니메이션 없이 새롭게 계산된 위치에 아이템들을 표시한다. 대신 커스텀 레이아웃에서 일정 간격으로 셀을 배치하고 애니메이션 효과를 만들기 위해 이 동작을 사용할 수 있을 것이다.